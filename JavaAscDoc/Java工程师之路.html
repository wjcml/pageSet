<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.18">
<meta name="author" content="汪俊程">
<title>Java工程师之路</title>
<style>
/*! normalize.css v2.1.2 | MIT License | git.io/normalize */
/* ========================================================================== HTML5 display definitions ========================================================================== */
/** Correct `block` display not defined in IE 8/9. */
article, aside, details, figcaption, figure, footer, header, hgroup, main, nav, section, summary { display: block; }

/** Correct `inline-block` display not defined in IE 8/9. */
audio, canvas, video { display: inline-block; }

/** Prevent modern browsers from displaying `audio` without controls. Remove excess height in iOS 5 devices. */
audio:not([controls]) { display: none; height: 0; }

/** Address `[hidden]` styling not present in IE 8/9. Hide the `template` element in IE, Safari, and Firefox < 22. */
[hidden], template { display: none; }

script { display: none !important; }

/* ========================================================================== Base ========================================================================== */
/** 1. Set default font family to sans-serif. 2. Prevent iOS text size adjust after orientation change, without disabling user zoom. */
html { font-family: sans-serif; /* 1 */ -ms-text-size-adjust: 100%; /* 2 */ -webkit-text-size-adjust: 100%; /* 2 */ }

/** Remove default margin. */
body { margin: 0; }

/* ========================================================================== Links ========================================================================== */
/** Remove the gray background color from active links in IE 10. */
a { background: transparent; }

/** Address `outline` inconsistency between Chrome and other browsers. */
a:focus { outline: thin dotted; }

/** Improve readability when focused and also mouse hovered in all browsers. */
a:active, a:hover { outline: 0; }

/* ========================================================================== Typography ========================================================================== */
/** Address variable `h1` font-size and margin within `section` and `article` contexts in Firefox 4+, Safari 5, and Chrome. */
h1 { font-size: 2em; margin: 0.67em 0; }

/** Address styling not present in IE 8/9, Safari 5, and Chrome. */
abbr[title] { border-bottom: 1px dotted; }

/** Address style set to `bolder` in Firefox 4+, Safari 5, and Chrome. */
b, strong { font-weight: bold; }

/** Address styling not present in Safari 5 and Chrome. */
dfn { font-style: italic; }

/** Address differences between Firefox and other browsers. */
hr { -moz-box-sizing: content-box; box-sizing: content-box; height: 0; }

/** Address styling not present in IE 8/9. */
mark { background: #ff0; color: #000; }

/** Correct font family set oddly in Safari 5 and Chrome. */
code, kbd, pre, samp { font-family: monospace, serif; font-size: 1em; }

/** Improve readability of pre-formatted text in all browsers. */
pre { white-space: pre-wrap; }

/** Set consistent quote types. */
q { quotes: "\201C" "\201D" "\2018" "\2019"; }

/** Address inconsistent and variable font size in all browsers. */
small { font-size: 80%; }

/** Prevent `sub` and `sup` affecting `line-height` in all browsers. */
sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; }

sup { top: -0.5em; }

sub { bottom: -0.25em; }

/* ========================================================================== Embedded content ========================================================================== */
/** Remove border when inside `a` element in IE 8/9. */
img { border: 0; }

/** Correct overflow displayed oddly in IE 9. */
svg:not(:root) { overflow: hidden; }

/* ========================================================================== Figures ========================================================================== */
/** Address margin not present in IE 8/9 and Safari 5. */
figure { margin: 0; }

/* ========================================================================== Forms ========================================================================== */
/** Define consistent border, margin, and padding. */
fieldset { border: 1px solid #c0c0c0; margin: 0 2px; padding: 0.35em 0.625em 0.75em; }

/** 1. Correct `color` not being inherited in IE 8/9. 2. Remove padding so people aren't caught out if they zero out fieldsets. */
legend { border: 0; /* 1 */ padding: 0; /* 2 */ }

/** 1. Correct font family not being inherited in all browsers. 2. Correct font size not being inherited in all browsers. 3. Address margins set differently in Firefox 4+, Safari 5, and Chrome. */
button, input, select, textarea { font-family: inherit; /* 1 */ font-size: 100%; /* 2 */ margin: 0; /* 3 */ }

/** Address Firefox 4+ setting `line-height` on `input` using `!important` in the UA stylesheet. */
button, input { line-height: normal; }

/** Address inconsistent `text-transform` inheritance for `button` and `select`. All other form control elements do not inherit `text-transform` values. Correct `button` style inheritance in Chrome, Safari 5+, and IE 8+. Correct `select` style inheritance in Firefox 4+ and Opera. */
button, select { text-transform: none; }

/** 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio` and `video` controls. 2. Correct inability to style clickable `input` types in iOS. 3. Improve usability and consistency of cursor style between image-type `input` and others. */
button, html input[type="button"], input[type="reset"], input[type="submit"] { -webkit-appearance: button; /* 2 */ cursor: pointer; /* 3 */ }

/** Re-set default cursor for disabled elements. */
button[disabled], html input[disabled] { cursor: default; }

/** 1. Address box sizing set to `content-box` in IE 8/9. 2. Remove excess padding in IE 8/9. */
input[type="checkbox"], input[type="radio"] { box-sizing: border-box; /* 1 */ padding: 0; /* 2 */ }

/** 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome. 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome (include `-moz` to future-proof). */
input[type="search"] { -webkit-appearance: textfield; /* 1 */ -moz-box-sizing: content-box; -webkit-box-sizing: content-box; /* 2 */ box-sizing: content-box; }

/** Remove inner padding and search cancel button in Safari 5 and Chrome on OS X. */
input[type="search"]::-webkit-search-cancel-button, input[type="search"]::-webkit-search-decoration { -webkit-appearance: none; }

/** Remove inner padding and border in Firefox 4+. */
button::-moz-focus-inner, input::-moz-focus-inner { border: 0; padding: 0; }

/** 1. Remove default vertical scrollbar in IE 8/9. 2. Improve readability and alignment in all browsers. */
textarea { overflow: auto; /* 1 */ vertical-align: top; /* 2 */ }

/* ========================================================================== Tables ========================================================================== */
/** Remove most spacing between table cells. */
table { border-collapse: collapse; border-spacing: 0; }

meta.foundation-mq-small { font-family: "only screen and (min-width: 768px)"; width: 768px; }

meta.foundation-mq-medium { font-family: "only screen and (min-width:1280px)"; width: 1280px; }

meta.foundation-mq-large { font-family: "only screen and (min-width:1440px)"; width: 1440px; }

*, *:before, *:after { -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box; }

html, body { font-size: 100%; }

body { background: white; color: rgba(0, 0, 0, 0.8); padding: 0; margin: 0; font-family: "Noto Serif", "DejaVu Serif", serif; font-weight: normal; font-style: normal; line-height: 1; position: relative; cursor: auto; }

a:hover { cursor: pointer; }

img, object, embed { max-width: 100%; height: auto; }

object, embed { height: 100%; }

img { -ms-interpolation-mode: bicubic; }

#map_canvas img, #map_canvas embed, #map_canvas object, .map_canvas img, .map_canvas embed, .map_canvas object { max-width: none !important; }

.left { float: left !important; }

.right { float: right !important; }

.text-left { text-align: left !important; }

.text-right { text-align: right !important; }

.text-center { text-align: center !important; }

.text-justify { text-align: justify !important; }

.hide { display: none; }

.antialiased, body { -webkit-font-smoothing: antialiased; }

img { display: inline-block; vertical-align: middle; }

textarea { height: auto; min-height: 50px; }

select { width: 100%; }

object, svg { display: inline-block; vertical-align: middle; }

.center { margin-left: auto; margin-right: auto; }

.spread { width: 100%; }

p.lead, .paragraph.lead > p, #preamble > .sectionbody > .paragraph:first-of-type p { font-size: 1.21875em; line-height: 1.6; }

.subheader, .admonitionblock td.content > .title, .audioblock > .title, .exampleblock > .title, .imageblock > .title, .listingblock > .title, .literalblock > .title, .stemblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, table.tableblock > .title, .verseblock > .title, .videoblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title { line-height: 1.45; color: #7a2518; font-weight: normal; margin-top: 0; margin-bottom: 0.25em; }

/* Typography resets */
div, dl, dt, dd, ul, ol, li, h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6, pre, form, p, blockquote, th, td { margin: 0; padding: 0; direction: ltr; }

/* Default Link Styles */
a { color: #2156a5; text-decoration: underline; line-height: inherit; }
a:hover, a:focus { color: #1d4b8f; }
a img { border: none; }

/* Default paragraph styles */
p { font-family: 微软雅黑; font-weight: normal; font-size: 1em; line-height: 1.6; margin-bottom: 1.25em; text-rendering: optimizeLegibility; }
/* p { font-family: inherit; font-weight: normal; font-size: 1em; line-height: 1.6; margin-bottom: 1.25em; text-rendering: optimizeLegibility; } */
p aside { font-size: 0.875em; line-height: 1.35; font-style: italic; }

/* Default header styles */
h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { font-family: "Open Sans", "DejaVu Sans", sans-serif; font-weight: 300; font-style: normal; color: #ba3925; text-rendering: optimizeLegibility; margin-top: 1em; margin-bottom: 0.5em; line-height: 1.0125em; }
h1 small, h2 small, h3 small, #toctitle small, .sidebarblock > .content > .title small, h4 small, h5 small, h6 small { font-size: 60%; color: #e99b8f; line-height: 0; }

h1 { font-size: 2.125em; }

h2 { font-size: 1.6875em; }

h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.375em; }

h4 { font-size: 1.125em; }

h5 { font-size: 1.125em; }

h6 { font-size: 1em; }

hr { border: solid #ddddd8; border-width: 1px 0 0; clear: both; margin: 1.25em 0 1.1875em; height: 0; }

/* Helpful Typography Defaults */
em, i { font-style: italic; line-height: inherit; }

strong, b { font-weight: bold; line-height: inherit; }

small { font-size: 60%; line-height: inherit; }

code { font-family: "Droid Sans Mono", "DejaVu Sans Mono", monospace; font-weight: normal; color: rgba(0, 0, 0, 0.9); }

/* Lists */
ul, ol, dl { font-size: 1em; line-height: 1.6; margin-bottom: 1.25em; list-style-position: outside; font-family: inherit; }

ul, ol { margin-left: 1.5em; }
ul.no-bullet, ol.no-bullet { margin-left: 1.5em; }

/* Unordered Lists */
ul li ul, ul li ol { margin-left: 1.25em; margin-bottom: 0; font-size: 1em; /* Override nested font-size change */ }
ul.square li ul, ul.circle li ul, ul.disc li ul { list-style: inherit; }
ul.square { list-style-type: square; }
ul.circle { list-style-type: circle; }
ul.disc { list-style-type: disc; }
ul.no-bullet { list-style: none; }

/* Ordered Lists */
ol li ul, ol li ol { margin-left: 1.25em; margin-bottom: 0; }

/* Definition Lists */
dl dt { margin-bottom: 0.3125em; font-weight: bold; }
dl dd { margin-bottom: 1.25em; }

/* Abbreviations */
abbr, acronym { text-transform: uppercase; font-size: 90%; color: rgba(0, 0, 0, 0.8); border-bottom: 1px dotted #dddddd; cursor: help; }

abbr { text-transform: none; }

/* Blockquotes */
blockquote { margin: 0 0 1.25em; padding: 0.5625em 1.25em 0 1.1875em; border-left: 1px solid #dddddd; }
blockquote cite { display: block; font-size: 0.9375em; color: rgba(0, 0, 0, 0.6); }
blockquote cite:before { content: "\2014 \0020"; }
blockquote cite a, blockquote cite a:visited { color: rgba(0, 0, 0, 0.6); }

blockquote, blockquote p { line-height: 1.6; color: rgba(0, 0, 0, 0.85); }

/* Microformats */
.vcard { display: inline-block; margin: 0 0 1.25em 0; border: 1px solid #dddddd; padding: 0.625em 0.75em; }
.vcard li { margin: 0; display: block; }
.vcard .fn { font-weight: bold; font-size: 0.9375em; }

.vevent .summary { font-weight: bold; }
.vevent abbr { cursor: auto; text-decoration: none; font-weight: bold; border: none; padding: 0 0.0625em; }

@media only screen and (min-width: 768px) { h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { line-height: 1.2; }
  h1 { font-size: 2.75em; }
  h2 { font-size: 2.3125em; }
  h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.6875em; }
  h4 { font-size: 1.4375em; } }
/* Tables */
table { background: white; margin-bottom: 1.25em; border: solid 1px #dedede; }
table thead, table tfoot { background: #f7f8f7; font-weight: bold; }
table thead tr th, table thead tr td, table tfoot tr th, table tfoot tr td { padding: 0.5em 0.625em 0.625em; font-size: inherit; color: rgba(0, 0, 0, 0.8); text-align: left; }
table tr th, table tr td { padding: 0.5625em 0.625em; font-size: inherit; color: rgba(0, 0, 0, 0.8); }
table tr.even, table tr.alt, table tr:nth-of-type(even) { background: #f8f8f7; }
table thead tr th, table tfoot tr th, table tbody tr td, table tr td, table tfoot tr td { display: table-cell; line-height: 1.6; }

body { tab-size: 4; }

h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { line-height: 1.2; word-spacing: -0.05em; }
h1 strong, h2 strong, h3 strong, #toctitle strong, .sidebarblock > .content > .title strong, h4 strong, h5 strong, h6 strong { font-weight: 400; }

.clearfix:before, .clearfix:after, .float-group:before, .float-group:after { content: " "; display: table; }
.clearfix:after, .float-group:after { clear: both; }

*:not(pre) > code { font-size: 0.9375em; font-style: normal !important; letter-spacing: 0; padding: 0.1em 0.5ex; word-spacing: -0.15em; background-color: #f7f7f8; -webkit-border-radius: 4px; border-radius: 4px; line-height: 1.45; text-rendering: optimizeSpeed; border: 1px dashed #2f6fab;}

pre {border: 1px dashed gray;}

pre, pre > code { line-height: 1.45; color: rgba(0, 0, 0, 0.9); font-family: "Droid Sans Mono", "DejaVu Sans Mono", "Monospace", monospace; font-weight: normal; text-rendering: optimizeSpeed;}

.keyseq { color: rgba(51, 51, 51, 0.8); }

kbd { font-family: "Droid Sans Mono", "DejaVu Sans Mono", monospace; display: inline-block; color: rgba(0, 0, 0, 0.8); font-size: 0.65em; line-height: 1.45; background-color: #f7f7f7; border: 1px solid #ccc; -webkit-border-radius: 3px; border-radius: 3px; -webkit-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 0.1em white inset; box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 0.1em white inset; margin: 0 0.15em; padding: 0.2em 0.5em; vertical-align: middle; position: relative; top: -0.1em; white-space: nowrap; }

.keyseq kbd:first-child { margin-left: 0; }

.keyseq kbd:last-child { margin-right: 0; }

.menuseq, .menu { color: rgba(0, 0, 0, 0.8); }

b.button:before, b.button:after { position: relative; top: -1px; font-weight: normal; }

b.button:before { content: "["; padding: 0 3px 0 2px; }

b.button:after { content: "]"; padding: 0 2px 0 3px; }

p a > code:hover { color: rgba(0, 0, 0, 0.9); }

#header, #content, #footnotes, #footer { width: 100%; margin-left: auto; margin-right: auto; margin-top: 0; margin-bottom: 0; max-width: 62.5em; *zoom: 1; position: relative; padding-left: 0.9375em; padding-right: 0.9375em; }
#header:before, #header:after, #content:before, #content:after, #footnotes:before, #footnotes:after, #footer:before, #footer:after { content: " "; display: table; }
#header:after, #content:after, #footnotes:after, #footer:after { clear: both; }

#content { margin-top: 1.25em; }

#content:before { content: none; }

#header > h1:first-child { color: rgba(0, 0, 0, 0.85); margin-top: 2.25rem; margin-bottom: 0; }
#header > h1:first-child + #toc { margin-top: 8px; border-top: 1px solid #ddddd8; }
#header > h1:only-child, body.toc2 #header > h1:nth-last-child(2) { border-bottom: 1px solid #ddddd8; padding-bottom: 8px; }
#header .details { border-bottom: 1px solid #ddddd8; line-height: 1.45; padding-top: 0.25em; padding-bottom: 0.25em; padding-left: 0.25em; color: rgba(0, 0, 0, 0.6); display: -ms-flexbox; display: -webkit-flex; display: flex; -ms-flex-flow: row wrap; -webkit-flex-flow: row wrap; flex-flow: row wrap; }
#header .details span:first-child { margin-left: -0.125em; }
#header .details span.email a { color: rgba(0, 0, 0, 0.85); }
#header .details br { display: none; }
#header .details br + span:before { content: "\00a0\2013\00a0"; }
#header .details br + span.author:before { content: "\00a0\22c5\00a0"; color: rgba(0, 0, 0, 0.85); }
#header .details br + span#revremark:before { content: "\00a0|\00a0"; }
#header #revnumber { text-transform: capitalize; }
#header #revnumber:after { content: "\00a0"; }

#content > h1:first-child:not([class]) { color: rgba(0, 0, 0, 0.85); border-bottom: 1px solid #ddddd8; padding-bottom: 8px; margin-top: 0; padding-top: 1rem; margin-bottom: 1.25rem; }

#toc { border-bottom: 1px solid #efefed; padding-bottom: 0.5em; }
#toc > ul { margin-left: 0.125em; }
#toc ul.sectlevel0 > li > a { font-style: italic; }
#toc ul.sectlevel0 ul.sectlevel1 { margin: 0.5em 0; }
#toc ul { font-family: "Open Sans", "DejaVu Sans", sans-serif; list-style-type: none; }
#toc li { line-height: 1.3334; margin-top: 0.3334em; }
#toc a { text-decoration: none; }
#toc a:active { text-decoration: underline; }

#toctitle { color: #7a2518; font-size: 1.2em; }

@media only screen and (min-width: 768px) { #toctitle { font-size: 1.375em; }
  body.toc2 { padding-left: 15em; padding-right: 0; }
  #toc.toc2 { margin-top: 0 !important; background-color: #f8f8f7; position: fixed; width: 15em; left: 0; top: 0; border-right: 1px solid #efefed; border-top-width: 0 !important; border-bottom-width: 0 !important; z-index: 1000; padding: 1.25em 1em; height: 100%; overflow: auto; }
  #toc.toc2 #toctitle { margin-top: 0; margin-bottom: 0.8rem; font-size: 1.2em; }
  #toc.toc2 > ul { font-size: 0.9em; margin-bottom: 0; }
  #toc.toc2 ul ul { margin-left: 0; padding-left: 1em; }
  #toc.toc2 ul.sectlevel0 ul.sectlevel1 { padding-left: 0; margin-top: 0.5em; margin-bottom: 0.5em; }
  body.toc2.toc-right { padding-left: 0; padding-right: 15em; }
  body.toc2.toc-right #toc.toc2 { border-right-width: 0; border-left: 1px solid #efefed; left: auto; right: 0; } }
@media only screen and (min-width: 1280px) { body.toc2 { padding-left: 20em; padding-right: 0; }
  #toc.toc2 { width: 20em; }
  #toc.toc2 #toctitle { font-size: 1.375em; }
  #toc.toc2 > ul { font-size: 0.95em; }
  #toc.toc2 ul ul { padding-left: 1.25em; }
  body.toc2.toc-right { padding-left: 0; padding-right: 20em; } }
#content #toc { border-style: solid; border-width: 1px; border-color: #e0e0dc; margin-bottom: 1.25em; padding: 1.25em; background: #f8f8f7; -webkit-border-radius: 4px; border-radius: 4px; }
#content #toc > :first-child { margin-top: 0; }
#content #toc > :last-child { margin-bottom: 0; }

#footer { max-width: 100%; background-color: rgba(0, 0, 0, 0.8); padding: 1.25em; }

#footer-text { color: rgba(255, 255, 255, 0.8); line-height: 1.44; }

.sect1 { padding-bottom: 0.625em; }

@media only screen and (min-width: 768px) { .sect1 { padding-bottom: 1.25em; } }
.sect1 + .sect1 { border-top: 1px solid #efefed; }

#content h1 > a.anchor, h2 > a.anchor, h3 > a.anchor, #toctitle > a.anchor, .sidebarblock > .content > .title > a.anchor, h4 > a.anchor, h5 > a.anchor, h6 > a.anchor { position: absolute; z-index: 1001; width: 1.5ex; margin-left: -1.5ex; display: block; text-decoration: none !important; visibility: hidden; text-align: center; font-weight: normal; }
#content h1 > a.anchor:before, h2 > a.anchor:before, h3 > a.anchor:before, #toctitle > a.anchor:before, .sidebarblock > .content > .title > a.anchor:before, h4 > a.anchor:before, h5 > a.anchor:before, h6 > a.anchor:before { content: "\00A7"; font-size: 0.85em; display: block; padding-top: 0.1em; }
#content h1:hover > a.anchor, #content h1 > a.anchor:hover, h2:hover > a.anchor, h2 > a.anchor:hover, h3:hover > a.anchor, #toctitle:hover > a.anchor, .sidebarblock > .content > .title:hover > a.anchor, h3 > a.anchor:hover, #toctitle > a.anchor:hover, .sidebarblock > .content > .title > a.anchor:hover, h4:hover > a.anchor, h4 > a.anchor:hover, h5:hover > a.anchor, h5 > a.anchor:hover, h6:hover > a.anchor, h6 > a.anchor:hover { visibility: visible; }
#content h1 > a.link, h2 > a.link, h3 > a.link, #toctitle > a.link, .sidebarblock > .content > .title > a.link, h4 > a.link, h5 > a.link, h6 > a.link { color: #ba3925; text-decoration: none; }
#content h1 > a.link:hover, h2 > a.link:hover, h3 > a.link:hover, #toctitle > a.link:hover, .sidebarblock > .content > .title > a.link:hover, h4 > a.link:hover, h5 > a.link:hover, h6 > a.link:hover { color: #a53221; }

.audioblock, .imageblock, .literalblock, .listingblock, .stemblock, .videoblock { margin-bottom: 1.25em; }

.admonitionblock td.content > .title, .audioblock > .title, .exampleblock > .title, .imageblock > .title, .listingblock > .title, .literalblock > .title, .stemblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, table.tableblock > .title, .verseblock > .title, .videoblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title { text-rendering: optimizeLegibility; text-align: left; font-family: "Noto Serif", "DejaVu Serif", serif; font-size: 1rem; font-style: italic; }

table.tableblock > caption.title { white-space: nowrap; overflow: visible; max-width: 0; }

.paragraph.lead > p, #preamble > .sectionbody > .paragraph:first-of-type p { color: rgba(0, 0, 0, 0.85); }

table.tableblock #preamble > .sectionbody > .paragraph:first-of-type p { font-size: inherit; }

.admonitionblock > table { border-collapse: separate; border: 0; background: none; width: 100%; }
.admonitionblock > table td.icon { text-align: center; width: 80px; }
.admonitionblock > table td.icon img { max-width: none; }
.admonitionblock > table td.icon .title { font-weight: bold; font-family: "Open Sans", "DejaVu Sans", sans-serif; text-transform: uppercase; }
.admonitionblock > table td.content { padding-left: 1.125em; padding-right: 1.25em; border-left: 1px solid #ddddd8; color: rgba(0, 0, 0, 0.6); }
.admonitionblock > table td.content > :last-child > :last-child { margin-bottom: 0; }

.exampleblock > .content { border-style: solid; border-width: 1px; border-color: #e6e6e6; margin-bottom: 1.25em; padding: 1.25em; background: white; -webkit-border-radius: 4px; border-radius: 4px; }
.exampleblock > .content > :first-child { margin-top: 0; }
.exampleblock > .content > :last-child { margin-bottom: 0; }

.sidebarblock { border-style: solid; border-width: 1px; border-color: #e0e0dc; margin-bottom: 1.25em; padding: 1.25em; background: #f8f8f7; -webkit-border-radius: 4px; border-radius: 4px; }
.sidebarblock > :first-child { margin-top: 0; }
.sidebarblock > :last-child { margin-bottom: 0; }
.sidebarblock > .content > .title { color: #7a2518; margin-top: 0; text-align: center; }

.exampleblock > .content > :last-child > :last-child, .exampleblock > .content .olist > ol > li:last-child > :last-child, .exampleblock > .content .ulist > ul > li:last-child > :last-child, .exampleblock > .content .qlist > ol > li:last-child > :last-child, .sidebarblock > .content > :last-child > :last-child, .sidebarblock > .content .olist > ol > li:last-child > :last-child, .sidebarblock > .content .ulist > ul > li:last-child > :last-child, .sidebarblock > .content .qlist > ol > li:last-child > :last-child { margin-bottom: 0; }

.listingblock pre:not(.highlight) {color: white; background: #002b36; }

.literalblock pre, .listingblock pre[class="highlight"], .listingblock pre[class^="highlight "], .listingblock pre.CodeRay, .listingblock pre.prettyprint { background: #f7f7f8; }
.sidebarblock .literalblock pre, .sidebarblock .listingblock pre:not(.highlight), .sidebarblock .listingblock pre[class="highlight"], .sidebarblock .listingblock pre[class^="highlight "], .sidebarblock .listingblock pre.CodeRay, .sidebarblock .listingblock pre.prettyprint { background: #f2f1f1; }

.literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] { -webkit-border-radius: 4px; border-radius: 4px; word-wrap: break-word; padding: 1em; font-size: 0.8125em; }
.literalblock pre.nowrap, .literalblock pre[class].nowrap, .listingblock pre.nowrap, .listingblock pre[class].nowrap { overflow-x: auto; white-space: pre; word-wrap: normal; }
@media only screen and (min-width: 768px) { .literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] { font-size: 0.90625em; } }
@media only screen and (min-width: 1280px) { .literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] { font-size: 1em; } }

.literalblock.output pre { color: #f7f7f8; background-color: rgba(0, 0, 0, 0.9); }

.listingblock pre.highlightjs { padding: 0; }
.listingblock pre.highlightjs > code { padding: 1em; -webkit-border-radius: 4px; border-radius: 4px; }

.listingblock pre.prettyprint { border-width: 0; }

.listingblock > .content { position: relative; }

.listingblock code[data-lang]:before { display: none; content: attr(data-lang); position: absolute; font-size: 0.75em; top: 0.425rem; right: 0.5rem; line-height: 1; text-transform: uppercase; color: #999; }

.listingblock:hover code[data-lang]:before { display: block; }

.listingblock.terminal pre .command:before { content: attr(data-prompt); padding-right: 0.5em; color: #999; }

.listingblock.terminal pre .command:not([data-prompt]):before { content: "$"; }

table.pyhltable { border-collapse: separate; border: 0; margin-bottom: 0; background: none; }

table.pyhltable td { vertical-align: top; padding-top: 0; padding-bottom: 0; line-height: 1.45; }

table.pyhltable td.code { padding-left: .75em; padding-right: 0; }

pre.pygments .lineno, table.pyhltable td:not(.code) { color: #999; padding-left: 0; padding-right: .5em; border-right: 1px solid #ddddd8; }

pre.pygments .lineno { display: inline-block; margin-right: .25em; }

table.pyhltable .linenodiv { background: none !important; padding-right: 0 !important; }

.quoteblock { margin: 0 1em 1.25em 1.5em; display: table; }
.quoteblock > .title { margin-left: -1.5em; margin-bottom: 0.75em; }
.quoteblock blockquote, .quoteblock blockquote p { color: rgba(0, 0, 0, 0.85); font-size: 1.15rem; line-height: 1.75; word-spacing: 0.1em; letter-spacing: 0; font-style: italic; text-align: justify; }
.quoteblock blockquote { margin: 0; padding: 0; border: 0; }
.quoteblock blockquote:before { content: "\201c"; float: left; font-size: 2.75em; font-weight: bold; line-height: 0.6em; margin-left: -0.6em; color: #7a2518; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1); }
.quoteblock blockquote > .paragraph:last-child p { margin-bottom: 0; }
.quoteblock .attribution { margin-top: 0.5em; margin-right: 0.5ex; text-align: right; }
.quoteblock .quoteblock { margin-left: 0; margin-right: 0; padding: 0.5em 0; border-left: 3px solid rgba(0, 0, 0, 0.6); }
.quoteblock .quoteblock blockquote { padding: 0 0 0 0.75em; }
.quoteblock .quoteblock blockquote:before { display: none; }

.verseblock { margin: 0 1em 1.25em 1em; }
.verseblock pre { font-family: "Open Sans", "DejaVu Sans", sans; font-size: 1.15rem; color: rgba(0, 0, 0, 0.85); font-weight: 300; text-rendering: optimizeLegibility; }
.verseblock pre strong { font-weight: 400; }
.verseblock .attribution { margin-top: 1.25rem; margin-left: 0.5ex; }

.quoteblock .attribution, .verseblock .attribution { font-size: 0.9375em; line-height: 1.45; font-style: italic; }
.quoteblock .attribution br, .verseblock .attribution br { display: none; }
.quoteblock .attribution cite, .verseblock .attribution cite { display: block; letter-spacing: -0.025em; color: rgba(0, 0, 0, 0.6); }

.quoteblock.abstract { margin: 0 0 1.25em 0; display: block; }
.quoteblock.abstract blockquote, .quoteblock.abstract blockquote p { text-align: left; word-spacing: 0; }
.quoteblock.abstract blockquote:before, .quoteblock.abstract blockquote p:first-of-type:before { display: none; }

table.tableblock { max-width: 100%; border-collapse: separate; }
table.tableblock td > .paragraph:last-child p > p:last-child, table.tableblock th > p:last-child, table.tableblock td > p:last-child { margin-bottom: 0; }

table.tableblock, th.tableblock, td.tableblock { border: 0 solid #dedede; }

table.grid-all th.tableblock, table.grid-all td.tableblock { border-width: 0 1px 1px 0; }

table.grid-all tfoot > tr > th.tableblock, table.grid-all tfoot > tr > td.tableblock { border-width: 1px 1px 0 0; }

table.grid-cols th.tableblock, table.grid-cols td.tableblock { border-width: 0 1px 0 0; }

table.grid-all * > tr > .tableblock:last-child, table.grid-cols * > tr > .tableblock:last-child { border-right-width: 0; }

table.grid-rows th.tableblock, table.grid-rows td.tableblock { border-width: 0 0 1px 0; }

table.grid-all tbody > tr:last-child > th.tableblock, table.grid-all tbody > tr:last-child > td.tableblock, table.grid-all thead:last-child > tr > th.tableblock, table.grid-rows tbody > tr:last-child > th.tableblock, table.grid-rows tbody > tr:last-child > td.tableblock, table.grid-rows thead:last-child > tr > th.tableblock { border-bottom-width: 0; }

table.grid-rows tfoot > tr > th.tableblock, table.grid-rows tfoot > tr > td.tableblock { border-width: 1px 0 0 0; }

table.frame-all { border-width: 1px; }

table.frame-sides { border-width: 0 1px; }

table.frame-topbot { border-width: 1px 0; }

th.halign-left, td.halign-left { text-align: left; }

th.halign-right, td.halign-right { text-align: right; }

th.halign-center, td.halign-center { text-align: center; }

th.valign-top, td.valign-top { vertical-align: top; }

th.valign-bottom, td.valign-bottom { vertical-align: bottom; }

th.valign-middle, td.valign-middle { vertical-align: middle; }

table thead th, table tfoot th { font-weight: bold; }

tbody tr th { display: table-cell; line-height: 1.6; background: #f7f8f7; }

tbody tr th, tbody tr th p, tfoot tr th, tfoot tr th p { color: rgba(0, 0, 0, 0.8); font-weight: bold; }

p.tableblock > code:only-child { background: none; padding: 0; }

p.tableblock { font-size: 1em; }

td > div.verse { white-space: pre; }

ol { margin-left: 1.75em; }

ul li ol { margin-left: 1.5em; }

dl dd { margin-left: 1.125em; }

dl dd:last-child, dl dd:last-child > :last-child { margin-bottom: 0; }

ol > li p, ul > li p, ul dd, ol dd, .olist .olist, .ulist .ulist, .ulist .olist, .olist .ulist { margin-bottom: 0.625em; }

ul.unstyled, ol.unnumbered, ul.checklist, ul.none { list-style-type: none; }

ul.unstyled, ol.unnumbered, ul.checklist { margin-left: 0.625em; }

ul.checklist li > p:first-child > .fa-square-o:first-child, ul.checklist li > p:first-child > .fa-check-square-o:first-child { width: 1em; font-size: 0.85em; }

ul.checklist li > p:first-child > input[type="checkbox"]:first-child { width: 1em; position: relative; top: 1px; }

ul.inline { margin: 0 auto 0.625em auto; margin-left: -1.375em; margin-right: 0; padding: 0; list-style: none; overflow: hidden; }
ul.inline > li { list-style: none; float: left; margin-left: 1.375em; display: block; }
ul.inline > li > * { display: block; }

.unstyled dl dt { font-weight: normal; font-style: normal; }

ol.arabic { list-style-type: decimal; }

ol.decimal { list-style-type: decimal-leading-zero; }

ol.loweralpha { list-style-type: lower-alpha; }

ol.upperalpha { list-style-type: upper-alpha; }

ol.lowerroman { list-style-type: lower-roman; }

ol.upperroman { list-style-type: upper-roman; }

ol.lowergreek { list-style-type: lower-greek; }

.hdlist > table, .colist > table { border: 0; background: none; }
.hdlist > table > tbody > tr, .colist > table > tbody > tr { background: none; }

td.hdlist1, td.hdlist2 { vertical-align: top; padding: 0 0.625em; }

td.hdlist1 { font-weight: bold; padding-bottom: 1.25em; }

.literalblock + .colist, .listingblock + .colist { margin-top: -0.5em; }

.colist > table tr > td:first-of-type { padding: 0 0.75em; line-height: 1; }
.colist > table tr > td:last-of-type { padding: 0.25em 0; }

.thumb, .th { line-height: 0; display: inline-block; border: solid 4px white; -webkit-box-shadow: 0 0 0 1px #dddddd; box-shadow: 0 0 0 1px #dddddd; }

.imageblock.left, .imageblock[style*="float: left"] { margin: 0.25em 0.625em 1.25em 0; }
.imageblock.right, .imageblock[style*="float: right"] { margin: 0.25em 0 1.25em 0.625em; }
.imageblock > .title { margin-bottom: 0; }
.imageblock.thumb, .imageblock.th { border-width: 6px; }
.imageblock.thumb > .title, .imageblock.th > .title { padding: 0 0.125em; }

.image.left, .image.right { margin-top: 0.25em; margin-bottom: 0.25em; display: inline-block; line-height: 0; }
.image.left { margin-right: 0.625em; }
.image.right { margin-left: 0.625em; }

a.image { text-decoration: none; display: inline-block; }
a.image object { pointer-events: none; }

sup.footnote, sup.footnoteref { font-size: 0.875em; position: static; vertical-align: super; }
sup.footnote a, sup.footnoteref a { text-decoration: none; }
sup.footnote a:active, sup.footnoteref a:active { text-decoration: underline; }

#footnotes { padding-top: 0.75em; padding-bottom: 0.75em; margin-bottom: 0.625em; }
#footnotes hr { width: 20%; min-width: 6.25em; margin: -0.25em 0 0.75em 0; border-width: 1px 0 0 0; }
#footnotes .footnote { padding: 0 0.375em 0 0.225em; line-height: 1.3334; font-size: 0.875em; margin-left: 1.2em; text-indent: -1.05em; margin-bottom: 0.2em; }
#footnotes .footnote a:first-of-type { font-weight: bold; text-decoration: none; }
#footnotes .footnote:last-of-type { margin-bottom: 0; }

#content #footnotes { margin-top: -0.625em; margin-bottom: 0; padding: 0.75em 0; }

.gist .file-data > table { border: 0; background: #fff; width: 100%; margin-bottom: 0; }
.gist .file-data > table td.line-data { width: 99%; }

div.unbreakable { page-break-inside: avoid; }

.big { font-size: larger; }

.small { font-size: smaller; }

.underline { text-decoration: underline; }

.overline { text-decoration: overline; }

.line-through { text-decoration: line-through; }

.aqua { color: #00bfbf; }

.aqua-background { background-color: #00fafa; }

.black { color: black; }

.black-background { background-color: black; }

.blue { color: #0000bf; }

.blue-background { background-color: #0000fa; }

.fuchsia { color: #bf00bf; }

.fuchsia-background { background-color: #fa00fa; }

.gray { color: #606060; }

.gray-background { background-color: #7d7d7d; }

.green { color: #006000; }

.green-background { background-color: #007d00; }

.lime { color: #00bf00; }

.lime-background { background-color: #00fa00; }

.maroon { color: #600000; }

.maroon-background { background-color: #7d0000; }

.navy { color: #000060; }

.navy-background { background-color: #00007d; }

.olive { color: #606000; }

.olive-background { background-color: #7d7d00; }

.purple { color: #600060; }

.purple-background { background-color: #7d007d; }

.red { color: #bf0000; }

.red-background { background-color: #fa0000; }

.silver { color: #909090; }

.silver-background { background-color: #bcbcbc; }

.teal { color: #006060; }

.teal-background { background-color: #007d7d; }

.white { color: #bfbfbf; }

.white-background { background-color: #fafafa; }

.yellow { color: #bfbf00; }

.yellow-background { background-color: #fafa00; }

span.icon > .fa { cursor: default; }

.admonitionblock td.icon [class^="fa icon-"] { font-size: 2.5em; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5); cursor: default; }
.admonitionblock td.icon .icon-note:before { content: "\f05a"; color: #19407c; }
.admonitionblock td.icon .icon-tip:before { content: "\f0eb"; text-shadow: 1px 1px 2px rgba(155, 155, 0, 0.8); color: #111; }
.admonitionblock td.icon .icon-warning:before { content: "\f071"; color: #bf6900; }
.admonitionblock td.icon .icon-caution:before { content: "\f06d"; color: #bf3400; }
.admonitionblock td.icon .icon-important:before { content: "\f06a"; color: #bf0000; }

.conum[data-value] { display: inline-block; color: #fff !important; background-color: rgba(0, 0, 0, 0.8); -webkit-border-radius: 100px; border-radius: 100px; text-align: center; font-size: 0.75em; width: 1.67em; height: 1.67em; line-height: 1.67em; font-family: "Open Sans", "DejaVu Sans", sans-serif; font-style: normal; font-weight: bold; }
.conum[data-value] * { color: #fff !important; }
.conum[data-value] + b { display: none; }
.conum[data-value]:after { content: attr(data-value); }
pre .conum[data-value] { position: relative; top: -0.125em; }

b.conum * { color: inherit !important; }

.conum:not([data-value]):empty { display: none; }

dt, th.tableblock, td.content, div.footnote { text-rendering: optimizeLegibility; }

h1, h2, p, td.content, span.alt { letter-spacing: -0.01em; }

p strong, td.content strong, div.footnote strong { letter-spacing: -0.005em; }

p, blockquote, dt, td.content, span.alt { font-size: 1.0625rem; }

p { margin-bottom: 1.25rem; }

.sidebarblock p, .sidebarblock dt, .sidebarblock td.content, p.tableblock { font-size: 1em; }

.exampleblock > .content { background-color: #fffef7; border-color: #e0e0dc; -webkit-box-shadow: 0 1px 4px #e0e0dc; box-shadow: 0 1px 4px #e0e0dc; }

.print-only { display: none !important; }

@media print { @page { margin: 1.25cm 0.75cm; }
  * { -webkit-box-shadow: none !important; box-shadow: none !important; text-shadow: none !important; }
  a { color: inherit !important; text-decoration: underline !important; }
  a.bare, a[href^="#"], a[href^="mailto:"] { text-decoration: none !important; }
  a[href^="http:"]:not(.bare):after, a[href^="https:"]:not(.bare):after { content: "(" attr(href) ")"; display: inline-block; font-size: 0.875em; padding-left: 0.25em; }
  abbr[title]:after { content: " (" attr(title) ")"; }
  pre, blockquote, tr, img, object, svg { page-break-inside: avoid; }
  thead { display: table-header-group; }
  svg { max-width: 100%; }
  p, blockquote, dt, td.content { font-size: 1em; orphans: 3; widows: 3; }
  h2, h3, #toctitle, .sidebarblock > .content > .title, #toctitle, .sidebarblock > .content > .title { page-break-after: avoid; }
  #toc, .sidebarblock, .exampleblock > .content { background: none !important; }
  #toc { border-bottom: 1px solid #ddddd8 !important; padding-bottom: 0 !important; }
  .sect1 { padding-bottom: 0 !important; }
  .sect1 + .sect1 { border: 0 !important; }
  #header > h1:first-child { margin-top: 1.25rem; }
  body.book #header { text-align: center; }
  body.book #header > h1:first-child { border: 0 !important; margin: 2.5em 0 1em 0; }
  body.book #header .details { border: 0 !important; display: block; padding: 0 !important; }
  body.book #header .details span:first-child { margin-left: 0 !important; }
  body.book #header .details br { display: block; }
  body.book #header .details br + span:before { content: none !important; }
  body.book #toc { border: 0 !important; text-align: left !important; padding: 0 !important; margin: 0 !important; }
  body.book #toc, body.book #preamble, body.book h1.sect0, body.book .sect1 > h2 { page-break-before: always; }
  .listingblock code[data-lang]:before { display: block; }
  #footer { background: none !important; padding: 0 0.9375em; }
  #footer-text { color: rgba(0, 0, 0, 0.6) !important; font-size: 0.9em; }
  .hide-on-print { display: none !important; }
  .print-only { display: block !important; }
  .hide-for-print { display: none !important; }
  .show-for-print { display: inherit !important; } }

</style>
<link rel="stylesheet" href="css/font-awesome.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/github.min.css">
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Java工程师之路</h1>
<div class="details">
<span id="author" class="author">汪俊程</span><br>
<span id="email" class="email"><a href="mailto:wjcml@foxmail.com">wjcml@foxmail.com</a></span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#_前言_by_汪俊程">前言 by 汪俊程</a></li>
<li><a href="#_JavaBase_chapter">1. Java基础</a>
<ul class="sectlevel2">
<li><a href="#_基础数据类型">1.1. 基础数据类型</a>
<ul class="sectlevel3">
<li><a href="#_自动装箱与拆箱">1.1.1. 自动装箱与拆箱</a></li>
<li><a href="#_8_种基本类型的包装类和常量池">1.1.2. 8 种基本类型的包装类和常量池</a></li>
</ul>
</li>
<li><a href="#_java关键字">1.2. java关键字</a>
<ul class="sectlevel3">
<li><a href="#_static关键字">1.2.1. static关键字</a></li>
<li><a href="#_java程序初始化的顺序java实例化的过程">1.2.2. Java程序初始化的顺序（Java实例化的过程）</a></li>
<li><a href="#_stringbuffer和stringbuilder">1.2.3. StringBuffer和StringBuilder</a></li>
</ul>
</li>
<li><a href="#_面向对象">1.3. 面向对象</a>
<ul class="sectlevel3">
<li><a href="#_面向对象的三大特征">1.3.1. 面向对象的三大特征</a></li>
<li><a href="#_普通类抽象类接口">1.3.2. 普通类、抽象类、接口</a></li>
</ul>
</li>
<li><a href="#_object类">1.4. Object类</a>
<ul class="sectlevel3">
<li><a href="#_object_类的常见方法总结">1.4.1. Object 类的常见方法总结</a></li>
<li><a href="#_和_equals_区别">1.4.2. == 和 equals 区别？</a></li>
<li><a href="#_hashcode与_equals">1.4.3. hashCode()与 equals()</a></li>
</ul>
</li>
<li><a href="#_泛型">1.5. 泛型</a></li>
<li><a href="#_java反射">1.6. Java反射</a></li>
<li><a href="#_序列化和反序列化">1.7. 序列化和反序列化</a>
<ul class="sectlevel3">
<li><a href="#_什么是序列化和反序列化">1.7.1. 什么是序列化和反序列化</a></li>
<li><a href="#_transient">1.7.2. transient</a></li>
</ul>
</li>
<li><a href="#_java集合">1.8. Java集合</a>
<ul class="sectlevel3">
<li><a href="#_collection_子接口之_list">1.8.1. Collection 子接口之 List</a></li>
<li><a href="#_collection_子接口之_set">1.8.2. Collection 子接口之 Set</a></li>
<li><a href="#_map_接口">1.8.3. Map 接口</a></li>
</ul>
</li>
<li><a href="#_异常处理">1.9. 异常处理</a>
<ul class="sectlevel3">
<li><a href="#_error和exception的区别">1.9.1. Error和Exception的区别</a></li>
<li><a href="#_异常处理方式">1.9.2. 异常处理方式</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_java_collection_all_chapter">2. Java集合专题</a>
<ul class="sectlevel2">
<li><a href="#_arraylist">2.1. ArrayList</a>
<ul class="sectlevel3">
<li><a href="#_arraylist构造方法和源码">2.1.1. ArrayList构造方法和源码</a></li>
<li><a href="#_arraylist扩容机制">2.1.2. ArrayList扩容机制</a></li>
</ul>
</li>
<li><a href="#_linkedlist">2.2. LinkedList</a></li>
<li><a href="#_hashmap">2.3. HashMap</a>
<ul class="sectlevel3">
<li><a href="#_hashmap的特点">2.3.1. HashMap的特点</a></li>
<li><a href="#_java8_hashmap的类属性">2.3.2. Java8 HashMap的类属性</a></li>
<li><a href="#_hashmap的底层结构">2.3.3. HashMap的底层结构</a></li>
<li><a href="#_hashmap之put方法">2.3.4. HashMap之put方法</a></li>
<li><a href="#_hashmap之resize方法">2.3.5. HashMap之resize方法</a></li>
<li><a href="#_为什么hashmap线程不安全">2.3.6. 为什么hashMap线程不安全？</a></li>
<li><a href="#_hashmap的几种遍历方式">2.3.7. HashMap的几种遍历方式</a></li>
</ul>
</li>
<li><a href="#_concurrenthashmap">2.4. ConcurrentHashMap</a>
<ul class="sectlevel3">
<li><a href="#_存储结构">2.4.1. 存储结构</a></li>
<li><a href="#_concurrenthashmap之put方法">2.4.2. ConcurrentHashMap之put方法</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_JVM_chapter">3. JVM</a>
<ul class="sectlevel2">
<li><a href="#_类加载">3.1. 类加载</a>
<ul class="sectlevel3">
<li><a href="#_类加载过程">3.1.1. 类加载过程</a></li>
<li><a href="#_类加载器">3.1.2. 类加载器</a></li>
</ul>
</li>
<li><a href="#_逃逸分析">3.2. 逃逸分析</a>
<ul class="sectlevel3">
<li><a href="#_逃逸分析的原理">3.2.1. 逃逸分析的原理</a></li>
<li><a href="#_逃逸的方式">3.2.2. 逃逸的方式</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_Thread_chapter">4. 多线程并发</a>
<ul class="sectlevel2">
<li><a href="#_linux系统io模型">4.1. Linux系统I/O模型</a>
<ul class="sectlevel3">
<li><a href="#_同步异歩阻塞非阻塞">4.1.1. 同步/异歩，阻塞/非阻塞</a></li>
<li><a href="#_五种io模型">4.1.2. 五种I/O模型</a></li>
<li><a href="#_bionioaio">4.1.3. BIO/NIO/AIO</a></li>
</ul>
</li>
<li><a href="#_volatile">4.2. volatile</a>
<ul class="sectlevel3">
<li><a href="#_什么是jmmjava内存模型">4.2.1. 什么是JMM(Java内存模型)</a></li>
<li><a href="#_volatile_的作用">4.2.2. volatile 的作用</a></li>
<li><a href="#_volatile的可见性问题">4.2.3. volatile的可见性问题</a></li>
</ul>
</li>
<li><a href="#_synchronized">4.3. synchronized</a>
<ul class="sectlevel3">
<li><a href="#_实现原理">4.3.1. 实现原理</a></li>
</ul>
</li>
<li><a href="#_java中的锁">4.4. Java中的锁</a>
<ul class="sectlevel3">
<li><a href="#_乐观锁">4.4.1. 乐观锁</a></li>
<li><a href="#_悲观锁">4.4.2. 悲观锁</a></li>
<li><a href="#_自旋锁">4.4.3. 自旋锁</a></li>
<li><a href="#_公平锁和非公平锁">4.4.4. 公平锁和非公平锁</a></li>
<li><a href="#_可重入锁">4.4.5. 可重入锁</a></li>
<li><a href="#_读写锁">4.4.6. 读写锁</a></li>
<li><a href="#_独占锁和共享锁">4.4.7. 独占锁和共享锁</a></li>
<li><a href="#_锁粗化">4.4.8. 锁粗化</a></li>
</ul>
</li>
<li><a href="#_线程的生命周期">4.5. 线程的生命周期</a>
<ul class="sectlevel3">
<li><a href="#_yield">4.5.1. yield()</a></li>
<li><a href="#_join">4.5.2. join()</a></li>
<li><a href="#_wait_和_notify">4.5.3. wait() 和 notify()</a></li>
<li><a href="#_wait_和_sleep_的区别">4.5.4. wait() 和 sleep() 的区别</a></li>
<li><a href="#_interrupted_和_isinterrupted_的区别">4.5.5. interrupted() 和 isInterrupted() 的区别</a></li>
</ul>
</li>
<li><a href="#_线程的创建方式">4.6. 线程的创建方式</a>
<ul class="sectlevel3">
<li><a href="#_thread">4.6.1. Thread</a></li>
<li><a href="#_runable">4.6.2. Runable</a></li>
<li><a href="#_callable">4.6.3. Callable</a></li>
<li><a href="#_基于线程池的方式">4.6.4. 基于线程池的方式</a></li>
<li><a href="#_runable和callable区别">4.6.5. Runable和Callable区别</a></li>
</ul>
</li>
<li><a href="#_java线程池">4.7. Java线程池</a>
<ul class="sectlevel3">
<li><a href="#_threadpoolexecutor_推荐">4.7.1. ThreadPoolExecutor (推荐)</a></li>
<li><a href="#_executors">4.7.2. Executors</a></li>
</ul>
</li>
<li><a href="#_记一次多线程研发遇到的坑">4.8. 记一次多线程研发遇到的坑</a>
<ul class="sectlevel3">
<li><a href="#_问题背景">4.8.1. 问题背景</a></li>
<li><a href="#_研发方案的迭代">4.8.2. 研发方案的迭代</a></li>
<li><a href="#_遇到的坑">4.8.3. 遇到的坑</a></li>
</ul>
</li>
<li><a href="#_记一次实战项目遇到的问题和解决方案智能决策平台">4.9. 记一次实战项目遇到的问题和解决方案（智能决策平台）</a>
<ul class="sectlevel3">
<li><a href="#_问题一">4.9.1. 问题一</a></li>
<li><a href="#_问题二">4.9.2. 问题二</a></li>
<li><a href="#_问题三">4.9.3. 问题三</a></li>
<li><a href="#_问题三_2">4.9.4. 问题三</a></li>
</ul>
</li>
<li><a href="#_threadlocal_作用线程本地存储">4.10. ThreadLocal 作用(线程本地存储)</a>
<ul class="sectlevel3">
<li><a href="#_threadlocal结构">4.10.1. ThreadLocal结构</a></li>
<li><a href="#_threadlocal内存泄漏问题">4.10.2. ThreadLocal内存泄漏问题</a></li>
<li><a href="#_threadlocal父子线程数据传递方案">4.10.3. ThreadLocal父子线程数据传递方案</a></li>
<li><a href="#_inheritablethreadlocal和线程池之间的问题">4.10.4. InheritableThreadLocal和线程池之间的问题</a></li>
</ul>
</li>
<li><a href="#_多线程框架">4.11. 多线程框架</a></li>
</ul>
</li>
<li><a href="#_Spring_chapter">5. Spring</a>
<ul class="sectlevel2">
<li><a href="#_spring_ioc">5.1. Spring IOC</a>
<ul class="sectlevel3">
<li><a href="#_什么是ioc">5.1.1. 什么是IOC？</a></li>
<li><a href="#_spring依赖注入的三种方式">5.1.2. Spring依赖注入的三种方式</a></li>
<li><a href="#_spring_ioc容器简述">5.1.3. Spring IOC容器简述</a></li>
<li><a href="#BeanFactory">5.1.4. BeanFactory</a></li>
<li><a href="#_applicationcontext">5.1.5. ApplicationContext</a></li>
</ul>
</li>
<li><a href="#_spring_bean">5.2. Spring Bean</a>
<ul class="sectlevel3">
<li><a href="#_bean的作用域scope">5.2.1. Bean的作用域(scope)</a></li>
<li><a href="#_spring中的单例bean是线程安全的吗">5.2.2. Spring中的单例Bean是线程安全的吗？</a></li>
<li><a href="#_beanfactory和factorybean的却别">5.2.3. BeanFactory和FactoryBean的却别</a></li>
</ul>
</li>
<li><a href="#容器背后的秘密">5.3. 容器背后的秘密</a>
<ul class="sectlevel3">
<li><a href="#_容器功能实现阶段">5.3.1. 容器功能实现阶段</a></li>
<li><a href="#_插手容器的启动">5.3.2. 插手“容器的启动”</a></li>
<li><a href="#_了解bean的一生">5.3.3. 了解Bean的一生</a></li>
</ul>
</li>
<li><a href="#_spring_aop">5.4. Spring AOP</a>
<ul class="sectlevel3">
<li><a href="#_java的三种代理方式">5.4.1. Java的三种代理方式</a></li>
<li><a href="#_静态代理">5.4.2. 静态代理</a></li>
<li><a href="#_jdk动态代理">5.4.3. JDK动态代理</a></li>
<li><a href="#_cglib动态代理">5.4.4. cglib动态代理</a></li>
<li><a href="#_spring_aop代理失效问题">5.4.5. Spring AOP代理失效问题？</a></li>
</ul>
</li>
<li><a href="#_spring数据访问">5.5. Spring数据访问</a>
<ul class="sectlevel3">
<li><a href="#_什么是jdbc">5.5.1. 什么是JDBC？</a></li>
<li><a href="#_集成hibernate">5.5.2. 集成Hibernate</a></li>
<li><a href="#_集成mybatis">5.5.3. 集成Mybatis</a></li>
</ul>
</li>
<li><a href="#_spring事务">5.6. Spring事务</a>
<ul class="sectlevel3">
<li><a href="#_spring对事务的支持">5.6.1. Spring对事务的支持</a></li>
<li><a href="#_事务的四大特性acid">5.6.2. 事务的四大特性（ACID）</a></li>
<li><a href="#_并发事务带来的问题">5.6.3. 并发事务带来的问题？</a></li>
<li><a href="#_事务的隔离级别有哪些">5.6.4. 事务的隔离级别有哪些？</a></li>
<li><a href="#_事务的传播行为">5.6.5. 事务的传播行为</a></li>
<li><a href="#_spring配置事务的两种方式">5.6.6. Spring配置事务的两种方式</a></li>
<li><a href="#_spring事务管理接口">5.6.7. Spring事务管理接口</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_spring_mvc_chapter">6. Spring MVC</a>
<ul class="sectlevel2">
<li><a href="#_什么是spring_mvc">6.1. 什么是Spring MVC？</a>
<ul class="sectlevel3">
<li><a href="#_spring_mvc的原理">6.1.1. Spring MVC的原理</a></li>
<li><a href="#_spring_mvc中各角色交互">6.1.2. Spring MVC中各角色交互</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_spring_boot_chapter">7. SpringBoot</a>
<ul class="sectlevel2">
<li><a href="#_spring_boot核心运行原理">7.1. Spring Boot核心运行原理</a>
<ul class="sectlevel3">
<li><a href="#_自动配置注解_enableautoconfiguration">7.1.1. 自动配置注解 @EnableAutoConfiguration</a></li>
<li><a href="#_条件注解_conditional">7.1.2. 条件注解 @Conditional</a></li>
</ul>
</li>
<li><a href="#_spring_boot构造流程">7.2. Spring Boot构造流程</a>
<ul class="sectlevel3">
<li><a href="#_springapplication_实例化流程">7.2.1. SpringApplication 实例化流程</a></li>
</ul>
</li>
<li><a href="#_spring_boot运行流程">7.3. Spring Boot运行流程</a>
<ul class="sectlevel3">
<li><a href="#_springapplicationrunlistener监听器">7.3.1. SpringApplicationRunListener监听器</a></li>
<li><a href="#_初始化applicaitonarguments">7.3.2. 初始化ApplicaitonArguments</a></li>
<li><a href="#_初始化configurableenvironment">7.3.3. 初始化ConfigurableEnvironment</a></li>
<li><a href="#_打印banner">7.3.4. 打印Banner</a></li>
<li><a href="#_spring_应用上下文的创建">7.3.5. Spring 应用上下文的创建</a></li>
<li><a href="#_spring_应用上下文的准备">7.3.6. Spring 应用上下文的准备</a></li>
<li><a href="#_spring_应用上下文的刷新">7.3.7. Spring 应用上下文的刷新</a></li>
<li><a href="#_applicationrunner_和_commandlinerunner">7.3.8. ApplicationRunner 和 CommandLineRunner</a></li>
</ul>
</li>
<li><a href="#一些注解的作用">7.4. 一些注解的作用</a>
<ul class="sectlevel3">
<li><a href="#Import注解">7.4.1. @Import注解</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_data_structure_chapter">8. 数据结构</a>
<ul class="sectlevel2">
<li><a href="#_queue和stack">8.1. Queue和Stack</a></li>
</ul>
</li>
<li><a href="#_MySQL_chapter">9. MySQL</a>
<ul class="sectlevel2">
<li><a href="#_存储引擎">9.1. 存储引擎</a>
<ul class="sectlevel3">
<li><a href="#_innodb和myisam对比">9.1.1. InnoDB和MyISAM对比</a></li>
<li><a href="#_存储过程">9.1.2. 存储过程</a></li>
</ul>
</li>
<li><a href="#_索引">9.2. 索引</a>
<ul class="sectlevel3">
<li><a href="#_索引分类">9.2.1. 索引分类</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_Mybatis_chapter">10. Mybatis</a>
<ul class="sectlevel2">
<li><a href="#_mybatis缓存">10.1. Mybatis缓存</a>
<ul class="sectlevel3">
<li><a href="#_一级缓存">10.1.1. 一级缓存</a></li>
<li><a href="#_二级缓存">10.1.2. 二级缓存</a></li>
</ul>
</li>
<li><a href="#_mybatis常见问题">10.2. Mybatis常见问题</a></li>
</ul>
</li>
<li><a href="#_Netty_chapter">11. Netty</a>
<ul class="sectlevel2">
<li><a href="#_常见问题">11.1. 常见问题</a></li>
</ul>
</li>
<li><a href="#_分布式_chapter">12. 分布式</a>
<ul class="sectlevel2">
<li><a href="#_cap理论">12.1. CAP理论</a></li>
<li><a href="#_base理论">12.2. Base理论</a>
<ul class="sectlevel3">
<li><a href="#_base理论的核心思想">12.2.1. BASE理论的核心思想</a></li>
<li><a href="#_base理论三要素">12.2.2. Base理论三要素</a></li>
</ul>
</li>
<li><a href="#_分布式事务">12.3. 分布式事务</a>
<ul class="sectlevel3">
<li><a href="#_强一致性解决方案">12.3.1. 强一致性解决方案</a></li>
<li><a href="#_最终一致性解决方案">12.3.2. 最终一致性解决方案</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_消息队列_chapter">13. 消息队列</a>
<ul class="sectlevel2">
<li><a href="#_什么是消息队列">13.1. 什么是消息队列</a></li>
<li><a href="#_kafka">13.2. Kafka</a>
<ul class="sectlevel3">
<li><a href="#_kafka的组件">13.2.1. Kafka的组件</a></li>
<li><a href="#_kafka的模型">13.2.2. Kafka的模型</a></li>
<li><a href="#_kafka多副本机制">13.2.3. Kafka多副本机制</a></li>
<li><a href="#_zookeeper_在_kafka_中的作用">13.2.4. Zookeeper 在 Kafka 中的作用</a></li>
<li><a href="#_kafka如何保证消息的消费顺序">13.2.5. Kafka如何保证消息的消费顺序</a></li>
<li><a href="#_kafka如何保证消息不丢失">13.2.6. Kafka如何保证消息不丢失</a></li>
<li><a href="#_kafka如何保证消息不重复">13.2.7. Kafka如何保证消息不重复</a></li>
<li><a href="#_kafka常见问题">13.2.8. Kafka常见问题</a></li>
</ul>
</li>
<li><a href="#_rabbitmq">13.3. RabbitMQ</a>
<ul class="sectlevel3">
<li><a href="#_rabbitmq的组件">13.3.1. RabbitMQ的组件</a></li>
<li><a href="#_rabbitmq消息消费流程">13.3.2. RabbitMQ消息消费流程</a></li>
<li><a href="#_rabbitmq消息模型">13.3.3. RabbitMQ消息模型</a></li>
<li><a href="#_rabbitmq如何保证消息不丢失">13.3.4. RabbitMQ如何保证消息不丢失</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_前言_by_汪俊程">前言 by 汪俊程</h2>
<div class="sectionbody">
<div class="paragraph">
<p>一本关于个人成长、Java学习，软件开发，思考的杂记。</p>
</div>
<div class="paragraph">
<p>参考文档地址: <a href="https://github.com/fifilyu/SystemEngineerInAction" class="bare" target="_blank" rel="noopener">https://github.com/fifilyu/SystemEngineerInAction</a></p>
</div>
<div class="paragraph">
<p>金步国作品集: <a href="http://www.jinbuguo.com/" class="bare" target="_blank" rel="noopener">http://www.jinbuguo.com/</a></p>
</div>
<div class="paragraph">
<p>JavaGuide: <a href="https://github.com/Snailclimb/JavaGuide" class="bare" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p>
</div>
<div class="paragraph">
<p>计划：java基础，spring，springBoot，springCloud，dubbo，docker，netty，nginx，大数据处理（Hadoop，Spark），JVM，数据结构，leecode（力扣），MySQL</p>
</div>
<div class="paragraph">
<p>文章中的 <code>TODO</code> 标识表示没有做完的，需要后续补充完善的。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_JavaBase_chapter">1. Java基础</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_基础数据类型">1.1. 基础数据类型</h3>
<div class="paragraph">
<p>Java 中有 8 种基本数据类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>6 种数字类型 ：byte、short、int、long、float、double
1 种字符类型：char
1 种布尔型：boolean</pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. 基本数据类型</caption>
<colgroup>
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 22.2222%;">
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 22.2223%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">基本类型</th>
<th class="tableblock halign-left valign-top">位数</th>
<th class="tableblock halign-left valign-top">字节</th>
<th class="tableblock halign-left valign-top">范围</th>
<th class="tableblock halign-left valign-top">默认值</th>
<th class="tableblock halign-left valign-top">包装类型</th>
<th class="tableblock halign-left valign-top">缓存范围</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">byte</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-2^7 ~ 2^7-1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Byte</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[-128, 127]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">short</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">16</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-2^15 ~ 2^15-1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Short</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[-128, 127]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-2^31 ~ 2^31-1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Integer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[-128, 127]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-2^63 ~ 2^63-1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0L</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Long</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[-128, 127]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">float</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-2^31 ~ 2^31-1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.0f</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Float</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-2^63 ~ 2^63-1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.0d</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Double</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">boolean</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Boolean</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ture 和 false</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">char</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">16</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0 ~ 2^16-1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">'u0000'</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Character</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[0, 127]</p></td>
</tr>
</tbody>
</table>
<div class="sect3">
<h4 id="_自动装箱与拆箱">1.1.1. 自动装箱与拆箱</h4>
<div class="ulist">
<ul>
<li>
<p><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</p>
</li>
<li>
<p><strong>拆箱</strong>：将包装类型转换为基本数据类型；</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_8_种基本类型的包装类和常量池">1.1.2. 8 种基本类型的包装类和常量池</h4>
<div class="paragraph">
<p>&emsp;&emsp;Java 基本类型的包装类的大部分都实现了常量池技术。<strong>Byte</strong>, <strong>Short</strong>, <strong>Integer</strong>, <strong>Long</strong> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<strong>Character</strong> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<strong>Boolean</strong> 直接返回 <strong>True</strong> Or <strong>False</strong>。两种浮点数类型的包装类 <strong>Float</strong> , <strong>Double</strong> 并没有实现常量池技术。</p>
</div>
<div class="paragraph">
<p>如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。</p>
</div>
<div class="paragraph">
<p>包装类型不赋值就是 <strong>Null</strong> ，而基本类型 <strong>有默认值</strong> 且不是 <strong>Null</strong>。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_java关键字">1.2. java关键字</h3>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 2. Java 中常见的关键字</caption>
<colgroup>
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">访问控制</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">public</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">protected</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">default</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">private</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">类，方法和变量修饰符</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">abstract</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">class</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">extends</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">final</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">implements</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">interface</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">native</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">new</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">static</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">strictfp</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">synchronized</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">transient</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">volatile</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">程序控制</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">break</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">continue</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">return</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">do</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">while</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">if</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">else</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">for</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">instanceof</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">switch</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">case</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">default</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">错误处理</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">try</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">catch</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">throw</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">throws</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">finally</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">包相关</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">import</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">package</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">基本类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">boolean</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">byte</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">char</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">float</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">short</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">null</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">变量引用</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">super</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">this</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">void</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">保留字</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">goto</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">const</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
<div class="sect3">
<h4 id="_static关键字">1.2.1. static关键字</h4>
<div class="paragraph">
<p>static 可以修饰 类，成员变量，成员方法，静态代码块</p>
</div>
<div class="ulist">
<ul>
<li>
<p>修饰类（静态内部类）</p>
</li>
<li>
<p>修饰成员变量（静态变量）：静态变量属于类，只要静态变量所在的类被加载，这个静态变量就会被分配空间，在 <strong>内存中只有一份</strong>，所有对象共享这个静态变量。</p>
</li>
<li>
<p>修饰成员方法（静态成员方法）：静态成员方法属于类，不需要创建对象就可以使用。而非静态方法属于对象，只有在对象创建出来以后才可以被使用。静态方法里面只能访问所属类的静态成员变量和静态成员方法。</p>
</li>
<li>
<p>静态代码块：静态代码块经常被用来初始化静态变量，在类加载的初始化阶段会执行为静态变量赋值的语句和静态代码块的内容，<strong>静态代码块只会被执行一次</strong>。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_java程序初始化的顺序java实例化的过程">1.2.2. Java程序初始化的顺序（Java实例化的过程）</h4>
<div class="ulist">
<ul>
<li>
<p>父类的静态变量、父类的静态代码块 （谁在前，谁先初始化）</p>
</li>
<li>
<p>子类的静态变量、子类的静态代码块（谁在前，谁先初始化）</p>
</li>
<li>
<p>父类的非静态变量、父类的非静态代码块（谁在前，谁先初始化）、父类的构造函数</p>
</li>
<li>
<p>子类的非静态变量、子类的非静态代码块（谁在前，谁先初始化）、子类的构造函数</p>
</li>
<li>
<p>静态成员变量或静态代码块&gt;main方法&gt;非静态成员变量或非静态代码块&gt;构造方法</p>
</li>
<li>
<p>如果在子类构造函数中，显示调用了父类的构造方法（即使用了super()），则先调用子类的构造函数，再调用父类的。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_stringbuffer和stringbuilder">1.2.3. StringBuffer和StringBuilder</h4>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p><code><strong>String</strong></code> 被 <code>final</code> 修饰，长度大小不可变<br>
<code><strong>StringBuffer</strong></code> 和 <code><strong>StringBuilder</strong></code> 长度可变<br>
<code><strong>StringBuffer</strong></code> 线程安全， <code><strong>StringBuilder</strong></code> 线程不安全<br>
<code><strong>StringBuilder</strong></code> 速度快</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_面向对象">1.3. 面向对象</h3>
<div class="listingblock">
<div class="title">1. 什么是对象？</div>
<div class="content">
<pre>一切事物皆对象</pre>
</div>
</div>
<div class="listingblock">
<div class="title">2. 什么是类？</div>
<div class="content">
<pre>类就是具有相同属性和功能的对象的抽象的集合</pre>
</div>
</div>
<div class="listingblock">
<div class="title">3. 什么是实例和实例化？</div>
<div class="content">
<pre>- 实例就是一个真实的对象
- 实例化就是创建对象的过程
- Cat cat = new Cat()，做了两件事：
    Cat cat：声明一个Cat的对象，对象名为cat
    cat = new Cat()：将此cat对象实例化</pre>
</div>
</div>
<div class="listingblock">
<div class="title">4. 对象的相等与指向他们的引用相等,两者有什么不同?</div>
<div class="content">
<pre>对象的相等，比的是内存中存放的内容是否相等。
而引用相等，比较的是他们指向的内存地址是否相等。</pre>
</div>
</div>
<div class="listingblock">
<div class="title">5. 什么是构造方法？</div>
<div class="content">
<pre>构造函数用于对类进行初始化
构造方法与类同名（*普通方法也可与类名同名*），无返回值，创建对象时自动调用
如果不写构造，系统默认生成空构造
构造函数不能被继承，不能被override（重写），可以被overload（重载）
子类可以通过 super() 来显示调用父类的构造函数</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
构造方法不能被重写：因为 <code>重写是子类方法重写父类的方法，重写的方法名不变，而类的构造方法名必须与类名一致，假设父类的构造方法如果能够被子类重写则子类类名必须与父类类名一致才行，所以 Java 的构造方法是不能被重写的。</code>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<div class="title">6. 访问修饰符</div>
<p>访问修饰符以及被修饰的属性和方法可以被访问的作用域</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/修饰关键字.png" alt="修饰关键字">
</div>
</div>
<div class="sect3">
<h4 id="_面向对象的三大特征">1.3.1. 面向对象的三大特征</h4>
<div class="listingblock">
<div class="title">封装： 属性的封装和方法的封装</div>
<div class="content">
<pre>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部
不允许外部对象直接访问对象的内部信息
对外提供方法来操作属性</pre>
</div>
</div>
<div class="listingblock">
<div class="title">继承： 子类可以继承父类的成员变量和成员方法</div>
<div class="content">
<pre>子类拥有父类的非private的属性和方法
子类可以扩展父类没有的属性和功能
子类可以进行方法的重写
提高代码的复用性</pre>
</div>
</div>
<div class="listingblock">
<div class="title">多态： 同样的行为有不同的表现形式，具体表现为父类的引用指向子类的实例。</div>
<div class="content">
<pre>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_普通类抽象类接口">1.3.2. 普通类、抽象类、接口</h4>
<div class="listingblock">
<div class="title">普通类</div>
<div class="content">
<pre>普通类不能包含抽象方法
普通类可以直接实例化</pre>
</div>
</div>
<div class="listingblock">
<div class="title">抽象类</div>
<div class="content">
<pre>抽象类可以包含抽象方法
抽象类不能直接实例化

使用abstract关键字修饰的方法是抽象方法,没有方法体。子类必须重写这些抽象方法
抽象类中可以只包含非抽象方法，即抽象类可以给出一些方法的实现

包含抽象方法的类,一定是抽象类
抽象类只能被继承,一个类只能继承一个抽象类</pre>
</div>
</div>
<div class="listingblock">
<div class="title">接口</div>
<div class="content">
<pre>全部的方法都是抽象方法,属性都是常量
不能实例化,可以定义变量。
接口只能被实现,一个具体类实现接口,必须实现全部的抽象方法
接口之间可以多实现
一个具体类可以实现多个接口,实现多继承现象</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_object类">1.4. Object类</h3>
<div class="sect3">
<h4 id="_object_类的常见方法总结">1.4.1. Object 类的常见方法总结</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。
public final native Class&lt;?&gt; getClass()

// native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。
public native int hashCode()

// 用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。
public boolean equals(Object obj)

// naitive方法，用于创建并返回当前对象的一份拷贝。
// 一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。
// Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。
protected native Object clone() throws CloneNotSupportedException

// 返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。
public String toString()

// native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。
public final native void notify()

// native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。
public final native void notifyAll()

// native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。
public final native void wait(long timeout) throws InterruptedException

// 多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。
public final void wait(long timeout, int nanos) throws InterruptedException

// 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念
public final void wait() throws InterruptedException

// 实例被垃圾回收器回收的时候触发的操作
protected void finalize() throws Throwable {}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_和_equals_区别">1.4.2. == 和 equals 区别？</h4>
<div class="paragraph">
<p>对于 <strong>基本数据类型</strong> 来说，== 比较的是 <strong>值</strong>。对于 <strong>引用数据类型</strong> 来说，== 比较的是对象的 <strong>内存地址</strong>。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p>
</div>
</blockquote>
</div>
</blockquote>
</div>
<div class="paragraph">
<p><strong>equals()方法存在于Object类中，而Object类是所有类的直接或间接父类</strong>。</p>
</div>
<div class="paragraph">
<p>Object 类 equals() 方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public boolean equals(Object obj) {
     return (this == obj);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们通常使用 equals() 方法有两种方式：</p>
</div>
<div class="paragraph">
<p><strong>重写了Object的equals()方法</strong>： 重写之后，依据重写后的逻辑判定是否相等。比如：<strong>String</strong> 中的 equals() 方法被重写过，在 String 中，<code>equals()</code> 方法比较的是对象的值。</p>
</div>
<div class="paragraph">
<p><strong>没有重写Object的equals()方法</strong>： 通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 Object 类 <code>equals()</code> 方法。即比较的是内存地址是否相等。</p>
</div>
</div>
<div class="sect3">
<h4 id="_hashcode与_equals">1.4.3. hashCode()与 equals()</h4>
<div class="paragraph">
<p>面试官可能会问你：“你重写过 <strong>hashCode</strong> 和 <strong>equals</strong> 么，为什么重写 <strong>equals</strong> 时必须重写 <strong>hashCode</strong> 方法？”</p>
</div>
<div class="paragraph">
<div class="title">1. 什么是hashCode？</div>
<p><strong>hashCode</strong> 是一个 <strong>数值</strong>，称作为散列数值。在Java中，通过 <strong>hashCode()</strong> 方法获取，该方法通常用来将对象的 <strong>内存地址</strong> 转换为整数之后返回。</p>
</div>
<div class="paragraph">
<div class="title">2. 为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？</div>
<p><strong>因为 hashCode() 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值</strong>。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 hashCode）。</p>
</div>
<div class="paragraph">
<div class="title">3. 为什么重写 equals 时必须重写 hashCode 方法？</div>
<p>要解释这个问题，我们需要根据一个例子来解析，这样更加容易理解。比如：我们自定义了一个类 Cat，并创建一个 Map，使用这个类作为 key 的类型（即：Map&lt;Cat, Object&gt;），先看如下代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class TestDemo {
    public static void main(String[] args){
        Cat cat = new Cat("red");

        HashMap&lt;Cat, String&gt; map = new HashMap&lt;&gt;();
        // 最终会输出null
        System.out.println(map.get(new Cat("red")));
    }
}

public class Cat {
    private String color;

    public Cat(String color) {
        this.color = color;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }
        return this.color.equals(((Cat) obj).color);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">null</code></pre>
</div>
</div>
<div class="paragraph">
<p>如上面的例子，我们在 Cat 中只重写了 equals 方法，没有重写 hashCode 方法，最终导致 输出为 null。因为，在 hashMap 中查找的时候，会先比较 <strong>对象的hashCode</strong>，如果 hashCode 相等，才会比较对象是否相等。因为，<strong>如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等,对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的</strong>。</p>
</div>
<div class="paragraph">
<p>看一下 <strong>HashMap</strong> 中的插入和查询时做判断的源码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">if (p.hash == hash &amp;&amp;
                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以看出，HashMap 先做了 hashCode 是否相等的判断，也就是说，如果不重写 hashCode() 方法的话，就会直接判定两个对象不相等，这样就理解比较清晰了。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_泛型">1.5. 泛型</h3>
<div class="paragraph">
<p>Java 泛型了解么？什么是类型擦除？介绍一下常用的通配符？</p>
</div>
<div class="paragraph">
<p>Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p>
</div>
<div class="paragraph">
<p>Java 的泛型是伪泛型，这是因为 Java 在编译期间，所有的泛型信息都会被擦掉，这也就是通常所说 <strong>类型擦除</strong> 。在泛型类被类型擦除的时候，之前泛型类中的类型参数部分如果没有指定上限，如 &lt;T&gt;则会被转译成普通的 Object 类型，如果指定了上限如 &lt;T extends String&gt;则类型参数就被替换成类型上限。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();

list.add(12);
//这里直接添加会报错
list.add("a");
Class&lt;? extends List&gt; clazz = list.getClass();
Method add = clazz.getDeclaredMethod("add", Object.class);
//但是通过反射添加，是可以的
add.invoke(list, "kl");

System.out.println(list);</code></pre>
</div>
</div>
<div class="paragraph">
<p>泛型一般有三种使用方式:泛型类、泛型接口、泛型方法。</p>
</div>
<div class="listingblock">
<div class="title">1. 泛类型</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型
//在实例化泛型类时，必须指定T的具体类型
public class Generic&lt;T&gt; {

    private T key;

    public Generic(T key) {
        this.key = key;
    }

    public T getKey() {
        return key;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如何实例化泛型类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Generic&lt;Integer&gt; genericInteger = new Generic&lt;Integer&gt;(123456);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">2. 泛型接口</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface Generator&lt;T&gt; {
    public T method();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>实现泛型接口，不指定类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class GeneratorImpl&lt;T&gt; implements Generator&lt;T&gt;{
    @Override
    public T method() {
        return null;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>实现泛型接口，指定类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class GeneratorImpl implements Generator&lt;String&gt;{
    @Override
    public String method() {
        return "hello";
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">3. 泛型方法</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public static &lt;E&gt; void printArray(E[] inputArray) {
    for (E element : inputArray) {
        System.out.printf("%s ", element);
    }
    System.out.println();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// 创建不同类型数组： Integer, Double 和 Character
Integer[] intArray = { 1, 2, 3 };
String[] stringArray = { "Hello", "World" };
printArray(intArray);
printArray(stringArray);</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>常用的通配符为： T，E，K，V，？</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>？ 表示不确定的 java 类型</p>
</li>
<li>
<p>T (type) 表示具体的一个 java 类型</p>
</li>
<li>
<p>K V (key value) 分别代表 java 键值中的 Key Value</p>
</li>
<li>
<p>E (element) 代表 Element</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_java反射">1.6. Java反射</h3>
<div class="paragraph">
<p>在 Java 中的反射机制是指在 <strong>运行状态中,对于任意一个类都能够知道这个类所有的属性和方法;并且对于任意一个对象,都能够调用它的任意一个方法</strong>，这种 <strong>动态获取信息以及动态调用对象方法的功能</strong> 称为 Java 语言的反射机制。</p>
</div>
</div>
<div class="sect2">
<h3 id="_序列化和反序列化">1.7. 序列化和反序列化</h3>
<div class="sect3">
<h4 id="_什么是序列化和反序列化">1.7.1. 什么是序列化和反序列化</h4>
<div class="paragraph">
<p>如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。</p>
</div>
<div class="paragraph">
<p>简单来说：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>序列化： 将数据结构或对象转换成二进制字节流的过程</p>
</li>
<li>
<p>反序列化：将在序列化过程中所生成的二进制字节流的过程转换成数据结构或者对象的过程</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="images/序列化和反序列化.png" alt="序列化和反序列化">
</div>
</div>
<div class="paragraph">
<div class="title">1. 为什么需要序列化和反序列化？</div>
<p>首先，我们要知道，<strong>序列化是为了方便持久化或者数据传输</strong>。那么为什么需要序列化呢？</p>
</div>
<div class="paragraph">
<p>第一种情况是：一般情况下Java对象的声明周期都比Java虚拟机的要短，实际应用中我们希望在JVM停止运行之后能够持久化指定的对象，这时候就需要把对象进行序列化之后保存。</p>
</div>
<div class="paragraph">
<p>第二种情况是：需要把Java对象通过网络进行传输的时候。因为数据只能够以二进制的形式在网络中进行传输，因此当把对象通过网络发送出去之前需要先序列化成二进制数据，在接收端读到二进制数据之后反序列化成Java对象。</p>
</div>
<div class="paragraph">
<div class="title">2. 为什么Java序列化一定要实现Serializable接口？</div>
<p>在Java中实现了Serializable接口后, JVM会在底层帮我们实现序列化和反序列化, 如果我们不实现Serializable接口, 那自己去写一套序列化和反序列化代码也行。</p>
</div>
<div class="paragraph">
<div class="title">3. 实现Serializable接口就算了, 为什么还要显示指定serialVersionUID的值？</div>
<p>因为序列化对象时，如果不显示的设置serialVersionUID，Java在序列化时会根据对象属性自动的生成一个serialVersionUID，再进行存储或用作网络传输。在反序列化时，会根据对象属性自动再生成一个新的serialVersionUID，和序列化时生成的serialVersionUID进行比对，两个serialVersionUID相同则反序列化成功，否则就会抛异常。</p>
</div>
<div class="paragraph">
<p>而当显示的设置serialVersionUID后，Java在序列化和反序列化对象时，生成的serialVersionUID都为我们设定的serialVersionUID，这样就保证了反序列化的成功。</p>
</div>
<div class="paragraph">
<div class="title">4. String为什么不用实现Serializable接口呢？</div>
<p>查看 String 的源码可以知道，String 已经默认实现了 Serializable 接口</p>
</div>
</div>
<div class="sect3">
<h4 id="_transient">1.7.2. transient</h4>
<div class="paragraph">
<p>Java 序列化中如果有些字段不想进行序列化，怎么办？</p>
</div>
<div class="paragraph">
<p>对于不想进行序列化的变量，使用 transient 关键字修饰。</p>
</div>
<div class="paragraph">
<p>transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。</p>
</div>
<div class="paragraph">
<p>关于 transient 还有几点注意：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>transient 只能修饰变量，不能修饰类和方法。</p>
</li>
<li>
<p>transient 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 int 类型，那么反序列后结果就是 0。</p>
</li>
<li>
<p>static 变量因为不属于任何对象(Object)，所以无论有没有 transient 关键字修饰，均不会被序列化。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_java集合">1.8. Java集合</h3>
<div class="paragraph">
<p>参考文章： <br>
<a href="https://juejin.im/post/6844903966103306247" target="_blank" rel="noopener">详解Java集合框架，让你全面掌握！</a><br>
<a href="https://www.runoob.com/java/java-collections.html" target="_blank" rel="noopener">菜鸟教程-Java 集合框架</a></p>
</div>
<div class="paragraph">
<p>集合框架归纳如下图：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/java集合02.png" alt="java集合02">
</div>
</div>
<div class="paragraph">
<p>Java集合类主要由两个根接口Collection和Map派生出来的，Collection派生出了三个子接口：List、Set、Queue（Java5新增的队列），因此Java集合大致也可分成List、Set、Queue、Map四种接口体系，（注意：Map不是Collection的子接口）。</p>
</div>
<div class="paragraph">
<p>集合框架如下图：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/java集合01.png" alt="java集合01">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>其中List代表了有序可重复集合，可直接根据元素的索引来访问；</p>
</li>
<li>
<p>Set代表无序不可重复集合，只能根据元素本身来访问；</p>
</li>
<li>
<p>Queue是队列集合；</p>
</li>
<li>
<p>Map代表的是存储key-value对的集合，可根据元素的key来访问value。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>上图中淡绿色背景覆盖的是集合体系中常用的实现类，分别是ArrayList、LinkedList、ArrayQueue、HashSet、TreeSet、HashMap、TreeMap等实现类。</p>
</div>
<div class="sect3">
<h4 id="_collection_子接口之_list">1.8.1. Collection 子接口之 List</h4>
<div class="sect4">
<h5 id="_arraylist_和_vector_的区别">Arraylist 和 Vector 的区别？</h5>
<div class="paragraph">
<p><strong>ArrayList</strong> 是 <strong>List</strong> 的主要实现类，底层使用 <strong>Object[]</strong> 存储，适用于频繁的查找工作，<strong>线程不安全</strong>；</p>
</div>
<div class="paragraph">
<p><strong>Vector</strong> 是 <strong>List</strong> 的古老实现类，底层使用 <strong>Object[]</strong> 存储，<strong>线程安全的</strong>。</p>
</div>
</div>
<div class="sect4">
<h5 id="_arraylist_与_linkedlist_区别">Arraylist 与 LinkedList 区别？</h5>
<div class="paragraph">
<div class="title">1. 是否保证线程安全</div>
<p>ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</p>
</div>
<div class="paragraph">
<div class="title">2. 底层数据结构</div>
<p><strong>Arraylist</strong> 底层使用的是 <strong>Object 数组</strong>；<strong>LinkedList</strong> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。）</p>
</div>
<div class="ulist">
<div class="title">3. 插入和删除是否受元素位置的影响</div>
<ul>
<li>
<p>ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行add(E e)方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（add(int index, E element)）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。</p>
</li>
<li>
<p>LinkedList 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（add(E e)、addFirst(E e)、addLast(E e)、removeFirst() 、 removeLast()），近似 O(1)，如果是要在指定位置 i 插入和删除元素的话（add(int index, E element)，remove(Object o)） 时间复杂度近似为 O(n) ，因为需要先移动到指定位置再插入。</p>
</li>
</ul>
</div>
<div class="paragraph">
<div class="title">4. 是否支持快速随机访问</div>
<p>LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。</p>
</div>
<div class="paragraph">
<div class="title">5. 内存空间占用</div>
<p>ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_collection_子接口之_set">1.8.2. Collection 子接口之 Set</h4>
<div class="sect4">
<h5 id="_比较_hashsetlinkedhashset_和_treeset_三者的异同">比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h5>
<div class="paragraph">
<p><strong>HashSet</strong> 是 Set 接口的主要实现类 ，HashSet 的底层是 <strong>HashMap</strong>，<strong>线程不安全的</strong>，可以存储 null 值；</p>
</div>
<div class="paragraph">
<p><strong>LinkedHashSet</strong> 是 HashSet 的子类，能够按照添加的顺序遍历；</p>
</div>
<div class="paragraph">
<p><strong>TreeSet</strong> 底层使用红黑树，能够按照添加元素的顺序进行遍历，排序的方式有自然排序和定制排序。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_map_接口">1.8.3. Map 接口</h4>
<div class="sect4">
<h5 id="_hashmap_和_hashtable_的区别">HashMap 和 Hashtable 的区别</h5>
<div class="paragraph">
<div class="title">1. 线程是否安全</div>
<p>HashMap 是 <strong>非线程安全的</strong>，HashTable 是 <strong>线程安全</strong> 的,因为 HashTable 内部的方法基本都经过 <strong>synchronized</strong> 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；</p>
</div>
<div class="paragraph">
<div class="title">2. 效率</div>
<p>因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</p>
</div>
<div class="ulist">
<div class="title">3. 对 Null key 和 Null value 的支持</div>
<ul>
<li>
<p>HashMap 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；</p>
</li>
<li>
<p>HashTable 不允许有 null 键和 null 值，否则会抛出 NullPointerException。</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">4. 初始容量大小和每次扩充容量大小的不同</div>
<ul>
<li>
<p>① 创建时如果不指定容量初始值，Hashtable 默认的初始大小为 <strong>11</strong>，之后每次扩充，容量变为原来的 <strong>2n+1</strong>。HashMap 默认的初始化大小为 <strong>16</strong>。之后每次扩充，容量变为原来的 <strong>2</strong> 倍。</p>
</li>
<li>
<p>② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为 <strong>2</strong> 的幂次方大小（HashMap 中的tableSizeFor()方法保证）。也就是说 HashMap <strong>总是使用 2 的幂</strong> 作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</p>
</li>
</ul>
</div>
<div class="paragraph">
<div class="title">5. 底层数据结构</div>
<p><strong>JDK1.8</strong> 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 <strong>8</strong>）（将链表转换成红黑树前会判断，如果当前数组的长度小于 <strong>64</strong>，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</p>
</div>
</div>
<div class="sect4">
<h5 id="_hashmap_和_hashset_区别">HashMap 和 HashSet 区别</h5>
<div class="paragraph">
<p><strong>HashSet 底层就是基于 HashMap 实现的</strong>。（HashSet 的源码非常非常少，因为除了 clone()、writeObject()、readObject()是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。</p>
</div>
<div class="paragraph">
<div class="title">HashSet 如何检查重复?</div>
<p>当你把对象加入HashSet时，HashSet 会先计算对象的 <strong>hashcode</strong> 值来判断对象加入的位置，同时也会与其他加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让加入操作成功。</p>
</div>
</div>
<div class="sect4">
<h5 id="_hashmap_和_treemap_区别">HashMap 和 TreeMap 区别</h5>
<div class="paragraph">
<p><strong>相比于 HashMap 来说 TreeMap 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</strong></p>
</div>
</div>
<div class="sect4">
<h5 id="_concurrenthashmap_和_hashtable_的区别">ConcurrentHashMap 和 Hashtable 的区别</h5>
<div class="paragraph">
<p><strong>ConcurrentHashMap</strong> 和 <strong>Hashtable</strong> 的区别主要体现在实现线程安全的方式上不同。</p>
</div>
<div class="paragraph">
<p><strong>底层数据结构</strong>：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>JDK1.7</strong> 的 ConcurrentHashMap 底层采用 <strong>分段的数组+链表</strong> 实现，<strong>JDK1.8</strong> 采用的数据结构跟 HashMap 1.8 的结构一样，<strong>数组+链表/红黑二叉树</strong>。</p>
</li>
<li>
<p>Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>实现线程安全的方式（重要）</strong>：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>① 在 JDK1.7 的时候，ConcurrentHashMap（<strong>分段锁</strong>） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 到了 JDK1.8 的时候已经摒弃了 Segment 的概念，而是直接用 <strong>Node 数组+链表+红黑树</strong> 的数据结构来实现，并发控制使用 <strong>synchronized</strong> 和 <strong>CAS</strong> 来操作。（JDK1.6 以后 对 synchronized 锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在 JDK1.8 中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</p>
</li>
<li>
<p>② Hashtable(<strong>同一把锁</strong>) :使用 <strong>synchronized</strong> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_异常处理">1.9. 异常处理</h3>
<div class="imageblock">
<div class="content">
<img src="images/Java异常类层次结构图.png" alt="Java异常类层次结构图">
</div>
</div>
<div class="sect3">
<h4 id="_error和exception的区别">1.9.1. Error和Exception的区别</h4>
<div class="paragraph">
<p><code>Error</code> 类是指 java 运行时系统的内部错误和资源耗尽错误。比如说内存溢出<br>
<code>Exception</code> 表示一种设计或实现问题</p>
</div>
<div class="paragraph">
<p>Exception又有两个分支, 一个是检查异常 CheckedException，这类异常必须被显示的捕获或抛出；一个是不检查异常 UncheckedException ，这类异常不必捕获或抛出。</p>
</div>
<div class="paragraph">
<p>几种常见的运行时异常：<br>
ClassCastException(类转换异常)<br>
IndexOutOfBoundsException(数组越界)<br>
NullPointerException(空指针异常)<br>
ArrayStoreException(数据存储异常,操作数组是类型不一致)</p>
</div>
</div>
<div class="sect3">
<h4 id="_异常处理方式">1.9.2. 异常处理方式</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>异常捕捉:try&#8230;&#8203;catch&#8230;&#8203;finally</p>
</li>
<li>
<p>异常抛出:throws。</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
throw 和 throws 的区别:<br>
throws 用在函数上,后面跟的是异常类,可以跟多个,用于声明异常;<br>
而 throw 用在函数内,后面跟的是异常对象，throw 抛出具体的问题对象,执行到 throw,功能就已经结束了
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_trycatchfinally">try&#8230;&#8203;catch&#8230;&#8203;finally</h5>
<div class="ulist">
<div class="title">1. try 里有 return ，finally 还执行么？ 如果会的话，什么时候执行，在 return 之前还是 return 之后？</div>
<ul>
<li>
<p>finally块里的代码在return之前执行</p>
</li>
<li>
<p>如果finally块中有return语句，它将覆盖掉函数中其他return语句</p>
</li>
<li>
<p>如果 finally 块中改变了 try 块中返回变量的值，该变量为基本数据类型的话，则 finally 块中改变变量值的语句将不起作用；如果该变量为引用变量的话，则起作用。</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">2. finally 块中的代码不执行的情况</div>
<ul>
<li>
<p>try 块执行之前，出现了异常，则程序终止</p>
</li>
<li>
<p>在 try 块中执行了 System.exit(0)</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_java_collection_all_chapter">2. Java集合专题</h2>
<div class="sectionbody">
<div class="paragraph">
<p>参考文档： <a href="https://snailclimb.gitee.io/javaguide/#/" target="_blank" rel="noopener">JavaGuide</a></p>
</div>
<div class="sect2">
<h3 id="_arraylist">2.1. ArrayList</h3>
<div class="paragraph">
<p>以下分析都是在 <strong>Java 8</strong> 的情况下。</p>
</div>
<div class="paragraph">
<p><strong>ArrayList</strong> 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。</p>
</div>
<div class="paragraph">
<p><strong>ArrayList</strong> 是 <strong>List</strong> 的主要实现类，底层使用 <strong>Object[]</strong> 存储，适用于频繁的查找工作，线程不安全。</p>
</div>
<div class="sect3">
<h4 id="_arraylist构造方法和源码">2.1.1. ArrayList构造方法和源码</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable{
    private static final long serialVersionUID = 8683452581122892189L;

    /**默认初始容量大小*/
    private static final int DEFAULT_CAPACITY = 10;
    /**空数组（用于空实例）*/
    private static final Object[] EMPTY_ELEMENTDATA = {};
    /**用于默认大小空实例的共享空数组实例。
    *我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。*/
    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
    /**保存ArrayList数据的数组*/
    transient Object[] elementData; // non-private to simplify nested class access
    /**ArrayList 所包含的元素个数*/
    private int size;

    /**带初始容量参数的构造函数（用户可以在创建ArrayList对象时自己指定集合的初始大小）*/
    public ArrayList(int initialCapacity) {
        if (initialCapacity &gt; 0) {
            //如果传入的参数大于0，创建initialCapacity大小的数组
            this.elementData = new Object[initialCapacity];
        } else if (initialCapacity == 0) {
            //如果传入的参数等于0，创建空数组
            this.elementData = EMPTY_ELEMENTDATA;
        } else {
            //其他情况，抛出异常
            throw new IllegalArgumentException("Illegal Capacity: "+
                                               initialCapacity);
        }
    }

    /**默认无参构造函数
     *DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10
     */
    public ArrayList() {
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }

    /**
    *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回
    *如果指定的集合为null，throws NullPointerException。
    */
    public ArrayList(Collection&lt;? extends E&gt; c) {
        //将指定集合转换为数组
        elementData = c.toArray();
        //如果elementData数组的长度不为0
        if ((size = elementData.length) != 0) {
            // 如果elementData不是Object类型数据（c.toArray可能返回的不是Object类型的数组所以加上下面的语句用于判断）
            if (elementData.getClass() != Object[].class)
                //将原来不是Object类型的elementData数组的内容，赋值给新的Object类型的elementData数组
                elementData = Arrays.copyOf(elementData, size, Object[].class);
        } else {
            // 其他情况，用空数组代替
            this.elementData = EMPTY_ELEMENTDATA;
        }
    }

    // 省略方法
    ......
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>ArrayList</strong> 在初始化的时候，如果没有指定初始化大小，就会使用默认的空数组 <strong>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</strong>，也就是 Object[0]；如果指定了大小，就会创建指定大小的数组。</p>
</div>
<div class="paragraph">
<p>如果采用 ArrayList 的无参构造方法进行初始化的话，是一个 <strong>空数组</strong>，并没有使用默认的初始容量大小 <strong>int DEFAULT_CAPACITY = 10</strong>；这是因为，在真正添加元素的时候（add()方法），才会将设置数组大小。接下来，我们看一下 ArrayList 的扩容机制。</p>
</div>
</div>
<div class="sect3">
<h4 id="_arraylist扩容机制">2.1.2. ArrayList扩容机制</h4>
<div class="sect4">
<h5 id="_add_方法">add 方法</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">/**
* 将指定的元素追加到此列表的末尾。
*/
public boolean add(E e) {
    //添加元素之前，先调用ensureCapacityInternal方法
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    //这里看到ArrayList添加元素的实质就相当于为数组赋值
    elementData[size++] = e;
    return true;
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_ensurecapacityinternal_方法_和_ensureexplicitcapacity_方法">ensureCapacityInternal 方法 和 ensureExplicitCapacity 方法</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">//得到最小扩容量，minCapacity = size + 1
private void ensureCapacityInternal(int minCapacity) {
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        // 获取默认的容量和传入参数的较大值
        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
    }

    ensureExplicitCapacity(minCapacity);
}

//判断是否需要扩容
private void ensureExplicitCapacity(int minCapacity) {
    modCount++;

    // 判断需要的大小是否大于当前数组的容量，如果容量不够，就需要扩容了
    if (minCapacity - elementData.length &gt; 0)
        //调用grow方法进行扩容，调用此方法代表已经开始扩容了
        grow(minCapacity);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们来仔细分析一下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>当我们要 add 进第 1 个元素到 ArrayList 时，<strong>elementData.length</strong> 为 0 （因为还是一个空的 list），因为执行了 <strong>ensureCapacityInternal()</strong> 方法 ，所以 <strong>minCapacity</strong> 此时为 <strong>10</strong>。此时，<strong>minCapacity - elementData.length &gt; 0</strong> 成立，所以会进入 <strong>grow(minCapacity)</strong> 方法。</p>
</li>
<li>
<p>当 add 第 2 个元素时，<strong>minCapacity</strong> 为 2，此时 <strong>elementData.length(容量)</strong> 在添加第一个元素后扩容成 10 了。此时，<strong>minCapacity - elementData.length &gt; 0</strong> 不成立，所以不会进入 （执行）<strong>grow(minCapacity)</strong> 方法。</p>
</li>
<li>
<p>添加第 3、4···到第 10 个元素时，依然不会执行 <strong>grow</strong> 方法，数组容量都为 10。</p>
</li>
<li>
<p>直到添加第 11 个元素，<strong>minCapacity</strong> (为 11) 比 <strong>elementData.length</strong>（为 10）要大。进入 <strong>grow</strong> 方法进行扩容。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_grow_方法">grow 方法</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">/**
* 要分配的最大数组大小
*/
private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;

/**
* ArrayList扩容的核心方法。
*/
private void grow(int minCapacity) {
    // oldCapacity为旧容量，newCapacity为新容量
    int oldCapacity = elementData.length;
    //将oldCapacity 右移一位，其效果相当于oldCapacity /2，
    //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，
    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
    //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，
    if (newCapacity - minCapacity &lt; 0)
        newCapacity = minCapacity;
    // 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，
    //如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。
    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
        newCapacity = hugeCapacity(minCapacity);
    // minCapacity is usually close to size, so this is a win:
    elementData = Arrays.copyOf(elementData, newCapacity);
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
通过这一句 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); 可以看出，每次扩容为上一次的 1.5 倍。
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_linkedlist">2.2. LinkedList</h3>
<div class="paragraph">
<p>Java 8 版本</p>
</div>
<div class="paragraph">
<p>LinkedList不是线程安全的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt;
                        implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, Serializable {
    transient int size;
    transient LinkedList.Node&lt;E&gt; first;
    transient LinkedList.Node&lt;E&gt; last;
    private static final long serialVersionUID = 876323262645176354L;

    // 省略代码
    ......


    private static class Node&lt;E&gt; {
        E item;
        LinkedList.Node&lt;E&gt; next;
        LinkedList.Node&lt;E&gt; prev;

        Node(LinkedList.Node&lt;E&gt; var1, E var2, LinkedList.Node&lt;E&gt; var3) {
            this.item = var2;
            this.next = var3;
            this.prev = var1;
        }
    }


    // 省略代码
    ......
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>LinkedList 内部有一个 Node 内部类，这个类有三个属性，分别是前驱节点，本节点的值，后继结点。</p>
</div>
</div>
<div class="sect2">
<h3 id="_hashmap">2.3. HashMap</h3>
<div class="sect3">
<h4 id="_hashmap的特点">2.3.1. HashMap的特点</h4>
<div class="paragraph">
<p>HashMap 是以 <strong>键值对</strong> 的形式存储数据的，<strong>线程不安全</strong>。</p>
</div>
<div class="paragraph">
<p>HashMap 可以存储 <strong>null</strong> 的 <strong>key</strong> 和 <strong>value</strong>，但 null 作为键只能有一个，null 作为值可以有多个。</p>
</div>
<div class="paragraph">
<p>HashMap 在 <strong>JDK 1.8</strong> 底层采用的是 <strong>数组 + 链表/红黑树</strong> 结构。数组是 <strong>Node&lt;K, V&gt;[]</strong> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="_java8_hashmap的类属性">2.3.2. Java8 HashMap的类属性</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;
            implements Map&lt;K,V&gt;, Cloneable, Serializable {
    // 序列号
    private static final long serialVersionUID = 362498820763181265L;
    // 默认的初始容量是16
    static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;
    // 最大容量
    static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;
    // 默认的填充因子
    static final float DEFAULT_LOAD_FACTOR = 0.75f;
    // 当桶(bucket)上的结点数大于这个值时会转成红黑树
    static final int TREEIFY_THRESHOLD = 8;
    // 当桶(bucket)上的结点数小于这个值时树转链表
    static final int UNTREEIFY_THRESHOLD = 6;
    // 桶中结构转化为红黑树对应的table的最小大小
    static final int MIN_TREEIFY_CAPACITY = 64;
    // 存储元素的数组，总是2的幂次倍
    transient Node&lt;k,v&gt;[] table;
    // 存放具体元素的集
    transient Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;
    // 存放元素的个数，注意这个不等于数组的长度。
    transient int size;
    // 每次扩容和更改map结构的计数器
    transient int modCount;
    // 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容
    int threshold;
    // 加载因子
    final float loadFactor;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_hashmap的底层结构">2.3.3. HashMap的底层结构</h4>
<div class="paragraph">
<p>HashMap 在 <strong>JDK 1.8</strong> 底层采用的是 <strong>数组 + 链表/红黑树</strong> 结构。在 <strong>JDK 1.7</strong> 以前(包括1.7) 采用的是 <strong>数组 + 链表</strong>，采用 <strong>数组 + 链表/红黑树</strong> 结构，可以减少搜索时间。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/HashMap数据结构(JAVA8).png" alt="HashMap数据结构(JAVA8)">
</div>
</div>
<div class="paragraph">
<p>在 HashMap 中，链表和红黑树分别由 HashMap 的两个内部类 <strong>Node&lt;K,V&gt;</strong> 和 <strong>TreeNode&lt;K,V&gt;</strong> 组成。</p>
</div>
<div class="paragraph">
<p><strong>Node&lt;K, V&gt; 源码</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// 继承自 Map.Entry&lt;K,V&gt;
static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
    final int hash;// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较
    final K key;//键
    V value;//值
    // 指向下一个节点
    Node&lt;K,V&gt; next;
    Node(int hash, K key, V value, Node&lt;K,V&gt; next) {
        this.hash = hash;
        this.key = key;
        this.value = value;
        this.next = next;
    }

    // 省略部分代码
    ......

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>TreeNode 继承自 LinkedHashMap.Entry，实际上，LinkedHashMap.Entry 继承自 HashMap.Node，所以说，TreeNode 也属于 Node 的子类。</p>
</div>
<div class="paragraph">
<p><strong>TreeNode&lt;K, V&gt; 源码</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; {
    TreeNode&lt;K,V&gt; parent;  // 父
    TreeNode&lt;K,V&gt; left;    // 左
    TreeNode&lt;K,V&gt; right;   // 右
    TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion
    boolean red;           // 判断颜色
    TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) {
        super(hash, key, val, next);
    }
    // 返回根节点
    final TreeNode&lt;K,V&gt; root() {
        for (TreeNode&lt;K,V&gt; r = this, p;;) {
            if ((p = r.parent) == null)
                return r;
            r = p;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_hashmap之put方法">2.3.4. HashMap之put方法</h4>
<div class="paragraph">
<p>在 HashMap 中，通过put方法来添加元素。我们首先根据下图来分析一下 HashMap 添加元素的逻辑。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/hashMap的put方法流程(JAVA8).png" alt="hashMap的put方法流程(JAVA8)">
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>判断 <strong>table</strong> 是否为空或者长度为0，是就执行 resize()</p>
</li>
<li>
<p>计算 <strong>hash</strong>，如果定位到的位置没有元素，就直接插入</p>
</li>
<li>
<p>与定位到元素进行 key 比较，如果 key 相同，就覆盖元素值。</p>
</li>
<li>
<p>桶是否为树结构，如果是树结构，就采用 <strong>红黑树</strong> 插入；如果是链表结构，就循环遍历，并判断 key 是否相等，如果相等就替换，遍历到了末尾的话，就插入到最后，然后判断是否需要转化为红黑树</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>下面是 HashMap 的 put 方法源码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}

final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
    // table未初始化或者长度为0，进行扩容
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    // (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)
    if ((p = tab[i = (n - 1) &amp; hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    // 桶中已经存在元素
    else {
        Node&lt;K,V&gt; e; K k;
        // 比较桶中第一个元素(数组中的结点)的hash值相等，key相等
        if (p.hash == hash &amp;&amp;
            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                // 将第一个元素赋值给e，用e来记录
                e = p;
        // hash值不相等，即key不相等；为红黑树结点
        else if (p instanceof TreeNode)
            // 放入树中
            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
        // 为链表结点
        else {
            // 在链表最末插入结点
            for (int binCount = 0; ; ++binCount) {
                // 到达链表的尾部
                if ((e = p.next) == null) {
                    // 在尾部插入新结点
                    p.next = newNode(hash, key, value, null);
                    // 结点数量达到阈值(默认为 8 )，执行 treeifyBin 方法
                    // 这个方法会根据 HashMap 数组来决定是否转换为红黑树。
                    // 只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是对数组扩容。
                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    // 跳出循环
                    break;
                }
                // 判断链表中结点的key值与插入的元素的key值是否相等
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    // 相等，跳出循环
                    break;
                // 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表
                p = e;
            }
        }
        // 表示在桶中找到key值、hash值与插入元素相等的结点
        if (e != null) {
            // 记录e的value
            V oldValue = e.value;
            // onlyIfAbsent为false或者旧值为null
            if (!onlyIfAbsent || oldValue == null)
                //用新值替换旧值
                e.value = value;
            // 访问后回调
            afterNodeAccess(e);
            // 返回旧值
            return oldValue;
        }
    }
    // 结构性修改
    ++modCount;
    // 实际大小大于阈值则扩容
    if (++size &gt; threshold)
        resize();
    // 插入后回调
    afterNodeInsertion(evict);
    return null;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_hashmap之resize方法">2.3.5. HashMap之resize方法</h4>
<div class="paragraph">
<p>进行扩容，会伴随着一次重新 hash 分配，并且会遍历 hash 表中所有的元素，是非常耗时的。在编写程序中，要尽量避免 resize。</p>
</div>
<div class="paragraph">
<p>这里就不贴代码了，如果需要看代码，可以访问 <a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/HashMap(JDK1.8)%E6%BA%90%E7%A0%81+%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90" target="_blank" rel="noopener">JavaGuide之HashMap解析</a></p>
</div>
</div>
<div class="sect3">
<h4 id="_为什么hashmap线程不安全">2.3.6. 为什么hashMap线程不安全？</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>如果多个线程对hashMap操作，又对同一个数组位置进行插入操作，会造成数据丢失。假设两个线程A、B都在进行put操作，并且hash函数计算出的插入下标是相同的，A执行完Hash碰撞后因为时间片耗尽被挂起，B插入了数据，而A获得时间片，因为A已经执行过hash碰撞了，所以直接插入，就会覆盖B的数据</p>
</li>
<li>
<p>hashMap执行扩容方法，会生成一个新的容量数组，将旧的数组的所有键值对重新计算写入新数组，之后指向新数组。假设多个线程同时检测到超过阈值，需要扩容，那么就都会遍历所有元素生成新的数组，然后让 table 指向生成的新数组，那么只有最后一个线程生成的新数组会被赋值给 table，其他线程数据都会丢失。</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_hashmap的几种遍历方式">2.3.7. HashMap的几种遍历方式</h4>
<div class="paragraph">
<p>参考文档： <a href="https://mp.weixin.qq.com/s/zQBN3UvJDhRTKP6SzcZFKw" target="_blank" rel="noopener">HashMap 的 7 种遍历方式与性能分析！「修正篇」</a></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>迭代器（Iterator）方式遍历；</p>
</li>
<li>
<p>For Each 方式遍历；</p>
</li>
<li>
<p>Lambda 表达式遍历（JDK 1.8+）;</p>
</li>
<li>
<p>Streams API 遍历（JDK 1.8+）。</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_concurrenthashmap">2.4. ConcurrentHashMap</h3>
<div class="paragraph">
<p>既然 HashMap 是线程不安全的，那么我们需要多线程操作的时候该怎么办呢，Java 提供了一个 ConcurrentHashMap 来进行操作。</p>
</div>
<div class="paragraph">
<p><strong>Java7</strong> 中 ConcurrentHashMap 使用的 <strong>分段锁</strong>，也就是每一个 Segment 上同时只有一个线程可以操作，每一个 Segment 都是一个类似 HashMap 数组的结构，它可以扩容，它的冲突会转化为链表。但是 Segment 的个数一但初始化就不能改变。</p>
</div>
<div class="paragraph">
<p><strong>Java8</strong> 中的 ConcurrentHashMap 使用的 <strong>Synchronized 锁 + CAS 的机制</strong>。结构也由 Java7 中的 <strong>Segment 数组 + HashEntry 数组 + 链表</strong> 进化成了 <strong>Node 数组 + 链表 / 红黑树</strong>，Node 是类似于一个 HashEntry 的结构。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。</p>
</div>
<div class="sect3">
<h4 id="_存储结构">2.4.1. 存储结构</h4>
<div class="paragraph">
<p>在 JDK 1.7 中, ConcurrentHashMap 的存储结构是 <strong>Segment 数组 + HashEntry 数组 + 链表</strong>，在 JDK 1.8 中，ConcurrentHashMap 的存储结构和 JDK 1.8 中的 HashMap 的数据结构是一样的，采用 <strong>Node 数组 + 链表 / 红黑树</strong>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_concurrenthashmap之put方法">2.4.2. ConcurrentHashMap之put方法</h4>
<div class="paragraph">
<p>ConcurrentHashMap 的 put 方法主要通过 <strong>Synchronized 锁 + CAS 的机制</strong> 的方式实现了线程安全，<strong>自旋</strong> 保证操作成功，下面是 ConcurrentHashMap 的 put 方法的流程图：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/ConcurrentHashMap之put方法.png" alt="ConcurrentHashMap之put方法">
</div>
</div>
<div class="paragraph">
<p><strong>put 方法步骤</strong>：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>根据 key 计算出 hashcode 。</p>
</li>
<li>
<p>判断是否需要进行初始化。</p>
</li>
<li>
<p>即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</p>
</li>
<li>
<p>如果当前位置的 hashcode == MOVED == -1,则需要进行扩容。</p>
</li>
<li>
<p>如果都不满足，则利用 synchronized 锁写入数据。</p>
</li>
<li>
<p>如果数量大于 8 则要转换为红黑树。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>put方法源码</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public V put(K key, V value) {
    return putVal(key, value, false);
}

/** Implementation for put and putIfAbsent */
final V putVal(K key, V value, boolean onlyIfAbsent) {
    // key 和 value 不能为空
    if (key == null || value == null) throw new NullPointerException();
    int hash = spread(key.hashCode());
    int binCount = 0;
    for (Node&lt;K,V&gt;[] tab = table;;) {
        // f = 目标位置元素
        Node&lt;K,V&gt; f; int n, i, fh;// fh 后面存放目标位置的元素 hash 值
        if (tab == null || (n = tab.length) == 0)
            // 数组桶为空，初始化数组桶（自旋+CAS)
            tab = initTable();
        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {
            // 桶内为空，CAS 放入，不加锁，成功了就直接 break 跳出
            if (casTabAt(tab, i, null,new Node&lt;K,V&gt;(hash, key, value, null)))
                break;  // no lock when adding to empty bin
        }
        else if ((fh = f.hash) == MOVED)
            tab = helpTransfer(tab, f);
        else {
            V oldVal = null;
            // 使用 synchronized 加锁加入节点
            synchronized (f) {
                if (tabAt(tab, i) == f) {
                    // 说明是链表
                    if (fh &gt;= 0) {
                        binCount = 1;
                        // 循环加入新的或者覆盖节点
                        for (Node&lt;K,V&gt; e = f;; ++binCount) {
                            K ek;
                            if (e.hash == hash &amp;&amp;
                                ((ek = e.key) == key ||
                                 (ek != null &amp;&amp; key.equals(ek)))) {
                                oldVal = e.val;
                                if (!onlyIfAbsent)
                                    e.val = value;
                                break;
                            }
                            Node&lt;K,V&gt; pred = e;
                            if ((e = e.next) == null) {
                                pred.next = new Node&lt;K,V&gt;(hash, key,
                                                          value, null);
                                break;
                            }
                        }
                    }
                    else if (f instanceof TreeBin) {
                        // 红黑树
                        Node&lt;K,V&gt; p;
                        binCount = 2;
                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,
                                                       value)) != null) {
                            oldVal = p.val;
                            if (!onlyIfAbsent)
                                p.val = value;
                        }
                    }
                }
            }
            if (binCount != 0) {
                if (binCount &gt;= TREEIFY_THRESHOLD)
                    treeifyBin(tab, i);
                if (oldVal != null)
                    return oldVal;
                break;
            }
        }
    }
    addCount(1L, binCount);
    return null;
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_JVM_chapter">3. JVM</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_类加载">3.1. 类加载</h3>
<div class="sect3">
<h4 id="_类加载过程">3.1.1. 类加载过程</h4>
<div class="paragraph">
<p>系统加载 Class 类型的文件主要三步：<strong>加载 &#8594; 连接 &#8594; 初始化</strong>。连接过程又可分为三步：<strong>验证 &#8594; 准备 &#8594; 解析</strong>。</p>
</div>
<div class="paragraph">
<p>所以说类加载可以分为五个步骤： <strong>加载 &#8594; 验证 &#8594; 准备 &#8594; 解析 &#8594; 初始化</strong></p>
</div>
<div class="sect4">
<h5 id="_加载">加载</h5>
<div class="paragraph">
<p>通过全类名获取定义此类的二进制字节流（比较常见的就是从 zip，jar，war 中读取），并将二进制字节流加载到方法区。</p>
</div>
</div>
<div class="sect4">
<h5 id="_验证">验证</h5>
<div class="ulist">
<ul>
<li>
<p>验证字节流是否符合Class文件格式规范</p>
</li>
<li>
<p>检查这个类有没有父类，有没有继承不允许继承的类（final修饰的类）</p>
</li>
<li>
<p>检查程序语义是否正确</p>
</li>
<li>
<p>确保解析动作能正确执行</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_准备">准备</h5>
<div class="paragraph">
<p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。</p>
</div>
</div>
<div class="sect4">
<h5 id="_解析">解析</h5>
<div class="paragraph">
<p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。</p>
</div>
</div>
<div class="sect4">
<h5 id="_初始化">初始化</h5>
<div class="paragraph">
<p>就是执行初始化方法</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_类加载器">3.1.2. 类加载器</h4>
<div class="paragraph">
<p>JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自java.lang.ClassLoader：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>BootstrapClassLoader(启动类加载器)</strong>：最顶层的加载类，由 C++实现，负责加载 %JAVA_HOME%/lib目录下的 jar 包和类或者被 -Xbootclasspath参数指定的路径中的所有类。</p>
</li>
<li>
<p><strong>ExtensionClassLoader(扩展类加载器)</strong>：主要负责加载 %JRE_HOME%/lib/ext 目录下的 jar 包和类，或被 java.ext.dirs 系统变量所指定的路径下的 jar 包。</p>
</li>
<li>
<p><strong>AppClassLoader(应用程序类加载器)</strong>：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_双亲委派模型">双亲委派模型</h5>
<div class="paragraph">
<p>每一个类都有一个对应它的类加载器。系统中的 ClassLoader 在协同工作的时候会默认使用 <strong>双亲委派模型</strong> 。即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派给父类加载器的 loadClass() 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 BootstrapClassLoader 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为 null 时，会使用启动类加载器 BootstrapClassLoader 作为父类加载器。</p>
</div>
<div class="paragraph">
<p>其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己想办法去完成，这不就是传说中的实力坑爹啊。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/双亲委派模型.png" alt="双亲委派模型">
</div>
</div>
<div class="paragraph">
<p>双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_逃逸分析">3.2. 逃逸分析</h3>
<div class="paragraph">
<p><a href="https://zhuanlan.zhihu.com/p/208366191" target="_blank" rel="noopener">你真的了解逃逸分析(Escape Analysis）么？</a></p>
</div>
<div class="paragraph">
<p>&emsp;&emsp;逃逸分析，是一种可以有效减少Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</p>
</div>
<div class="sect3">
<h4 id="_逃逸分析的原理">3.2.1. 逃逸分析的原理</h4>
<div class="paragraph">
<p>&emsp;&emsp;Java本身的限制（对象只能分配到堆中），我可以这么理解了，为了减少临时对象在堆内分配的数量，我会在一个方法体内定义一个局部变量，并且该变量在方法执行过程中未发生逃逸，按照JVM调优机制，首先会在堆内存创建类的实例，然后将此对象的引用压入调用栈，继续执行，这是JVM优化前的方式。然后，我采用逃逸分析对JVM进行优化。即针对栈的重新分配方式，首先找出未逃逸的变量，将该变量直接存到栈里，无需进入堆，分配完成后，继续调用栈内执行，最后线程执行结束，栈空间被回收，局部变量也被回收了。如此操作，是优化前在堆中，优化后在栈中，从而减少了堆中对象的分配和销毁，从而优化性能。</p>
</div>
</div>
<div class="sect3">
<h4 id="_逃逸的方式">3.2.2. 逃逸的方式</h4>
<div class="paragraph">
<p>&emsp;&emsp; <strong>方法逃逸</strong>：在一个方法体内，定义一个局部变量，而它可能被外部方法引用，比如作为调用参数传递给方法，或作为对象直接返回。或者，可以理解成对象跳出了方法。</p>
</div>
<div class="paragraph">
<p>&emsp;&emsp; <strong>线程逃逸</strong>：这个对象被其他线程访问到，比如赋值给了实例变量，并被其他线程访问到了。对象逃出了当前线程。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_Thread_chapter">4. 多线程并发</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_linux系统io模型">4.1. Linux系统I/O模型</h3>
<div class="sect3">
<h4 id="_同步异歩阻塞非阻塞">4.1.1. 同步/异歩，阻塞/非阻塞</h4>
<div class="paragraph">
<p>在了解 I/O 之前，需要先知道几个重要的概念，什么是 <strong>同步/异歩</strong>，<strong>阻塞/非阻塞</strong>。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
这四个概念很 <code>重要</code>，必须弄清楚这几个概念，特别是同步和阻塞，异步和非阻塞的区别
</td>
</tr>
</table>
</div>
<div class="paragraph">
<div class="title">同步/异步</div>
<p><strong>同步</strong> ：两个同步任务相互依赖，并且一个任务必须以依赖于另一任务的某种方式执行。 比如在A&#8594;B事件模型中，你需要先完成 A 才能执行B。 再换句话说，同步调用中被调用者未处理完请求之前，调用不返回，调用者会一直等待结果的返回。</p>
</div>
<div class="paragraph">
<p><strong>异步</strong>： 两个异步的任务完全独立的，一方的执行不需要等待另外一方的执行。再换句话说，异步调用种一调用就返回结果不需要等待结果返回，当结果返回的时候通过回调函数或者其他方式拿着结果再做相关事情。</p>
</div>
<div class="paragraph">
<div class="title">阻塞/非阻塞</div>
<p><strong>阻塞</strong>： 阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。</p>
</div>
<div class="paragraph">
<p><strong>非阻塞</strong>： 非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如何区分 “同步/异步 ”和 “阻塞/非阻塞” 呢？<br>
<code><strong>同步/异步是从行为角度描述事物的，而阻塞和非阻塞描述的当前事物的状态（等待调用结果时的状态）。</strong></code>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_五种io模型">4.1.2. 五种I/O模型</h4>
<div class="paragraph">
<p>参考文章： <a href="https://mp.weixin.qq.com/s?__biz=Mzg3MjA4MTExMw==&amp;mid=2247484746&amp;idx=1&amp;sn=c0a7f9129d780786cabfcac0a8aa6bb7&amp;source=41#wechat_redirect" target="_blank" rel="noopener">漫画编程&#8212;&#8203;如何给女朋友解释什么是Linux的五种IO模型？</a></p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在一次I/O操作，数据会先拷贝到 <code>内核空间</code> 中，然后再从内核空间拷贝到 <code>用户空间</code> 中</p>
</div>
<div class="ulist">
<ul>
<li>
<p>1. 等待数据准备（将数据拷贝到 <code>内核空间</code> ）</p>
</li>
<li>
<p>2. 数据从内核空间拷贝到 <code>用户空间</code></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在Linux(UNIX)操作系统中，共有五种IO模型，分别是：<strong>阻塞IO模型</strong>、<strong>非阻塞IO模型</strong>、<strong>IO复用模型</strong>、<strong>信号驱动IO模型</strong> 以及 <strong>异步IO模型</strong>。</p>
</div>
<div class="paragraph">
<div class="title">阻塞IO模型</div>
<p>从进程发起IO操作，一直等待上述两个阶段完成，此时两阶段一起阻塞。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/阻塞IO模型.png" alt="阻塞IO模型">
</div>
</div>
<div class="paragraph">
<div class="title">非阻塞IO模型</div>
<p>进程一直询问IO准备好了没有（轮询），准备好了再发起读取操作，这时才把数据从内核空间拷贝到用户空间。第一阶段不阻塞但要轮询，第二阶段阻塞。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/非阻塞IO模型.png" alt="非阻塞IO模型">
</div>
</div>
<div class="paragraph">
<div class="title">IO复用模型</div>
<p>多个连接使用同一个select去询问IO准备好了没有，如果有准备好了的，就返回有数据准备好了，然后对应的连接再发起读取操作，把数据从内核空间拷贝到用户空间。两阶段分开阻塞。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/IO复用模型.png" alt="IO复用模型">
</div>
</div>
<div class="paragraph">
<div class="title">信号驱动IO模型</div>
<p>进程发起读取操作会立即返回，当数据准备好了会以通知的形式告诉进程，进程再发起读取操作，把数据从内核空间拷贝到用户空间。第一阶段不阻塞，第二阶段阻塞。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/信号驱动IO模型.png" alt="信号驱动IO模型">
</div>
</div>
<div class="paragraph">
<div class="title">异步IO模型</div>
<p>进程发起读取操作会立即返回，等到数据准备好且已经拷贝到用户空间了再通知进程拿数据。两个阶段都不阻塞。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/异步IO模型.png" alt="异步IO模型">
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
需要注意的是，在这五种IO模型中，<code>阻塞IO模型</code>、<code>非阻塞IO模型</code>、<code>IO复用模型</code>、<code>信号驱动IO模型</code> 这四种模型属于 <code>同步IO模型</code>； <code>异步IO模型</code> 才是真正的 <code>异步IO模型</code>。这是因为在前四种I模型中，无论在第一步（将数据准备到内核空间中）是阻塞还是非阻塞的，在第二步（将数据从内核空间中拷贝到用户空间中）的时候是阻塞的，所以从整个IO过程来看，是同步的；在异步IO模型中，两个步骤都是非阻塞的，所以是异步的。<br>
<br>
这里容易错误的以为 <code>信号驱动IO模型</code> 是异步模型，需要注意一下。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<div class="title">五种IO模型对比</div>
<p>通过对五种IO模型的认识，下面这张图对比五种IO模型的区别。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/IO模型对比.jpeg" alt="IO模型对比">
</div>
</div>
</div>
<div class="sect3">
<h4 id="_bionioaio">4.1.3. BIO/NIO/AIO</h4>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
在java的IO中，我们可能会经常遇到 <code>channel</code> 和 <code>pipeline</code> 这两个词，从英语的角度翻译过来都是 <code>通道，管道</code> 的意思。我们容易弄不清楚他们的区别。<br>
<br>
NIO的 <code>channel</code> 是NIO的核心之一，指的是连接资源的通道，channel用于IO传输，这里的 <code>pipeline</code> 只是附带的一个小功能，用线程间数据交互。<br>
<br>
channel &#8594; IO通道（远程或本地）<br>
pipeline &#8594; jvm进程内的线程间管道
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Java 中的 BIO、NIO和AIO理解为是 Java 语言在操作系统层面对这三种 IO 模型的封装。程序员在使用这些 封装API 的时候，不需要关心操作系统层面的知识，也不需要根据不同操作系统编写不同的代码，只需要使用Java的API就可以了。</p>
</div>
<div class="sect4">
<h5 id="_bio">BIO</h5>
<div class="paragraph">
<div class="title">传统BIO</div>
<p>采用 BIO 通信模型 的服务端，通常由一个独立的 Acceptor 线程负责监听客户端的连接。我们一般通过在while(true) 循环中服务端会调用 accept() 方法等待接收客户端的连接的方式监听请求，请求一旦接收到一个连接请求，就可以建立通信套接字在这个通信套接字上进行读写操作，此时不能再接收其他客户端连接请求，只能等待同当前连接的客户端的操作执行完成， 不过可以通过多线程来支持多个客户端的连接，如上图所示。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/BIO通信模型.png" alt="BIO通信模型">
</div>
</div>
<div class="paragraph">
<div class="title">伪异步IO</div>
<p>为了解决同步阻塞I/O面临的一个链路需要一个线程处理的问题，后来有人对它的线程模型进行了优化一一一后端通过一个线程池来处理多个客户端的请求接入，形成客户端个数M：线程池最大线程数N的比例关系，其中M可以远远大于N.通过线程池可以灵活地调配线程资源，设置线程的最大值，防止由于海量并发接入导致线程耗尽。</p>
</div>
<div class="paragraph">
<p>采用线程池和任务队列可以实现一种叫做伪异步的 I/O 通信框架，它的模型图如下图所示。当有新的客户端接入时，将客户端的 Socket 封装成一个Task（该任务实现java.lang.Runnable接口）投递到后端的线程池中进行处理，JDK 的线程池维护一个消息队列和 N 个活跃线程，对消息队列中的任务进行处理。由于线程池可以设置消息队列的大小和最大线程数，因此，它的资源占用是可控的，无论多少个客户端并发访问，都不会导致资源的耗尽和宕机。</p>
</div>
<div class="paragraph">
<p>伪异步I/O通信框架采用了线程池实现，因此避免了为每个请求都创建一个独立线程造成的线程资源耗尽问题。不过因为它的底层仍然是同步阻塞的BIO模型，因此无法从根本上解决问题。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/伪异步IO模型.png" alt="伪异步IO模型">
</div>
</div>
</div>
<div class="sect4">
<h5 id="_nio">NIO</h5>
<div class="paragraph">
<p><code>NIO</code> 是一种同步非阻塞的I/O模型。</p>
</div>
<div class="ulist">
<div class="title">NIO的核心组件</div>
<ul>
<li>
<p>Channel(通道)</p>
</li>
<li>
<p>Buffer(缓冲区)</p>
</li>
<li>
<p>Selector(选择器)</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="images/Slector.png" alt="Slector">
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>通常来说NIO中的所有IO都是从 Channel（通道） 开始的。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>从通道进行数据读取 ：创建一个缓冲区，然后请求通道读取数据。<br></p>
</li>
<li>
<p>从通道进行数据写入 ：创建一个缓冲区，填充数据，并要求通道写入数据。</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="imageblock">
<div class="content">
<img src="images/NIO读写数据的方式.png" alt="NIO读写数据的方式">
</div>
</div>
</div>
<div class="sect4">
<h5 id="_aio">AIO</h5>
<div class="paragraph">
<p>异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_volatile">4.2. volatile</h3>
<div class="paragraph">
<p>参考文档： <a href="https://www.cnblogs.com/javazhiyin/p/13521567.html" target="_blank" rel="noopener">面试官最爱的 volatile 关键字，这些问题你都搞懂了没？</a></p>
</div>
<div class="sect3">
<h4 id="_什么是jmmjava内存模型">4.2.1. 什么是JMM(Java内存模型)</h4>
<div class="paragraph">
<p><a href="https://zhuanlan.zhihu.com/p/258393139" target="_blank" rel="noopener">面试官问我什么是JMM</a></p>
</div>
<div class="paragraph">
<p>&emsp;&emsp;JMM指的是 在Java中定义了程序中各种变量的访问规范，屏蔽掉各种硬件和操作系统的内存访问差异，以实现让java程序在各种平台下都能达到一致的并发效果。</p>
</div>
</div>
<div class="sect3">
<h4 id="_volatile_的作用">4.2.2. volatile 的作用</h4>
<div class="paragraph">
<p>被 volatile 修饰的变量具有的特性：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>保证此变量对所有线程的可见性</strong></p>
</li>
<li>
<p><strong>禁止指令重排序优化</strong></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_指令重排序">指令重排序</h5>
<div class="paragraph">
<p>&emsp;&emsp; <strong>在不改变程序执行结果的前提下，尽可能提高程序的运行效率</strong> ，意思是在不改变程序运行结果的情况下，调整代码执行顺序，优化程序。（JVM虚拟机的一种优化措施）。</p>
</div>
<div class="paragraph">
<p>&emsp;&emsp;重排序不会影响单线程环境的执行结果，但是会破坏多线程的执行语义。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">volatile boolean isOK = false;

//假设以下代码在线程A执行
A.init();
isOK=true;

//假设以下代码在线程B执行
while(!isOK){
  sleep();
}
B.init();</code></pre>
</div>
</div>
<div class="paragraph">
<p>&emsp;&emsp;线程在初始化的时候，B线程处于睡眠状态，等待A线程完成初始化的时候才能够进行自己的初始化。这里的先后关系依赖于isOK这个变量。</p>
</div>
<div class="paragraph">
<p>&emsp;&emsp;如果没有volatile修饰isOK这个变量，那么isOK的赋值就可能出现在A.init()之前（指令重排序,Java虚拟机的一种优化措施），此时A没有初始化，而B的初始化就破坏了它们之前形成的那种依赖关系，可能就会出错。</p>
</div>
<div class="paragraph">
<p>&emsp;&emsp;volatile关键字通过 “<strong>内存屏障</strong>” 的方式来防止指令被重排序，即：<strong>在每个 volatile 读写操作前后加一种CPU指令</strong>。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
内存屏障: 内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）是一种CPU指令，用于控制特定条件下的重排序和内存可见性问题。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_volatile的可见性问题">4.2.3. volatile的可见性问题</h4>
<div class="paragraph">
<p>&emsp;&emsp;内存可见性是指当一个线程修改了某个变量的值，其它线程总是能知道这个变量变化。也就是说，如果线程 A 修改了共享变量 V 的值，那么线程 B 在使用 V 的值时，能立即读到 V 的最新值。</p>
</div>
<div class="paragraph">
<p>&emsp;&emsp;使用 volatile 修饰共享变量后，每个线程要操作变量时会从主内存中将变量拷贝到本地内存作为副本。当线程操作变量副本并写回主内存后，会通过 <strong>CPU 总线嗅探机制</strong> 告知其他线程该变量副本已经失效，需要重新从主内存中读取。(CPU 总线嗅探机制 是实现缓存一致性的常见机制，想要了解更多可以看看这篇文章 <a href="https://zhuanlan.zhihu.com/p/138819184" target="_blank" rel="noopener">volatile 关键字，你真的理解吗？</a>)</p>
</div>
<div class="paragraph">
<p>所以：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>每次直接从主内存读取值</strong>。</p>
</li>
<li>
<p><strong>每次写入强制修改主内存的值</strong>。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>需要注意的是：volatile 是不能保证原子性的。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>&emsp;&emsp;在 Java 内存模型（JMM）中规定：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写共享变量的副本。这里所说的共享变量指的是实例变量和类变量，不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。</p>
</li>
<li>
<p>线程对变量的所有的操作（读，取）都必须在工作内存中完成，而不能直接读写主内存中的变量。</p>
</li>
<li>
<p>不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存中转来完成。</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="images/JMM示意图.webp" alt="JMM示意图">
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_synchronized">4.3. synchronized</h3>
<div class="paragraph">
<p><a href="https://blog.csdn.net/Hdu_lc14015312/article/details/100053032" target="_blank" rel="noopener">java中的几种锁（很详细）-小白收藏</a></p>
</div>
<div class="paragraph">
<p><a href="https://juejin.cn/post/6973571891915128846" target="_blank" rel="noopener">这一次，彻底搞懂Java中的synchronized关键字</a></p>
</div>
<div class="paragraph">
<p><a href="https://juejin.cn/post/6977744582725681182" target="_blank" rel="noopener">彻底理解Java并发编程之Synchronized关键字实现原理剖析</a></p>
</div>
<div class="sect3">
<h4 id="_实现原理">4.3.1. 实现原理</h4>
<div class="paragraph">
<p>JVM 是通过进入、退出对象监视器( Monitor )来实现对方法、同步块的同步的。</p>
</div>
<div class="paragraph">
<p>具体实现是在编译之后在 <strong>同步方法调用前</strong> 加入一个 <strong>monitor.enter</strong> 指令，在 <strong>退出方法和异常处</strong> 插入 <strong>monitor.exit</strong> 的指令。</p>
</div>
<div class="paragraph">
<p>其本质就是对一个对象监视器( Monitor )进行获取，而这个获取过程具有排他性从而达到了同一时刻只能一个线程访问的目的。</p>
</div>
<div class="paragraph">
<p>而对于没有获取到锁的线程将会阻塞到方法入口处，直到获取锁的线程 monitor.exit 之后才能尝试继续获取锁。</p>
</div>
<div class="paragraph">
<p>流程图如下:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/synchronized实现同步原理的流程图.jpg" alt="synchronized实现同步原理的流程图">
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_java中的锁">4.4. Java中的锁</h3>
<div class="sect3">
<h4 id="_乐观锁">4.4.1. 乐观锁</h4>
<div class="paragraph">
<p>&emsp;&emsp;总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，只在更新的时候会判断一下在此期间别人有没有去更新这个数据。Java中的乐观锁基本是通过CAS实现的。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
乐观锁不能解决 ABA 问题。解决 ABA 问题，可以在修改数据中添加一个版本号，修改数据前，根据版本号确定数据是否被修改过。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_悲观锁">4.4.2. 悲观锁</h4>
<div class="paragraph">
<p>&emsp;&emsp;总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞，直到它拿到锁。</p>
</div>
</div>
<div class="sect3">
<h4 id="_自旋锁">4.4.3. 自旋锁</h4>
<div class="paragraph">
<p>&emsp;&emsp;自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需自旋，等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。线程自旋需消耗 cup 的，如果一直获取不到锁，则线程长时间占用CPU自旋，需要设定一个自旋等待最大事件在最大等待时间内仍未获得锁就会停止自旋进入阻塞状态。</p>
</div>
</div>
<div class="sect3">
<h4 id="_公平锁和非公平锁">4.4.4. 公平锁和非公平锁</h4>
<div class="paragraph">
<p>&emsp;&emsp;所谓公平指的是线程获取到锁时，争抢锁资源的线程是否遵循先到先得的规则。</p>
</div>
<div class="paragraph">
<p>&emsp;&emsp;公平锁指的是锁的分配机制是公平的，通常先对锁提出获取请求的线程会先被分配到锁。非公平锁中存在后来的线程先获得锁资源的情况。</p>
</div>
</div>
<div class="sect3">
<h4 id="_可重入锁">4.4.5. 可重入锁</h4>
<div class="paragraph">
<p>&emsp;&emsp;如果当前线程已经获得了某个监视器对象所持有的锁，那么该线程在该方法中调用另外一个同步方法也同样持有该锁。可重入锁最大的作用就是避免死锁。</p>
</div>
</div>
<div class="sect3">
<h4 id="_读写锁">4.4.6. 读写锁</h4>
<div class="paragraph">
<p>&emsp;&emsp;读锁： 允许多个线程获取读锁，同时访问同一个资源。</p>
</div>
<div class="paragraph">
<p>&emsp;&emsp;写锁： 只允许一个线程获取写锁，不允许同时访问同一个资源。</p>
</div>
<div class="paragraph">
<p>&emsp;&emsp;Java中的读写锁：ReentrantReadWriteLock</p>
</div>
</div>
<div class="sect3">
<h4 id="_独占锁和共享锁">4.4.7. 独占锁和共享锁</h4>
<div class="paragraph">
<p>&emsp;&emsp;独占锁：每次只能有一个线程能持有锁</p>
</div>
<div class="paragraph">
<p>&emsp;&emsp;共享锁：允许多个线程同时获取锁，并发访问共享资源</p>
</div>
</div>
<div class="sect3">
<h4 id="_锁粗化">4.4.8. 锁粗化</h4>
<div class="paragraph">
<p>&emsp;&emsp;锁粗化是一种优化技术： 如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作都是出现在循环体体之中，就算真的没有线程竞争，频繁地进行互斥同步操作将会导致不必要的性能损耗，所以就采取了一种方案：把加锁的范围扩展（粗化）到整个操作序列的外部，这样加锁解锁的频率就会大大降低，从而减少了性能损耗。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_线程的生命周期">4.5. 线程的生命周期</h3>
<div class="sidebarblock">
<div class="content">
<div class="title">线程的6种状态</div>
<div class="ulist">
<ul>
<li>
<p><strong>初始(NEW)</strong>：新创建了一个线程对象，但还没有调用start()方法。</p>
</li>
<li>
<p><strong>运行(RUNNABLE)</strong>：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。<br>
线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。</p>
</li>
<li>
<p><strong>等待(WAITING)</strong>：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</p>
</li>
<li>
<p><strong>阻塞(BLOCKED)</strong>：表示线程阻塞于锁。</p>
</li>
<li>
<p><strong>超时等待(TIMED_WAITING)</strong>：该状态不同于WAITING，它可以在指定的时间后自行返回。</p>
</li>
<li>
<p><strong>终止(TERMINATED)</strong>：表示该线程已经执行完毕。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/线程的生命周期(线程的6种状态).jpeg" alt="线程的生命周期(线程的6种状态)">
</div>
</div>
<div class="sect3">
<h4 id="_yield">4.5.1. yield()</h4>
<div class="paragraph">
<p>&emsp;&emsp;线程调用了yield()方法，意思是放弃当前获得的CPU时间片，回到就绪状态，这时与其他进程处于同等竞争状态</p>
</div>
</div>
<div class="sect3">
<h4 id="_join">4.5.2. join()</h4>
<div class="paragraph">
<p>&emsp;&emsp;使得放弃当前线程的执行，并返回对应的线程。程序在main线程中调用t1线程的join方法，则main线程放弃cpu控制权，并返回t1线程继续执行直到线程t1执行完毕所以结果是t1线程执行完后，才到主线程执行，相当于在main线程中同步t1线程，t1执行完了，main线程才有执行的机会。</p>
</div>
</div>
<div class="sect3">
<h4 id="_wait_和_notify">4.5.3. wait() 和 notify()</h4>
<div class="paragraph">
<p>&emsp;&emsp;当线程调用wait()方法后会进入等待队列（进入这个状态会释放所占有的所有资源，与阻塞状态不同），进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify()或notifyAll()方法才能被唤醒（由于notify()只是唤醒一个线程，但我们由不能确定具体唤醒的是哪一个线程，也许我们需要唤醒的线程不能够被唤醒，因此在实际使用时，一般都用notifyAll()方法，唤醒有所线程），线程被唤醒后会进入锁池，等待获取锁标记。</p>
</div>
</div>
<div class="sect3">
<h4 id="_wait_和_sleep_的区别">4.5.4. wait() 和 sleep() 的区别</h4>
<div class="ulist">
<ul>
<li>
<p>wait() 来自 Object 类，sleep() 来自 Thread 类</p>
</li>
<li>
<p>sleep() 没有释放锁；wait() 释放了锁，让敏感词线程可以使用同步块或方法。</p>
</li>
<li>
<p>wait()、notify() 和 notifyAll() 只能在同步方法或控制块里使用，只有在synchronized方法或块中当前线程才占有锁，才有锁可以释放；sleep() 可以在任何地方使用。</p>
</li>
<li>
<p>sleep() 必须捕获异常；wait()、notify() 和 notifyAll() 不需要</p>
</li>
<li>
<p>wait() 不加时间限制，要等待 notify() 或 notifyAll() 唤醒等待池中所有的线程（执行完 notify() 或 notifyAll() 或 wait() 后，并不立即获得或释放锁，而是执行完同步块后再释放或获得），才会进入就绪队列等待OS分配系统资源；sleep() 可以设置时间唤醒，如果时间不到，只能用interrupt()强行打断。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_interrupted_和_isinterrupted_的区别">4.5.5. interrupted() 和 isInterrupted() 的区别</h4>
<div class="ulist">
<ul>
<li>
<p>二个方法都是判断线程是否停止的方法</p>
</li>
<li>
<p>前者是静态方法，后者是非静态方法。interrupted() 是作用于当前正在运行的线程，isInterrupted() 是作用于调用该方法的线程对象所对应的线程。</p>
</li>
<li>
<p>前者会将中断状态清除而后者不会。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_线程的创建方式">4.6. 线程的创建方式</h3>
<div class="sect3">
<h4 id="_thread">4.6.1. Thread</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class NewThread extends Thread {
    public void run() {
        System.out.println("通过继承Thread类实现");
    }
}

new Thread（new NewThread()).start();</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Thread 本质上是实现了 Runable 接口。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_runable">4.6.2. Runable</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class NewThread implements Runnable {
    public void run() {
        System.out.println("通过实现Runable接口实现");
    }
}

new Thread（new NewThread()).start();</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_callable">4.6.3. Callable</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// ExecutorService、Callable&lt;Class&gt;、Future (子线程会有返回值)

public class Test {
    public static void main(String[] args) {
        // 线程池
        ExecutorService executor = Executors.newCachedThreadPool();
        Task task = new Task();
        // 执行任务并获取 Future 对象
        Future&lt;String&gt; future = executor.submit(task);
        // 关闭线程池
        executor.shutdown();

        System.out.println("当前为主线程");

        try {
            // 获取子线程返回值
            System.out.println(future.get());
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }

        System.out.println("所有任务执行完毕");
    }
}

class Task implements Callable&lt;String&gt;{
    @Override
    public String call() throws Exception {
        return "子线程返回值";
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
通过 <code>Callable</code> 创建新线程，一般是和 <code>ExecutorService</code> 配合来使用的
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_基于线程池的方式">4.6.4. 基于线程池的方式</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// 创建线程池
ExecutorService threadPool = Executors.newFixedThreadPool(10);
while(true) {
    // 提交多个线程任务,并执行
    threadPool.execute(new Runnable() {
        @Override
        public void run() {
            System.out.println(Thread.currentThread().getName() + " is running ..");
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
            }
        }
    });
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
 <code>为什么推荐采用线程池的方式</code> ：<br>
线程和数据库连接的  <code>创建</code>  和  <code>销毁</code>  都是非常浪费资源的，使用线程池避免了频繁的创建和销毁。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_runable和callable区别">4.6.5. Runable和Callable区别</h4>
<div class="listingblock">
<div class="content">
<pre>1. Runable 没有返回值，Callable有返回值（返回Future对象）
2. Runable不能抛出异常，Callable可以抛出异常
3. Callable在JUC包下，属于线程安全的接口</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Callalble接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。这个其实和 CountDownLatch + Runable 实现主线程等待所有子线程执行完再继续执行的功能类似。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_java线程池">4.7. Java线程池</h3>
<div class="paragraph">
<p><strong>线程池原理</strong>：<br>
线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列,然后在线程创建后，启动这些任务,如果线程数量超过了最大数量超出数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。他的主要特点为: <code>线程复用</code>，<code>控制最大并发数</code>，<code>管理线程</code>。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">线程池的5种状态</div>
<div class="ulist">
<ul>
<li>
<p><strong>RUNNING</strong>：表示线程池处于运行状态，能够接受新提交的任务且能对已添加的任务进行处理。RUNNING状态是线程池的初始化状态，线程池一旦被创建就处于RUNNING状态。</p>
</li>
<li>
<p><strong>SHUTDOWN</strong>：线程处于关闭状态，不接受新任务，但可以处理已添加的任务。RUNNING状态的线程池调用shutdown后会进入SHUTDOWN状态。</p>
</li>
<li>
<p><strong>STOP</strong>：线程池处于停止状态，不接收任务，不处理已添加的任务，且会中断正在执行任务的线程。RUNNING状态的线程池调用了shutdownNow后会进入STOP状态。</p>
</li>
<li>
<p><strong>TIDYING</strong>：当所有任务已终止，且任务数量为0时，线程池会进入TIDYING。当线程池处于SHUTDOWN状态时，阻塞队列中的任务被执行完了，且线程池中没有正在执行的任务了，状态会由SHUTDOWN变为TIDYING。当线程处于STOP状态时，线程池中没有正在执行的任务时则会由STOP变为TIDYING。</p>
</li>
<li>
<p><strong>TERMINATED</strong>：线程终止状态。处于TIDYING状态的线程执行terminated()后进入TERMINATED状态。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/线程池的5种状态.awebp" alt="线程池的5种状态">
</div>
</div>
<div class="sect3">
<h4 id="_threadpoolexecutor_推荐">4.7.1. ThreadPoolExecutor (推荐)</h4>
<div class="paragraph">
<p>ThreadPoolExecutor 创建线程池的几个核心参数： <code>核心线程数</code>， <code>最大线程数</code>， <code>超过核心线程数量的线程最大空闲时间</code>， <code>时间单位</code>， <code>阻塞队列</code>， <code>拒绝策略</code>。</p>
</div>
<div class="olist arabic">
<div class="title">核心参数的关联关系</div>
<ol class="arabic">
<li>
<p>如果运行的线程数小于 <code>核心线程数</code>，提交新任务时就会新建一个线程来运行，即使其他核心线程能够执行新任务也会创建线程；</p>
</li>
<li>
<p>如果运行线程数大于或等于 <code>核心线程数</code>，新提交的任务就会加入到 <code>阻塞队列</code> 等待；如果队列已满，并且已创建的线程数小于 <code>最大线程数</code>，也将会新建一个线程来运行；</p>
</li>
<li>
<p>如果线程数大于 <code>最大线程数</code>，新提交的任务将会根据拒绝策略来处理。</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>需要注意的是： 如果采用 <code>无界队列</code> 时， <code>最大线程数</code> 和 <code>超过核心线程数量的线程最大空闲时间</code> 这两个参数就不起作用了</p>
</div>
<div class="paragraph">
<p>一般我们称核心线程池中的线程为核心线程，这部分线程不会被回收；超过任务队列后，创建的线程为空闲线程，这部分线程会被回收（回收时间即 keepAliveTime）</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<div class="title">阻塞队列入队策略</div>
<p><strong>直接传递</strong>： 使用 <code>SynchronousQueue</code> 作为阻塞队列，线程池的数量无限大，新任务会直接分配或者创建一个线程进行执行。</p>
</div>
<div class="paragraph">
<p><strong>无界队列</strong>： 使用无界队列（例如： <code>LinkedBlockingQueue</code>）作为阻塞队列，当所有的核心线程都在处理任务时，新提交的任务都会进入队列等待。线程池大小固定，队列长度无限制。</p>
</div>
<div class="paragraph">
<p><strong>有界队列</strong>： 使用有界队列（例如： <code>ArrayBlockingQueue</code>）作为阻塞队列，可以防止资源耗尽，但是难以调整和控制。队列大小和线程池大小可以相互作用。</p>
</div>
<div class="paragraph">
<div class="title">拒绝策略</div>
<p>当线程池已经关闭或达到饱和（最大线程和队列都已满）状态时，新提交的任务将会被拒绝。<code>ThreadPoolExecutor</code> 定义了四种拒绝策略：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>AbortPolicy</strong>：默认策略，在需要拒绝任务时抛出RejectedExecutionException；</p>
</li>
<li>
<p><strong>CallerRunsPolicy</strong>：直接在 execute 方法的调用线程中运行被拒绝的任务（用调用者所在线程来运行任务），如果线程池已经关闭，任务将被丢弃；</p>
</li>
<li>
<p><strong>DiscardPolicy</strong>：直接丢弃任务；</p>
</li>
<li>
<p><strong>DiscardOldestPolicy</strong>：丢弃队列中等待时间最长的任务，并执行当前提交的任务，如果线程池已经关闭，任务将被丢弃。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>也可以自定义拒绝策略，只需要实现 <strong>RejectedExecutionHandler</strong> 接口。</p>
</div>
<div class="listingblock">
<div class="title">创建线程池</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// 核心线程数
int corePoolSize = 3;
// 最大线程数
int maximumPoolSize = 6;
// 超过 corePoolSize 线程数量的线程最大空闲时间
long keepAliveTime = 2;
// 以秒为时间单位
TimeUnit unit = TimeUnit.SECONDS;
// 创建工作队列，用于存放提交的等待执行任务
BlockingQueue&lt;Runnable&gt; workQueue = new ArrayBlockingQueue&lt;Runnable&gt;(100);
// 创建线程池
ThreadPoolExecutorthreadPoolExecutor = new ThreadPoolExecutor(corePoolSize,
                    maximumPoolSize,
                    keepAliveTime,
                    unit,
                    workQueue,
                    new ThreadPoolExecutor.AbortPolicy());</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_executors">4.7.2. Executors</h4>
<div class="paragraph">
<p>Executors 创建线程池其实也是通过 <code>ThreadPoolExecutor</code> 进行创建的，只不过参数固定，<code>ThreadPoolExecutor</code> 参数不固定，在开发中更加符合业务需求，所以更推荐使用 <code>ThreadPoolExecutor</code> 创建线程池。</p>
</div>
<div class="listingblock">
<div class="title">newCachedThreadPool</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">创建一个可根据需要创建新线程的线程池,但是在以前构造的线程可用时将重用它们。对于执行很多短期异步任务的程序而言,这些线程池通常可提高程序性能。调用 execute 将重用以前构造的线程(如果线程可用)。如果现有线程没有可用的,则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">newFixedThreadPool</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">创建一个可重用固定线程数的线程池,以共享的无界队列方式来运行这些线程。</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">newScheduledThreadPool</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">创建一个线程池,它可安排在给定延迟后运行命令或者定期地执行。</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">newSingleThreadExecutor</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">Executors.newSingleThreadExecutor()返回一个线程池(这个线程池只有一个线程),这个线程
池可以在线程死后(或发生异常时)重新启动一个线程来替代原来的线程继续执行下去!</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Executors 创建线程的弊端：</p>
</div>
<div class="paragraph">
<p><code>newFixedThreadPool</code> 和 <code>newSingleThreadExecutor</code>: 主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至OOM(内存用完了)。</p>
</div>
<div class="paragraph">
<p><code>newCachedThreadPool</code> 和 <code>newScheduledThreadPool</code>: 主要问题是线程数最大数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_记一次多线程研发遇到的坑">4.8. 记一次多线程研发遇到的坑</h3>
<div class="sect3">
<h4 id="_问题背景">4.8.1. 问题背景</h4>
<div class="listingblock">
<div class="content">
<pre>1. 开发一套经验支持系统，就是通过创建公共的经验模型和规则，然后由模型获取并整合数据，将数据输入规则中，得到返回结果。
2. 难点: 模型中存在多个对象（M），并且每个对象可以通过SQL获取API获取多个数据（N），也就是说，跑一次模型，一个规则需要被执行 M 次，并且需要查询数据 M * N 次。
3. 目标: 降低跑一次模型需要用的时间，提升速度。</pre>
</div>
</div>
<div class="paragraph">
<p>如下图:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/多线程遇到的坑-业务逻辑图.png" alt="多线程遇到的坑 业务逻辑图">
</div>
</div>
</div>
<div class="sect3">
<h4 id="_研发方案的迭代">4.8.2. 研发方案的迭代</h4>
<div class="listingblock">
<div class="content">
<pre>1. for循环
2. 线程池框架 ThreadPoolExecutor（Disruptor，gitee-京东零售）</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_遇到的坑">4.8.3. 遇到的坑</h4>
<div class="sect4">
<h5 id="_1死锁">1、死锁</h5>
<div class="listingblock">
<div class="content">
<pre>出现问题的原因:
1. 只定义了一个线程池
2. 自定义了 10 个核心线程数
3. 有 60 个对象需要执行规则逻辑（下面用 A 代替），每个对象需要 调用 2 个api接口获取数据
4. 如果有 10 个 A 占用了 10 个线程，但是他们需要等待 api 接口获取到数据才能继续执行，但是查数据的任务又在等待队列中，等待核心线程资源释放，这时就会一直等待

解决办法:
1. 创建两个线程池分别执行这两种任务</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_2经典线程安全问题">2、经典线程安全问题</h5>
<div class="listingblock">
<div class="content">
<pre>出现问题的原因:
1. 多个线程中对同一个对象中的属性进行修改

解决办法:
1. 禁止在多线程中对同一个对象的属性进行修改
2. 使用JUC下的线程安全对象
3. 在子线程中创建新的对象接受需要修改的值，最后通过线程返回值返回
4. 对数据操作方法加锁（不推荐）</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_3内存泄漏问题">3、内存泄漏问题</h5>
<div class="sect5">
<h6 id="_1_问题描述">(1) 问题描述</h6>
<div class="listingblock">
<div class="content">
<pre>在项目部署后，一开始模型和模型实例较少，程序的负担较低，没有发现问题。但是随着模型和模型实例的数量越来越多，我们发现内存占用上涨的非常快，一天的时间就可以将4个G的内存占满（内存泄漏）。</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_2_可能的原因">(2) 可能的原因</h6>
<div class="listingblock">
<div class="content">
<pre>1. 项目是使用观云台（公司的产品）部署的，因此程序是在 K8s 的 Pod 中运行的。在pod中运行的程序打印日志（输出日志到控制台和写日志到日志文件）是会占用大量的内存的。该项目本身是一个多线程运行模型的程序，为了方便排查问题，日志打印的也比较多，所以造成pod的内存被大量占用。

2. 程序中存在对象一直没有被释放，导致内存泄漏。</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>TODO: 为什么打印大量的日志会造成内存占用过高？后续讨论&#8230;&#8203;</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="_3_解决办法">(3) 解决办法</h6>
<div class="listingblock">
<div class="content">
<pre>1. 在正式环境中，日志的打印等级要调低一些，尽量使用 Error 作为日志输出等级。

2. 排查程序中是否有对象没有被回收掉，导致内存泄漏，然后修改代码。（排查过程在后续中会些出来）</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_4_排查内存泄漏的原因">(4) 排查内存泄漏的原因</h6>
<div class="paragraph">
<p>说明：异常管控服务是通过 K8s 进行部署的。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>首先第一步进入到部署的容器中，命令： <strong>docker exec -it 容器名 /bin/bash</strong></p>
</li>
<li>
<p>然后查看java进程列表，命令： <strong>ps -ef | grep java</strong></p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="images/查看java进程.png" alt="查看java进程">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>通过 <strong>jmap</strong> 命令，查看查看堆内存的使用情况，命令：<strong>jmap -heap 进程id</strong></p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>堆内存详情参数解释：

Heap Configuration:         ## 堆配置情况，也就是JVM参数配置的结果[平常说的tomcat配置JVM参数，就是在配置这些]
   MinHeapFreeRatio         = 40                            //JVM堆最小空闲比率(default 40)
   MaxHeapFreeRatio         = 70                            //JVM堆最大空闲比率(default 70)
   MaxHeapSize              = 402653184 (384.0MB)           //JVM堆的最大大小
   NewSize                  = 8388608 (8.0MB)               //JVM堆的‘新生代’的默认大小
   MaxNewSize               = 134217728 (128.0MB)           //JVM堆的‘新生代’的最大大小
   OldSize                  = 16777216 (16.0MB)             //JVM堆的‘老生代’的大小
   NewRatio                 = 2                             //‘新生代’和‘老生代’的大小比率
   SurvivorRatio            = 8                             //年轻代中Eden区与Survivor区的大小比值
   MetaspaceSize            = 21807104 (20.796875MB)        //元空间大小
   CompressedClassSpaceSize = 1073741824 (1024.0MB)         //元空间中类区域的大小
   MaxMetaspaceSize         = 17592186044415 MB             //元空间最大值，设置这么大，意思是让jvm自己去管理
   G1HeapRegionSize         = 0 (0.0MB)

Heap Usage:                ## 堆内存分布
New Generation (Eden + 1 Survivor Space):                   //新生代（Eden区 + survior(from + to)空间）
   capacity = 70713344 (67.4375MB)                          //新生代区容量
   used     = 38155000 (36.38744354248047MB)                //新生代区已经使用大小
   free     = 32558344 (31.05005645751953MB)                //新生代区剩余容量
   53.95728421498494% used                                  //使用比例
Eden Space:                                                 //Eden区容量
   capacity = 62914560 (60.0MB)
   used     = 37078688 (35.360992431640625MB)
   free     = 25835872 (24.639007568359375MB)
   58.93498738606771% used
From Space:                                                 //from survior
   capacity = 7798784 (7.4375MB)
   used     = 1076312 (1.0264511108398438MB)
   free     = 6722472 (6.411048889160156MB)
   13.801023339023109% used
To Space:                                                   //to survior
   capacity = 7798784 (7.4375MB)
   used     = 0 (0.0MB)
   free     = 7798784 (7.4375MB)
   0.0% used
PS Old Generation:                                         //老年代
   capacity = 156958720 (149.6875MB)
   used     = 125501120 (119.68719482421875MB)
   free     = 31457600 (30.00030517578125MB)
   79.95804247129436% used</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>查看java进程中的堆内存对象数量情况，命令： <strong>jmap -histo:live 进程id</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>下面三张图是服务不同时期，堆内存对象数量情况：</p>
</div>
<div class="paragraph">
<p>&emsp;&emsp;1.服务已启动，未运行模型的堆内存中对象数量情况</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/堆内存对象数量情况03.png" alt="堆内存对象数量情况03">
</div>
</div>
<div class="paragraph">
<p>&emsp;&emsp;2.服务已启动，在执行模型，服务启动时间不长的堆内存对象数量情况</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/堆内存对象数量情况01.png" alt="堆内存对象数量情况01">
</div>
</div>
<div class="paragraph">
<p>&emsp;&emsp;3.服务已启动，在执行模型，运行了一段时间后，快到达最大堆内存   的堆内存对象数量情况</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/堆内存对象数量情况02.png" alt="堆内存对象数量情况02">
</div>
</div>
<div class="paragraph">
<p>&emsp;&emsp;从上面三张图中可以看出，服务随着运行时间的增加，内存占用越来越高，可以看出有很多的对象数量一直再增加，比如 <strong>ThreadLocalMap</strong> 对象。一开始我看到这个的时候，还以为是某个 ThreadLocal 使用后没有被回收，造成内存泄漏。然后我立马去看代码，经过仔细的排查后，所有的 ThreadLocal 都在使用后，及时的调用了 clear() 方法的，所以并不是 ThreadLocal 造成内存缓慢增长的。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>把进程的内存使用情况dump到文件中，使用命令：<strong>jmap -dump:format=b,file=文件名.hprof 进程id</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>&emsp;&emsp;然后将该文件下载到本地，使用 <strong>MemoryAnalyzer</strong> 工具，查询内存使用情况。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/java内存dump文件分析01.png" alt="java内存dump文件分析01">
</div>
</div>
<div class="paragraph">
<p>从上图中可以看出 ThreadLocalMap 在哪个线程中，经过一系列的排查，导致内存缓慢升高的原因是：<strong>进程中的线程数量一直在增加</strong> ，由于线程是通过线程池创建的，模型实例的数量也很多，并发很高，所以线程基本是一直处于占用状态，然后随着线程数量的增加，内存占用就越来越高。</p>
</div>
<div class="paragraph">
<p>最终解决方案：根据我们的线程池配置，当线程池的核心数量使用完后，堆内存占用大概 3G，所以我们配置了堆内存大小 4G。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_记一次实战项目遇到的问题和解决方案智能决策平台">4.9. 记一次实战项目遇到的问题和解决方案（智能决策平台）</h3>
<div class="paragraph">
<p>智能决策平台实现的主要功能：获取到多个数据，然后将数据经由专业的业务规则和历史数据的数学模型，最终生成决策结果。</p>
</div>
<div class="paragraph">
<p>产生以下问题的大部分原因在于数据量太大，或者并发太高了。在只有一个租户的的情况下，气田生产业务域一天能产生 7G 的数据，石油工程一天能产生 12G 的数据。</p>
</div>
<div class="sect3">
<h4 id="_问题一">4.9.1. 问题一</h4>
<div class="sect4">
<h5 id="_1_问题描述_2">(1) 问题描述</h5>
<div class="listingblock">
<div class="content">
<pre>为了提高模型执行效率，项目中采用了多线程的的方式执行模型实例和查询每个实例的执行数据。采用多线程就会涉及到线程池的配置问题，线程池数量配置的过高或者过低，都会导致模型执行时间过长。</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_2_解决方案">(2) 解决方案</h5>
<div class="listingblock">
<div class="content">
<pre>该系统是一个IO密集型的，我们也做过相关调研，网上说的IO密集型的 线程数等于CPU核心数 * 2，CPU密集型的线程数等于CPU核心数 + 1；在这个系统中是不适用的，很是得根据实际情况来配置（还有就是我们的服务器配置很高的，有144核500G，也有192核1T）。
通过大量的测试，得出结论，规则执行的线程池线程数 ：查询执行数据的线程池线程数 = 1:5 （或1:4）为最优配置。</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_2_实际配置如下">(2) 实际配置如下</h5>
<div class="paragraph">
<p>实际配置可能没有按照 1:5 进行配置</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"># 线程池配置
thread-pool:
  async-task:
    # 执行模型规则的线程池
    rule-exec:
      core-pool-size: 1500
      max-pool-size: 3000
      keep-alive-time: 30
      queue-capacity: 20000
      thread-name-prefix: rule-executor-thread-
      # 拒绝策略：CallerRunsPolicy，AbortPolicy，DiscardPolicy，DiscardOldestPolicy
      rejected-policy: CallerRunsPolicy
    # 执行规则时，数据集查询数据的线程池
    dataset-exec:
      core-pool-size: 5000
      max-pool-size: 10000
      keep-alive-time: 30
      queue-capacity: 20000
      thread-name-prefix: dataset-executor-thread-
      # 拒绝策略：CallerRunsPolicy，AbortPolicy，DiscardPolicy，DiscardOldestPolicy
      rejected-policy: CallerRunsPolicy</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_问题二">4.9.2. 问题二</h4>
<div class="sect4">
<h5 id="_1_问题描述_3">(1) 问题描述</h5>
<div class="listingblock">
<div class="content">
<pre>系统采用Elasticsearch保存模型执行有大量的执行记录和告警记录，Es频繁报错，有大量的数据保存失败，造成数据丢失。（注：Es的配置是三主三从，八核20G内存，1T的存储）</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_2_原因">(2) 原因</h5>
<div class="listingblock">
<div class="content">
<pre>由于模型大部分是定时任务触发，任务触发后，采用多线程的方式保存执行记录，并且项目是多实例部署的，使得Es承载的并发太高，然后数据频繁失败。</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_3_解决方案">(3) 解决方案</h5>
<div class="listingblock">
<div class="content">
<pre>1. 添加了重试次数，模型实例数量增加到一定数量，还是会有很多数据保存失败。
2. 将执行记录放入到内存中，然后使用 CommandLineRunner 启动一个线程，一直去内存中取数据，然后批量保存到ES，降低ES的请求频率，从而降低压力。
3. 为了保证执行记录全部保存成功，采用优雅停机的方式，接收到 kill -2 的信号后，会等待一定的时间再停止服务。</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_问题三">4.9.3. 问题三</h4>
<div class="sect4">
<h5 id="_1_问题描述_4">(1) 问题描述</h5>
<div class="listingblock">
<div class="content">
<pre>模型在执行过程中，数据库查询缓慢，导致执行时间过长的问题。</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_2_原因_2">(2) 原因</h5>
<div class="listingblock">
<div class="content">
<pre>1. 数据库查询次数过多，数据库压力太大了（数据库已经是主从配置了）。
2. 系统配置的数据源连接数太少。
3. MySQL本身配置的最大连接数太少，当有多个服务的实例（Pod）连接数据库时，连接不够用。（主要是该数据库是采用容器部署的，为了能资源利用最大化，所以在部署MySQL服务器时，给数据库配置的有些资源都比较低）</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_3_解决方案_2">(3) 解决方案</h5>
<div class="listingblock">
<div class="content">
<pre>1. 能够使用Redis的地方尽量使用Redis。
2. 系统要配置合适的数据源连接配置。
3. 调整好数据库应该分配足够的资源和配置好MySQL本身的配置。</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_问题三_2">4.9.4. 问题三</h4>
<div class="sect4">
<h5 id="_1_问题描述_5">(1) 问题描述</h5>
<div class="listingblock">
<div class="content">
<pre>在模板中有大量的SQL查询数据集，导致模型执行时间过长；并且由于查询时间很长，会使得其一直占用的线程，导致其他模型的执行时间很长，告警消息滞后，不能准时告警。</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_2_原因_3">(2) 原因</h5>
<div class="listingblock">
<div class="content">
<pre>1. SQL请求频率高，数据库查询压力大。
2. SQL非常复杂，有的SQL不走索引；有的SQL中做了大量计算；有的SQL有大量的子查询；对同一张表多次扫描。</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_3_解决方案_3">(3) 解决方案</h5>
<div class="listingblock">
<div class="content">
<pre>1. 对部分数据做缓存，筛选出可以做缓存的数据集（该数据集的SQL简单，查询的表数据更新不频繁），通过canal配置监控表，如果发生变化，更新对应数据就可以了。
2. 将执行缓慢的模型筛选出来，单独部署一套执行这些模型的环境，增加机器资源，避免这些执行缓慢的模型影响到执行很快的模型。
3. 将变化频繁的数据，（比如实时录井数据）存入缓存，然后在提供查询缓存的API接口，以API接口查询缓存，减少对数据库的查询次数。</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_threadlocal_作用线程本地存储">4.10. ThreadLocal 作用(线程本地存储)</h3>
<div class="paragraph">
<p>最常见的 ThreadLocal 使用场景为：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>用来解决 数据库连接、Session 管理等。</p>
</li>
<li>
<p>记录当前登录用户信息。</p>
</li>
<li>
<p>还可以保存针对某个线程的所有输出日志，然后统一保存日志，比如说定时任务日志。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>ThreadLocal，很多地方叫做 <strong>线程本地变量</strong>，也有些地方叫做线程本地存储，ThreadLocal 的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。</p>
</div>
<div class="sect3">
<h4 id="_threadlocal结构">4.10.1. ThreadLocal结构</h4>
<div class="paragraph">
<p>在 ThreadLocal 中，有一个内部类 <strong>ThreadLocalMap</strong>。ThreadLocalMap 中定义了一个 <strong>Entry 数组</strong>。</p>
</div>
<div class="paragraph">
<p><strong>Thread</strong> 类有一个类型为 <strong>ThreadLocal.ThreadLocalMap</strong> 的实例变量 <strong>threadLocals</strong>，也就是说每个线程有一个自己的 <strong>ThreadLocalMap</strong>。</p>
</div>
<div class="paragraph">
<p><strong>ThreadLocalMap</strong> 有自己的独立实现，可以简单地将它的 <strong>key</strong> 视作 <strong>ThreadLocal</strong>，<strong>value</strong> 为代码中放入的值（实际上 <strong>key</strong> 并不是 <strong>ThreadLocal</strong> 本身，而是它的一个 <strong>弱引用</strong>）。</p>
</div>
<div class="paragraph">
<p>每个线程在往 <strong>ThreadLocal</strong> 里放值的时候，都会先获取当前线程的 <strong>ThreadLocalMap</strong>，然后往自己的 <strong>ThreadLocalMap</strong> 里存，读也是以 <strong>ThreadLocal</strong> 作为引用，在自己的 <strong>map</strong> 里找对应的 <strong>key</strong>，从而实现了 <strong>线程隔离</strong>。</p>
</div>
<div class="paragraph">
<p>我们还要注意 <strong>Entry</strong>， 它的 <strong>key</strong> 是 <strong>ThreadLocal&lt;?&gt; k</strong> ，继承自 <strong>WeakReference</strong>， 也就是我们常说的 <strong>弱引用类型</strong>。</p>
</div>
<div class="paragraph">
<p>threadLocalMap的结构图如下：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/threadLocalMap结构.awebp" alt="threadLocalMap结构">
</div>
</div>
</div>
<div class="sect3">
<h4 id="_threadlocal内存泄漏问题">4.10.2. ThreadLocal内存泄漏问题</h4>
<div class="ulist">
<ul>
<li>
<p>为什么ThreadLocalMap中的Entry要继承WeakReference，使ThreadLocal作为一个弱引用呢？</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>&emsp;&emsp;我们知道，弱引用在发生GC时这个对象一定会被回收。通常来说使用弱引用是为了避免内存泄漏。这里也不例外，ThreadLocal使用弱引用可以避免内存泄漏问题的发生。</p>
</div>
<div class="paragraph">
<p>&emsp;&emsp;试想，如果将ThreadLocal声明为强引用，一旦ThreadLocal不再使用，就需要被回收。但是此时由于ThreadLocalMap中的Entry数组持有了ThreadLocal。导致ThreadLocal不能够被回收而出现内存泄漏。那么，如果将ThreadLocal声明为弱引用就可以避免这一问题的出现。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>为什么需要及时的调用 ThreadLocal.remove() 方法呢？</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="images/threadLocal的引用链.awebp" alt="threadLocal的引用链">
</div>
</div>
<div class="paragraph">
<p>&emsp;&emsp;如上图所示，在ThreadLocal中存在一个这样的引用连。如果Thread一直在运行，那么此时由于强引用的value不能被回收，故此种情况下也可能出现内存泄漏的问题。</p>
</div>
</div>
<div class="sect3">
<h4 id="_threadlocal父子线程数据传递方案">4.10.3. ThreadLocal父子线程数据传递方案</h4>
<div class="sect4">
<h5 id="_子线程能否直接拿到父线程threadlocal中的值">子线程能否直接拿到父线程ThreadLocal中的值？</h5>
<div class="paragraph">
<p><strong>答案：不能</strong></p>
</div>
<div class="paragraph">
<p>由于ThreadLocal的实现机制，在子线程中调用get时，我们拿到的Thread对象是当前子线程对象，所以在调用 get 方法时，得到的是 null。</p>
</div>
</div>
<div class="sect4">
<h5 id="_inheritablethreadlocal">InheritableThreadLocal</h5>
<div class="paragraph">
<p>既然我们在子线程中不能通过 <strong>ThreadLocal</strong> 的 <strong>get()</strong> 直接获取到父线程中的值，那么有什么办法去解决这样的问题呢，毕竟有时候我们又有这样的需求。答案就是使用 <strong>InheritableThreadLocal</strong>。</p>
</div>
<div class="paragraph">
<p>先说一下 <strong>InheritableThreadLocal</strong> 的原理：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>InheritableThreadLocal</strong> 是 <strong>ThreadLocal</strong> 的子类，在创建 <strong>InheritableThreadLocal</strong> 对象的时候，会将  <strong>ThreadLocalMap</strong> 赋值给 <strong>Thread</strong> 中的 <strong>inheritableThreadLocals</strong> 属性；</p>
</li>
<li>
<p>在创建新线程的时候会检查父线程中 <strong>inheritableThreadLocals</strong> 变量是否为 <strong>null</strong>，如果不为 <strong>null</strong> 则 <strong>copy</strong> 一份 <strong>ThradLocalMap</strong> 到子线程的 <strong>inheritableThreadLocals</strong> 成员变量中去（Thread中的init方法）。</p>
</li>
<li>
<p>因为覆写了 <strong>getMap(Thread)</strong> 和 <strong>CreateMap()</strong> 方法，所以 <strong>get</strong> 的时候，就可以在 <strong>getMap(t)</strong> 的时候就会从 <strong>inheritableThreadLocals</strong> 中拿到 <strong>map</strong> 对象（可以看下面的源码），从而实现了可以拿到父线程 <strong>ThreadLocal</strong> 中的值。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>InheritableThreadLocal的源码：</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class InheritableThreadLocal&lt;T&gt; extends ThreadLocal&lt;T&gt; {
    /**
     * Computes the child's initial value for this inheritable thread-local
     * variable as a function of the parent's value at the time the child
     * thread is created.  This method is called from within the parent
     * thread before the child is started.
     * &lt;p&gt;
     * This method merely returns its input argument, and should be overridden
     * if a different behavior is desired.
     *
     * @param parentValue the parent thread's value
     * @return the child thread's initial value
     */
    protected T childValue(T parentValue) {
        return parentValue;
    }

    /**
     * Get the map associated with a ThreadLocal.
     *
     * @param t the current thread
     */
    ThreadLocalMap getMap(Thread t) {
       return t.inheritableThreadLocals;
    }

    /**
     * Create the map associated with a ThreadLocal.
     *
     * @param t the current thread
     * @param firstValue value for the initial entry of the table.
     */
    void createMap(Thread t, T firstValue) {
        t.inheritableThreadLocals = new ThreadLocalMap(this, firstValue);
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_inheritablethreadlocal和线程池之间的问题">4.10.4. InheritableThreadLocal和线程池之间的问题</h4>

</div>
</div>
<div class="sect2">
<h3 id="_多线程框架">4.11. 多线程框架</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>ThreadPoolExecutor</p>
</li>
<li>
<p>Disruptor</p>
</li>
<li>
<p>gitee-京东零售</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_Spring_chapter">5. Spring</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring 是一种轻量级开发框架，旨在提高开发人员的开发效率以及系统的可维护性。</p>
</div>
<div class="sect2">
<h3 id="_spring_ioc">5.1. Spring IOC</h3>
<div class="sect3">
<h4 id="_什么是ioc">5.1.1. 什么是IOC？</h4>
<div class="paragraph">
<p>IoC（Inverse of Control:控制反转）是一种 <strong>设计思想</strong>，就是 <strong>将原本在程序中手动创建对象的控制权，交由Spring框架来管理</strong>。IoC 在其他语言中也有应用，并非 Spring 特有。 <strong>IoC 容器是 Spring 用来实现 IoC 的载体</strong>， <strong>IoC 容器实际上就是个Map（key，value），Map 中存放的是各种对象</strong>。</p>
</div>
<div class="paragraph">
<p>在不使用Spring IOC的情况下，如果我们依赖于某个类或服务，我们通常会使用 <strong>new</strong> 关键字直接创建对象。如下例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class DoServiceImpl{
    private IUserService userService;
    private IRoleService roleService;

    public DoServiceImpl(){
        // new 方式创建对象
        userService = new UserServiceImpl();
        roleService = new RoleServiceImpl();
    }

    public void method1(){
        // do something
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>采用以上方式，每次我们需要什么依赖对象都需要自己去手动创建，非常的不方便。在使用Sping IOC后，当我们需要某个依赖的时候，由IOC容器自动给我们送过来，这就很舒服。IOC的理念就是让别人为你服务。</p>
</div>
<div class="paragraph">
<p><strong>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入</strong>。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 <strong>IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件或注解即可，完全不用考虑对象是如何被创建出来的</strong>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_spring依赖注入的三种方式">5.1.2. Spring依赖注入的三种方式</h4>
<div class="paragraph">
<p>在Spring中，提供了三种依赖注入的方式：<strong>构造方法注入</strong>，<strong>setter方法注入</strong>，<strong>接口注入</strong>。</p>
</div>
<div class="sect4">
<h5 id="_构造方法注入">构造方法注入</h5>
<div class="paragraph">
<p>IoC Service Provider会检查 <strong>被注入对象的构造方法</strong>，取得它所 <strong>需要的依赖对象列表</strong>，进而为其注入相应的对象。同一个对象是不可能被构造两次的，因此，被注入对象的构造乃至其整个生命周期，应该是由IoC Service Provider来管理的。</p>
</div>
<div class="paragraph">
<p><strong>构造方法注入方式比较直观，对象被构造完成后，即进入就绪状态，可以马上使用</strong>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class DoServiceImpl{
    private IUserService userService;
    private IRoleService roleService;

    // ioc 会检查构造器需要的依赖对象，然后注入
    public DoServiceImpl(UserServiceImpl userServiceImpl, RoleServiceImpl roleServiceImpl){
        userService = userServiceImpl;
        roleService = roleServiceImpl;
    }

    public void method1(){
        // do something
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_setter方法注入">setter方法注入</h5>
<div class="paragraph">
<p>在java中，通常是通过每个属性的setter和getter方法设置和访问对应属性的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class DoServiceImpl{
    private IUserService userService;

    public void setUserService(IUserService userService){
        this.userService = userService;
    }

    public IUserService getUserService(){
        return this.userService;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>看上边的代码，这样，外界就可以通过 <strong>setUserService(IUserService userService)</strong> 方法为 <strong>DoServiceImpl</strong> 注入所需要的依赖对象了。</p>
</div>
</div>
<div class="sect4">
<h5 id="_接口注入">接口注入</h5>
<div class="paragraph">
<p>接口注入的实现比较复杂，被注入对象如果想要IoC Service Provider为其注入依赖对象，就 <strong>必须实现某个接口</strong>。<strong>这个接口提供一个方法，用来为其注入依赖对象</strong>。<strong>IoC Service Provider最终通过这些接口来了解应该为被注入对象注入什么依赖对象</strong>。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spring_ioc接口注入图.png" alt="spring ioc接口注入图">
</div>
</div>
<div class="paragraph">
<p>DoServiceImpl为了让IOC容器为其注入所依赖的对象IUserService首先需要实现IDoService接口，这个接口会声明一个injectUserService的一个方法（方法名随意），该方法的参数就是所依赖的对象，这样IOC容器就可以通过这个接口方法将依赖对象注入到DoServiceImpl中。</p>
</div>
</div>
<div class="sect4">
<h5 id="_三种注入方式比较">三种注入方式比较</h5>
<div class="paragraph">
<p><strong>构造方法注入</strong>：这种方式注入优点就是，对象在构造方法完成之后，就进入了就绪状态，可以马上使用。但是无法设置默认值。</p>
</div>
<div class="paragraph">
<p><strong>setter方法注入</strong>：允许设置默认值，setter方法注入不像构造方法那样，让对象构造完成后就可以马上使用，但是相对来说宽松一些，可以在 <strong>对象构造完成后再注入</strong>。</p>
</div>
<div class="paragraph">
<p><strong>接口注入</strong>：因为这种方式必须要求实现一个接口，代码带有侵入性，所以现在不提倡使用这种方式。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_spring_ioc容器简述">5.1.3. Spring IOC容器简述</h4>
<div class="paragraph">
<p>Spring的IoC容器是一个IoC Service Provider（直译：IOC服务提供者），Spring提供了两种容器类型：<strong>BeanFactory</strong> 和 <strong>ApplicationContext</strong>。</p>
</div>
<div class="paragraph">
<p><strong>BeanFactory</strong>：基础类型IoC容器，提供完整的IoC服务支持。如果没有特殊指定，默认采用 <strong>延迟初始化策略（lazy-load）</strong>。<strong>只有当客户端对象需要访问容器中的某个受管对象的时候，才对该受管对象进行初始化以及依赖注入操作</strong>。所以，相对来说，<strong>容器启动初期速度较快</strong>，所需要的资源有限。对于资源有限，并且功能要求不是很严格的场景，BeanFactory是比较合适的IoC容器选择。</p>
</div>
<div class="paragraph">
<p><strong>ApplicationContext</strong>：<strong>ApplicationContext在BeanFactory的基础上构建</strong>，是相对比较高级的容器实现，除了 <strong>拥有BeanFactory的所有支持</strong>，ApplicationContext还提供了其他高级特性，比如事件发布、国际化信息支持等，这些会在后面详述。<strong>ApplicationContext所管理的对象，在该类型容器启动之后，默认全部初始化并绑定完成</strong>。所以，相对于BeanFactory来说，ApplicationContext要求更多的系统资源，同时，<strong>因为在启动时就完成所有初始化，容器启动时间较之BeanFactory也会长一些</strong>。在那些系统资源充足，并且要求更多功能的场景中，ApplicationContext类型的容器是比较合适的选择。</p>
</div>
<div class="paragraph">
<p>通过下图，我们可以对BeanFactory和ApplicationContext之间的关系有一个更清晰的认识。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spring_beanfactory_applicationContext关系图.png" alt="spring beanfactory applicationContext关系图">
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>ApplicationContext间接继承自BeanFactory，所以说它是构建于BeanFactory之上的IoC容器。</p>
</div>
</blockquote>
</div>
</blockquote>
</div>
</div>
<div class="sect3">
<h4 id="BeanFactory">5.1.4. BeanFactory</h4>
<div class="paragraph">
<p>BeanFactory，顾名思义，就是生产Bean的工厂。作为Spring提供的基本的IoC容器，BeanFactory可以完成作为IoC Service Provider的所有职责，包括 <strong>业务对象的注册</strong> 和 <strong>对象间依赖关系的绑定</strong>。</p>
</div>
<div class="sect4">
<h5 id="_beanfactory的对象注册与依赖绑定方式">BeanFactory的对象注册与依赖绑定方式</h5>
<div class="sect5">
<h6 id="_直接编码方式">直接编码方式</h6>
<div class="quoteblock">
<blockquote>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>其实，把编码方式单独提出来称作一种方式并不十分恰当。因为不管什么方式，最终都需要编码才能“落实”所有信息并付诸使用。不过，通过这些代码，起码可以让我们更加清楚BeanFactory在底层是如何运作的。</p>
</div>
</blockquote>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>想要了解其中的原理，我们先通过一些代码进行分析，这样更容易理解。下面是直接编码方式的代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public static void main(String[] args){
    DefaultListableBeanFactory beanRegistry = new DefaultListableBeanFactory();
    BeanFactory container = (BeanFactory)bindViaCode(beanRegistry);
    FXNewsProvider newsProvider = (FXNewsProvider)container.getBean("djNewsProvider");
    newsProvider.getAndPersistNews();
}

public static BeanFactory bindViaCode(BeanDefinitionRegistry registry)
{
    // 将需要的类信息映射到BeanDefinition中
    AbstractBeanDefinition newsProvider = new RootBeanDefinition(FXNewsProvider.class,true);
    AbstractBeanDefinition newsListener = new RootBeanDefinition(DowJonesNewsListener.class,true);
    AbstractBeanDefinition newsPersister = new RootBeanDefinition(DowJonesNewsPersister.class,true);
    // 将bean定义注册到容器中
    registry.registerBeanDefinition("djNewsProvider", newsProvider);
    registry.registerBeanDefinition("djListener", newsListener);
    registry.registerBeanDefinition("djPersister", newsPersister);
    // 指定依赖关系
    // 1. 可以通过构造方法注入方式
    ConstructorArgumentValues argValues = new ConstructorArgumentValues();
    argValues.addIndexedArgumentValue(0, newsListener);
    argValues.addIndexedArgumentValue(1, newsPersister);
    newsProvider.setConstructorArgumentValues(argValues);
    // 2. 或者通过setter方法注入方式
    // MutablePropertyValues propertyValues = new MutablePropertyValues();
    // propertyValues.addPropertyValue(new ropertyValue("newsListener",newsListener));
    // propertyValues.addPropertyValue(new PropertyValue("newPersistener",newsPersister));
    // newsProvider.setPropertyValues(propertyValues);

    // 绑定完成
    return (BeanFactory)registry;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>从上面的代码中分析，首先创建一个 DefaultListableBeanFactory 对象，然后通过 bindViaCode 方法返回一个 BeanFactory 对象，在 bindViaCode 方法中，首先将需要的类信息映射到 BeanDefinition 中，然后将 Bean 的定义注册到容器中，再指定相应的依赖关系，最后返回 BeanFactory 对象，这就是直接编码的方式，当然，我们在代码中肯定不会这样做。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>小心 最后一行的强制类型转换是有特定场景的。因为传入的DefaultListableBeanFactory同时实现了BeanFactory和BeanDefinitionRegistry接口，所以，这样做强制类型转换不会出现问题。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>BeanFactory只是一个接口</strong>，我们最终需要一个 <strong>该接口的实现</strong> 来进行实际的Bean的管理，<strong>DefaultListableBeanFactory</strong> 就是这么一个比较通用的 BeanFactory实现类 。<strong>DefaultListableBeanFactory</strong> 除了间接地实现了 <strong>BeanFactory</strong> 接口，还实现了 <strong>BeanDefinitionRegistry</strong> 接口，<strong>该接口才是在BeanFactory的实现中担当Bean注册管理的角色</strong>。基本上，BeanFactory接口只定义如何访问容器内管理的Bean的方法，<strong>各个 BeanFactory 的具体实现类负责具体Bean的注册以及管理工作</strong>。<strong>BeanDefinitionRegistry接口定义抽象了Bean的注册逻辑</strong>。通常情况下，<strong>具体的BeanFactory实现类会实现这个接口来管理Bean的注册</strong>。下图是它们之间的关系：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/beanfactory实现类关系图.png" alt="beanfactory实现类关系图">
</div>
</div>
<div class="paragraph">
<p>每一个受管的对象，在容器中都会有一个 <strong>BeanDefinition的实例</strong> 与之相对应，该BeanDefinition的实例 <strong>负责保存对象的所有必要信息</strong>，包括其对应的对象的class类型、是否是抽象类、构造方法参数以及其他属性等。<strong>当客户端向BeanFactory请求相应对象的时候，BeanFactory会通过这些信息为客户端返回一个完备可用的对象实例</strong>。</p>
</div>
</div>
<div class="sect5">
<h6 id="_外部配置文件方式重要">外部配置文件方式（重要）</h6>
<div class="paragraph">
<p><strong>Spring的IoC容器支持两种配置文件格式：Properties文件格式和XML文件格式。</strong></p>
</div>
<div class="quoteblock">
<blockquote>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>下面这段话，是Spring的核心点，很重要，也可以称之为Spring加载Bean的过程</p>
</div>
</blockquote>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>采用外部配置文件时，Spring的IoC容器有一个统一的处理方式。通常情况下，需要根据不同的外部配置文件格式，给出相应的 <strong>BeanDefinitionReader实现类</strong>，由 <strong>BeanDefinitionReader的相应实现类</strong> 负责将相应的配置文件内容读取并映射到 <strong>BeanDefinition</strong>，然后将映射后的 <strong>BeanDefinition</strong> 注册到一个 <strong>BeanDefinitionRegistry</strong> 中，这样，BeanDefinitionRegistry就完成了Bean的注册和加载，这时，整个BeanFactory就可以放给客户端使用了。当然，大部分工作，包括解析文件格式、装配BeanDefinition之类的工作，都是由 <strong>BeanDefinitionReader的相应实现类</strong> 来做的， <strong>BeanDefinitionRegistry只不过负责保管而已</strong>。</p>
</div>
</div>
<div class="sect5">
<h6 id="_注解方式">注解方式</h6>
<div class="paragraph">
<p>通过 <strong>@Component</strong> 或者 <strong>@Bean</strong> 实现Bean的注册和绑定。</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_applicationcontext">5.1.5. ApplicationContext</h4>
<div class="paragraph">
<p>作为Spring提供的较之 BeanFactory更为先进的IoC容器实现， ApplicationContext除了拥有BeanFactory支持的所有功能之外，还进一步扩展了基本容器的功能，包括 BeanFactoryPostProcessor、BeanPostProcessor （这两个接口在 <a href="#容器背后的秘密">容器背后的秘密</a> 会进行详细讲解）以及其他特殊类型bean的自动识别、容器启动后bean实例的自动初始化、国际化的信息支持、容器内事件发布等。</p>
</div>
<div class="paragraph">
<p>下面呢，主要针对ApplicationContext提供的国际化信息支持，统一资源加载策略以及容器内事件发布进行探讨。</p>
</div>
<div class="sect4">
<h5 id="_统一资源加载策略">统一资源加载策略</h5>
<div class="paragraph">
<p>核心接口：ResourceLoader接口</p>
</div>
<div class="paragraph">
<p>可以通过ResourceLoader 返回Resource 对象得到我们需要的文件，ResourceLoader接口定义如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface ResourceLoader {

	/** 从class path 路径加载时的伪资源URL: "classpath:" 。不陌生，web.xml配置中指定类路径下资源时便要加此前缀*/
	String CLASSPATH_URL_PREFIX = ResourceUtils.CLASSPATH_URL_PREFIX;

	/**返回指定path的资源*/
	Resource getResource(String location);

	/**需要直接访问ClassLoader的客户端可以这样做,即以与ResourceLoader统一的方式，而不是依赖线程上下文ClassLoader*/
	ClassLoader getClassLoader();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面是 ApplicationContext 的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    ApplicationContext context = new FileSystemXmlApplicationContext("/home/wjc/demo/src/Beans.xml");
    HelloWorld obj = (HelloWorld) context.getBean("helloWorld");
    obj.getMessage();</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_事件发布">事件发布</h5>
<div class="paragraph">
<p>核心接口：ApplicationEvent类、ApplicationListener接口、ApplicationContextAware接口</p>
</div>
<div class="paragraph">
<p>下面是一个事件推送的示例：</p>
</div>
<div class="listingblock">
<div class="title"><strong>1. 定义一个事件类，继承 ApplicationEvent 类</strong></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class SayHello enxtends ApplicationEvent{
	public SayHello(){super();}
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><strong>2. 写一个ApplicationEvent 事件监听类，实现 ApplicationListener 接口</strong></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class SayListener implement ApplicationListener{
	public void onApplicationEvent(ApplicationEvent ev){
		if(ev instanceof SayHello){
			System.out.println("收到SayHello事件");
		}
	}
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><strong>3. 写一个事件发布管理类，实现 ApplicationContextAware 接口</strong></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class ManagerEvent implements ApplicationContextAware{
	private ApplicationContext appCtx = null;
	@Override
	public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
		appCtx = applicationContext;
	}

	public void publish(ApplicationEvent event){
		if(event != null){
            appCtx.publisherEvent(event);
        }
	}
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><strong>4. 配置 Spring 容器中的bean，可通过 XML 配置</strong></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;beans&gt;
	&lt;bean id="hellowEvent" class="**.SayHello"/&gt;
	&lt;bean id="manageEvent" class="**.ManageEvent"/&gt;
	&lt;bean id="listerner" class="**.SayListener"/&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><strong>5. 测试：主函数部分代码</strong></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public static void main(String[] args){
	ApplicationContext appCtx = new FileSystemApplicationContext("XML 文件路径");
	SayHello event = appCtx.getBean("hellowEvent");
	ManageEvent manage = appCtx.getBean("manageEvent");
    //发布事件
	manage.publish(event);
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_国际化信息支持">国际化信息支持</h5>
<div class="paragraph">
<p>核心接口：MessageResource接口</p>
</div>
<div class="paragraph">
<p>Spring的国际化支持，其实是建立在Java程序国际化的基础之上。其核心思路都是将程序需要实现国际化的信息写入资源文件，而代码中仅仅使用相应的个信息的Key。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_spring_bean">5.2. Spring Bean</h3>
<div class="sect3">
<h4 id="_bean的作用域scope">5.2.1. Bean的作用域(scope)</h4>
<div class="paragraph">
<p><strong>singleton</strong>：该作用域的Bean，在Spring IOC容器中只有一个实例，将一直存活到容器退出，寿命和IOC容器一样长。</p>
</div>
<div class="paragraph">
<p><strong>prototype</strong>：该作用域的Bean，每当 <strong>容器</strong> 在接到 <strong>该类型对象的请求</strong> 的时候，会每次都重新生成一个新的对象实例给请求方。</p>
</div>
<div class="paragraph">
<p><strong>request</strong>：该作用域的Bean，每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。</p>
</div>
<div class="paragraph">
<p><strong>session</strong>：该作用域的Bean，Spring容器会为每个独立的session创建属于它们自己的全新的对象实例。与request相比，除了拥有session scope的bean的实例具有比request scope的bean可能更长的存活时间，其他方面真是没什么差别。</p>
</div>
<div class="paragraph">
<p><strong>global-session</strong>：全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。</p>
</div>
</div>
<div class="sect3">
<h4 id="_spring中的单例bean是线程安全的吗">5.2.2. Spring中的单例Bean是线程安全的吗？</h4>
<div class="paragraph">
<div class="title"><strong>1. 介绍两个概念</strong></div>
<p><strong>有状态的 Bean</strong>：对象中有实例变量（成员变量），可以保存数据，是非线程安全的。</p>
</div>
<div class="paragraph">
<p><strong>无状态的 Bean</strong>：对象中没有实例变量（成员变量），不能保存数据，可以在多线程环境下共享，是线程安全的。</p>
</div>
<div class="paragraph">
<div class="title"><strong>2. Spring中的单例Bean是线程安全问题</strong></div>
<p>我们都知道 Spring 中的 Bean 默认都是单例的，IOC 容器中一个类只会存在一个实例对象。这种设计是怎么保证线程安全的？</p>
</div>
<div class="paragraph">
<p>一般不会出现线程安全问题。在 Spring 中，绝大部分 Bean 都是无状态的，因此即使这些 Bean 默认是单例的，也不会出现线程安全问题的。比如 <strong>Controller</strong>、<strong>Service</strong>、<strong>Dao</strong> 这些类，这些类里面通常 <strong>不会含有成员变量</strong>，因此它们被设计成 <strong>单例</strong> 的。<strong>如果这些类中定义了实例变量，就线程不安全了，所以尽量避免定义实例变量</strong>。</p>
</div>
<div class="olist arabic">
<div class="title"><strong>3. 解决Spring单例Bean线程安全问题办法</strong></div>
<ol class="arabic">
<li>
<p>对于 <strong>有状态的 Bean</strong>，Spring 采用 ThreadLocal 进行处理，使它们成为线程安全可以共享的对象。</p>
</li>
<li>
<p>对于 <strong>有状态的 bean</strong>，也可以使用原型模式（prototype），每次使用时都会重新生成一个对象，解决了线程不安全的问题。</p>
</li>
</ol>
</div>
<div class="quoteblock">
<blockquote>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>ps：无状态的 Bean 适合使用不变模式，即单例模式，这样可以共享实例，提高性能。有状态的 Bean，多线程环境下不安全，适合使用 Prototype 原型模式。Prototype: 每次对 Bean 的请求都会创建一个新的 bean 实例。</p>
</div>
</blockquote>
</div>
</blockquote>
</div>
</div>
<div class="sect3">
<h4 id="_beanfactory和factorybean的却别">5.2.3. BeanFactory和FactoryBean的却别</h4>
<div class="paragraph">
<p><strong>BeanFactory是个Factory</strong>，也就是IOC容器或对象工厂，FactoryBean是个Bean。在Spring中，所有的Bean都是由BeanFactory(也就是IOC容器)来进行管理的。<strong>FactoryBean是个Bean</strong>，这个Bean不是简单的Bean，而是一个 <strong>能生产或者修饰对象生成的工厂Bean</strong>。</p>
</div>
<div class="sect4">
<h5 id="_factorybean">FactoryBean</h5>
<div class="paragraph">
<p>当某些对象的实例化过程过于烦琐，通过XML配置过于复杂，使我们宁愿使用Java代码来完成这个实例化过程的时候，或者，某些第三方库不能直接注册到Spring容器的时候，就可以实现 <strong>org.springframework.beans.factory.FactoryBean</strong> 接口，给出自己的对象实例化逻辑代码。</p>
</div>
<div class="paragraph">
<p>下面是 FactoryBean 接口源码，其中定义了三个方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface FactoryBean {
    Object getObject() throws Exception;
    Class getObjectType();
    boolean isSingleton();
}</code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>getObject()</strong> 方法会返回该FactoryBean“生产”的对象实例，我们需要实现该方法以给出自己的对象实例化逻辑。<br></p>
</li>
<li>
<p><strong>getObjectType()</strong> 方法仅返回getObject()方法所返回的对象的类型，如果预先无法确定，则返回null。<br></p>
</li>
<li>
<p><strong>isSingleton()</strong> 方法返回结果用于表明，工厂方法（getObject()）所“生产”的对象是否要以singleton形式存在于容器中。如果以singleton形式存在，则返回true，否则返回false。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>我们现在实现一个 FactoryBean ，比如，如果我们想每次得到的日期都是第二天（该例子来自于《Spring揭秘&#8212;&#8203;王福强》），代码如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.joda.time.DateTime;
import org.springframework.beans.factory.FactoryBean;

public class NextDayDateFactoryBean implements FactoryBean {
    public Object getObject() throws Exception {
        return new DateTime().plusDays(1);
    }
    public Class getObjectType() {
        return DateTime.class;
    }
    public boolean isSingleton() {
        return false;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>实现很简单，接下来要使用 NextDayDateFactoryBean ，下面是 XML 配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="nextDayDateDisplayer" class="...NextDayDateDisplayer"&gt;
    &lt;property name="dateOfNextDay"&gt;
        &lt;ref bean="nextDayDate"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="nextDayDate" class="...NextDayDateFactoryBean"&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>从上面的配置看不出和平常定义的Bean有什么不同，不要着急，下面再看一下NextDayDateDisplayer 的定义的时候，就可以看出 FactoryBean 的魔力在哪里。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class NextDayDateDisplayer{
    private DateTime dateOfNextDay;
    // 相应的setter方法
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>看到了嘛？ NextDayDateDisplayer所声明的依赖 dateOfNextDay 的类型为 DateTime，而不是NextDayDateFactoryBean。<strong>也就是说FactoryBean类型的bean定义，通过正常的id引用，容器返回的是FactoryBean所“生产”的对象类型，而非FactoryBean实现类本身</strong>。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="容器背后的秘密">5.3. 容器背后的秘密</h3>
<div class="paragraph">
<p>在没有特别说明的情况下，以下描述以 <strong>BeanFactory</strong> 进行的分析，<strong>ApplicationContext</strong> 有一些不一样。</p>
</div>
<div class="sect3">
<h4 id="_容器功能实现阶段">5.3.1. 容器功能实现阶段</h4>
<div class="paragraph">
<p>Spring的IOC容器会以某种方式加载Configuration Metadata（通常也就是XML格式的配置信息），然后根据这些信息绑定整个系统的对象，最终组装成一个可用的基于轻量级容器的应用系统。</p>
</div>
<div class="paragraph">
<p>Spring的IOC容器实现以上功能的过程，基本上可以按照类似的流程划分为两个阶段，即 <strong>容器启动阶段</strong> 和 <strong>Bean实例化阶段</strong>。如下图所示：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spring_ioc容器功能实现的各个阶段.png" alt="spring ioc容器功能实现的各个阶段">
</div>
</div>
<div class="paragraph">
<div class="title"><strong>1. 容器启动阶段</strong></div>
<p>容器启动伊始，首先会通过某种途径加载 <strong>Configuration MetaData</strong>。除了代码方式比较直接，在大部分情况下，容器需要依赖某些工具类（<strong>BeanDefinitionReader</strong>）对加载的Configuration MetaData进行解析和分析，<strong>并将分析后的信息映射为相应的BeanDefinition</strong>，最后把这些保存了bean定义必要信息的BeanDefinition，<strong>注册到相应的BeanDefinitionRegistry</strong>，这样容器启动工作就完成了。</p>
</div>
<div class="paragraph">
<div class="title"><strong>2. Bean实例化阶段</strong></div>
<p>经过第一阶段，现在 <strong>所有的bean定义信息都通过BeanDefinition的方式注册到了BeanDefinitionRegistry中</strong>。当某个请求方通过容器的 <strong>getBean</strong> 方法明确地请求某个对象，或者因依赖关系容器需要隐式地调用getBean方法时，就会触发第二阶段的活动。</p>
</div>
<div class="paragraph">
<p>该阶段，容器会 <strong>首先检查所请求的对象之前是否已经初始化</strong>。<strong>如果没有，则会根据注册的BeanDefinition所提供的信息实例化被请求对象，并为其注入依赖</strong>。如果该对象实现了某些回调接口，也会根据回调接口的要求来装配它。当该对象装配完毕之后，容器会立即将其返回请求方使用。如果说第一阶段只是根据图纸装配生产线的话，那么第二阶段就是使用装配好的生产线来生产具体的产品了。</p>
</div>
</div>
<div class="sect3">
<h4 id="_插手容器的启动">5.3.2. 插手“容器的启动”</h4>
<div class="paragraph">
<p>Spring提供了一种叫做 <strong>BeanFactoryPostProcessor</strong> 的容器扩展机制。<strong>该机制允许我们在容器实例化相应对象之前，对注册到容器的BeanDefinition所保存的信息做相应的修改</strong>。这就相当于在容器实现的 <strong>第一阶段最后加入一道工序</strong>，<strong>让我们对最终的BeanDefinition做一些额外的操作，比如修改其中bean定义的某些属性，为bean定义增加其他信息</strong> 等。</p>
</div>
<div class="paragraph">
<p>如果要自定义实现 <strong>BeanFactoryPostProcessor</strong>，通常我们需要实现 <strong>BeanFactoryPostProcessor接口</strong>。同时，因为一个 <strong>容器可能拥有多个BeanFactoryPostProcessor</strong>，这个时候可能需要实现类同时实现 <strong>Spring的Ordered接口</strong>，以 <strong>保证各个BeanFactoryPostProcessor可以按照预先设定的顺序执行</strong>（如果顺序紧要的话）。但是，因为Spring已经提供了几个现成的BeanFactoryPostProcessor实现类，所以，大多时候，我们很少自己去实现某个BeanFactoryPostProcessor。其中，<strong>PropertyPlaceholderConfigurer</strong> 和 <strong>PropertyOverrideConfigurer</strong> 是两个比较常用的BeanFactoryPostProcessor。另外，为了处理配置文件中的数据类型与真正的业务对象所定义的数据类型转换，Spring还允许我们通过 <strong>CustomEditorConfigurer</strong> 来注册自定义的PropertyEditor以补助容器中默认的PropertyEditor。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>上述讲到的interface对应的完整包路径如下：</p>
</div>
<div class="paragraph">
<p>BeanFactoryPostProcessor：org.springframework.beans.factory.config.BeanFactoryPostProcessor</p>
</div>
<div class="paragraph">
<p>Ordered：org.springframework.core.Ordered</p>
</div>
<div class="paragraph">
<p>PropertyPlaceholderConfigurer：org.springframework.beans.factory.config.PropertyPlaceholderConfigurer</p>
</div>
<div class="paragraph">
<p>PropertyOverrideConfigurer：org.springframework.beans.factory.config.PropertyOverrideConfigurer</p>
</div>
<div class="paragraph">
<p>CustomEditorConfigurer：org.springframework.beans.factory.config.CustomEditorConfigurer</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<div class="title"><strong>举个例子</strong></div>
<p>通常情况下，我们 <strong>不想将类似于系统管理相关的信息同业务对象相关的配置信息混杂到XML配置文件中</strong>，以免部署或者维护期间因为改动繁杂的XML配置文件而出现问题。我们会将一些数据库连接信息、邮件服务器等相关信息单独配置到一个 <strong>properties</strong> 文件中，这样，如果因系统资源变动的话，只需要关注这些简单properties配置文件即可。</p>
</div>
<div class="paragraph">
<p>PropertyPlaceholderConfigurer允许我们在XML配置文件中使用 <strong>占位符</strong>（PlaceHolder），并将这些占位符所代表的资源单独配置到简单的properties文件中来加载。以数据源的配置为例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
&lt;property name="url"&gt;
    &lt;value&gt;${jdbc.url}&lt;/value&gt;
&lt;/property&gt;
&lt;property name="driverClassName"&gt;
    &lt;value&gt;${jdbc.driver}&lt;/value&gt;
&lt;/property&gt;
&lt;property name="username"&gt;
    &lt;value&gt;${jdbc.username}&lt;/value&gt;
&lt;/property&gt;
&lt;property name="password"&gt;
    &lt;value&gt;${jdbc.password}&lt;/value&gt;
&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>jdbc.properties配置文件</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">jdbc.url=jdbc:mysql://server/MAIN?useUnicode=true&amp;characterEncoding=ms932&amp;failOverReadOnly=false&amp;roundRobinLoadBalance=true
jdbc.driver=com.mysql.jdbc.Driver
jdbc.username=your username
jdbc.password=your password</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_了解bean的一生">5.3.3. 了解Bean的一生</h4>
<div class="paragraph">
<p><strong>容器启动之后，并不会马上就实例化相应的bean定义</strong>。我们知道，容器现在仅仅拥有所有对象的BeanDefinition来保存实例化阶段将要用的必要信息。只有当请求方通过BeanFactory的getBean()方法来请求某个对象实例的时候，才有可能触发Bean实例化阶段的活动。BeanFactory的getBean方法可以被客户端对象 <strong>显式调用</strong>，也可以在容器内部隐式地被调用。<strong>隐式调用有如下两种情况</strong>。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>对于 <strong>BeanFactory</strong> 来说，对象实例化默认采用延迟初始化。通常情况下，当对象A被请求而需要第一次实例化的时候，如果它所依赖的对象B之前同样没有被实例化，那么容器会先实例化对象A所依赖的对象。这时容器内部就会首先实例化对象B，以及对象 A依赖的其他还没有被实例化的对象。这种情况是容器内部调用getBean()，对于本次请求的请求方是隐式的。</p>
</li>
<li>
<p><strong>ApplicationContext启动之后会实例化所有的bean定义</strong>，这个特性在本文档中已经多次提到。但ApplicationContext在实现的过程中依然遵循Spring容器实现流程的两个阶段，只不过它会 <strong>在启动阶段的活动完成之后，紧接着调用注册到该容器的所有bean定义的实例化方法getBean()</strong>。这就是为什么当你得到ApplicationContext类型的容器引用时，容器内所有对象已经被全部实例化完成 。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>之所以说getBean()方法是有可能触发Bean实例化阶段的活动，是因为 <strong>只有当对应某个bean定义的getBean()方法第一次被调用时，不管是显式的还是隐式的，Bean实例化阶段的活动才会被触发，第二次被调用则会直接返回容器缓存的第一次实例化完的对象实例（prototype类型bean除外）。当getBean()方法内部发现该bean定义之前还没有被实例化之后，会通过createBean()方法来进行具体的对象实例化</strong>。下面是Bean实例化的过程图：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/Bean的实例化过程.png" alt="Bean的实例化过程">
</div>
</div>
<div class="sect4">
<h5 id="_bean实例化的过程解析">Bean实例化的过程解析</h5>
<div class="paragraph">
<div class="title"><strong>1. Bean的实例化与BeanWrapper</strong></div>
<p>容器在内部实现的时候，采用“策略模式（Strategy Pattern）”来决定采用何种方式初始化bean实例。通常，可以通过反射或者CGLIB动态字节码生成来初始化相应的bean实例或者动态生成其子类。</p>
</div>
<div class="paragraph">
<p>容器只要根据相应bean定义的 <strong>BeanDefintion</strong> 取得实例化信息，然后实例化并返回实例化完成的对象实例。但是，返回方式上有些“点缀”。不是直接返回构造完成的对象实例，而是以BeanWrapper对构造完成的对象实例进行包裹，返回相应的BeanWrapper实例。</p>
</div>
<div class="paragraph">
<p>至此，第一步结束。</p>
</div>
<div class="paragraph">
<p>第二步就是设置属性值（成员变量的值），第一步返回的 <strong>BeanWrapper实例</strong> 就是这一步来设置属性值的。</p>
</div>
<div id="各色的Aware接口" class="paragraph">
<div class="title"><strong>2. 各色的Aware接口</strong></div>
<p>当对象实例化完成并且相关属性以及依赖设置完成之后，Spring容器会检查当前对象实例是否实现了一系列的以Aware命名结尾的接口定义。如果是，则 <strong>将这些Aware接口定义中规定的依赖注入给当前对象实例</strong>。</p>
</div>
<div class="paragraph">
<p>比如说：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>org.springframework.beans.factory.BeanNameAware</strong> 接口，如果Spring容器检测到当前对象实例实现了该接口，会将该对象实例的bean定义对应的beanName设置到当前对象实例。</p>
</li>
<li>
<p><strong>org.springframework.beans.factory.BeanFactoryAware</strong> 接口，如果对 象声明实现了BeanFactoryAware接口，BeanFactory容器会将自身设置到当前对象实例。这样，当前对象实例就拥有了一个BeanFactory容器的引用，并且可以对这个容器内允许访问的对象按照需要进行访问。</p>
</li>
</ol>
</div>
<div class="paragraph">
<div class="title"><strong>3. BeanPostProcessor</strong></div>
<p><strong>BeanPostProcessor</strong> 的概念容易与 <strong>BeanFactoryPostProcessor</strong> 的概念混淆。但只要记住 <strong>BeanPostProcessor</strong> 是存在于对象实例化阶段，而 <strong>BeanFactoryPostProcessor</strong> 则是存在于容器启动阶段，这两个概念就比较容易区分了。</p>
</div>
<div class="paragraph">
<p>BeanPostProcessor会处理容器内 <strong>所有符合条件的实例化后的对象实例</strong>。该接口声明了两个方法，分别在两个不同的时机执行，见如下代码定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface BeanPostProcessor{
    Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;

    Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>BeanPostProcessor的两个方法中都传入了原来的对象实例的引用，这为我们扩展容器的对象实例化过程中的行为提供了极大的便利，我们几乎可以对传入的对象实例执行任何的操作。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="literalblock">
<div class="content">
<pre>怎么判断实例化后的对象是否符合 BeanPostProcessor 的处理条件？</pre>
</div>
</div>
<div class="paragraph">
<p><strong>就是在这两个方法里面做判断，符合条件就执行</strong>。下面是一个自定义的 <strong>BeanPostProcessor</strong>，在执行 <strong>postProcessBeforeInitialization</strong> 方法的时候，判断这个Bean是否是 PasswordDecodable ，如果是，就执行里面的操作。这只是一个例子，不一定是判断是否属于某个类，就看用户想做什么样的事情，看如下代码就比较容易理解了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class PasswordDecodePostProcessor implements BeanPostProcessor {
    public Object postProcessAfterInitialization(Object object, String beanName) throws BeansException {
        return object;
    }
    public Object postProcessBeforeInitialization(Object object, String beanName) throws BeansException {
        // 判断这个Bean是否满足某个条件，如果满足就会执行相应的操作
        if(object instanceof PasswordDecodable){
            String encodedPassword = ((PasswordDecodable)object).getEncodedPassword();
            String decodedPassword = decodePassword(encodedPassword);
            ((PasswordDecodable)object).setDecodedPassword(decodedPassword);
        }
        return object;
    }

    private String decodePassword(String encodedPassword) {
        // 实现解码逻辑
        return encodedPassword;
    }
}</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<div class="title"><strong>4. InitializingBean和init-method</strong></div>
<p>org.springframework.beans.factory.InitializingBean是容器内部广泛使用的一个对象生命周期标识接口，其定义如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface InitializingBean {
    void afterPropertiesSet() throws Exception;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该接口定义很简单，其作用在于，在对象实例化过程调用过“BeanPostProcessor的前置处理”之后，会接着检测当前对象是否实现了InitializingBean接口，如果是，则会调用其afterPropertiesSet()方法进一步调整对象实例的状态。比如，在有些情况下，某个业务对象实例化完成后，还不能处于可以使用状态。这个时候就可以让该业务对象实现该接口，并在方法afterPropertiesSet()中完成对该业务对象的后续处理。</p>
</div>
<div class="paragraph">
<p>虽然该接口在Spring容器内部广泛使用，但如果真的让我们的业务对象实现这个接口，则显得Spring容器比较具有侵入性。所以，Spring还提供了另一种方式来指定自定义的对象初始化操作，那就是在XML配置的时候，使用&lt;bean&gt;的init-method属性。</p>
</div>
<div class="paragraph">
<p>通过init-method，系统中业务对象的自定义初始化操作可以以任何方式命名，而不再受制于InitializingBean的afterPropertiesSet()。如果配置了自定义的init-method方法，那么就会在“BeanPostProcessor的后置处理”之前执行指定的init-method方法。</p>
</div>
<div class="paragraph">
<div class="title"><strong>5. DisposableBean与destroy-method</strong></div>
<p>当所有的一切，该设置的设置，该注入的注入，该调用的调用完成之后，容器将检查singleton类型的bean实例，看其是否实现了org.springframework.beans.factory.DisposableBean接口。或者其对应的bean定义是否通过&lt;bean&gt;的destroy-method属性指定了自定义的对象销毁方法。如果是，就会为该实例注册一个用于对象销毁的回调（Callback），以便在这些singleton类型的对象实例销毁之前，执行销毁逻辑。</p>
</div>
<div class="paragraph">
<p>不过，这些自定义的对象销毁逻辑，在对象实例初始化完成并注册了相关的回调方法之后，并不会马上执行。回调方法注册后，返回的对象实例即处于使用状态，只有该对象实例不再被使用的时候，才会执行相关的自定义销毁逻辑，此时通常也就是Spring容器关闭的时候。但Spring容器在关闭之前，不会聪明到自动调用这些回调方法。所以，需要我们告知容器，在哪个时间点来执行对象的自定义销毁方法。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="literalblock">
<div class="content">
<pre>总结Spring Bean的生命周期</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>根据 <strong>BeanDefintion</strong> 中的信息，创建一个Bean的实例。</p>
</li>
<li>
<p>如果存在一些属性值，设置属性值。</p>
</li>
<li>
<p>检查是否实现了一些 <strong>Aware</strong> 接口，如果是，则将这些Aware接口定义中规定的依赖注入给当前对象实例。</p>
</li>
<li>
<p>执行 <strong>BeanPostProcessor</strong> 中的 <strong>postProcessBeforeInitialization()</strong> 方法，BeanPostProcessor会处理容器内 <strong>所有符合条件的实例化后的对象实例</strong>。</p>
</li>
<li>
<p>检查是否实现了 <strong>InitializingBean</strong> 接口，执行 <strong>afterPropertiesSet()</strong> 方法。</p>
</li>
<li>
<p>如果 Bean 在配置文件中的定义包含 <strong>init-method</strong> 属性，执行指定的方法。</p>
</li>
<li>
<p>执行 <strong>BeanPostProcessor</strong> 中的 <strong>postProcessAfterInitialization()</strong> 方法，BeanPostProcessor会处理容器内 <strong>所有符合条件的实例化后的对象实例</strong>。</p>
</li>
<li>
<p>然后就是这个Bean处于使用中了。</p>
</li>
<li>
<p>当要销毁 Bean 的时候，如果 Bean 实现了 <strong>DisposableBean</strong> 接口，执行 <strong>destroy()</strong> 方法。或者，如果 Bean 在配置文件中的定义包含 <strong>destroy-method</strong> 属性，执行指定的方法。</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_spring_aop">5.4. Spring AOP</h3>
<div class="paragraph">
<p><strong>AOP</strong> 全称为Aspect-Oriented Programming, 中文翻译为面向切面编程，AOP可以将业务系统中一些公共的点提取出来，进行封装，让我们在编写业务代码的时候，只关注业务的一个 <strong>切点</strong>，在切点的前后做相应的处理，简化了系统需求与实现之间的对比关系，使得整个系统的实现更具有模块化。</p>
</div>
<div class="paragraph">
<p>AOP通常用在 <strong>安全检查</strong>，<strong>系统日志</strong>，<strong>事物管理</strong>，<strong>性能统计</strong>，<strong>异常处理</strong> 等地方。</p>
</div>
<div class="paragraph">
<p><strong>Spring AOP</strong> 采用的是 <strong>动态代理机制</strong> 和 <strong>字节码生成技术</strong> 实现的。这两种方式都是 <strong>在运行期间</strong>，<strong>为被代理的目标类生成一个代理对象</strong>，而 <strong>将横切逻辑添加到这个代理对象中</strong>，系统最终使用的是添加了横切逻辑的代理对象，不是被代理的目标对象。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/AOP系统关系示意图.png" alt="AOP系统关系示意图">
</div>
</div>
<div class="sect3">
<h4 id="_java的三种代理方式">5.4.1. Java的三种代理方式</h4>
<div class="paragraph">
<p>java静态代理，JDK动态代理和cglib动态代理</p>
</div>
<div class="paragraph">
<p><strong>参考文档一</strong>： 《Sring揭秘》--王福强 （推荐，这本书写的真的很好）</p>
</div>
<div class="paragraph">
<p><strong>三种代理的实现代码Demo</strong>： <a href="https://github.com/wjcml/java_engineer_road_code/tree/master/java_proxy" target="_blank" rel="noopener">java的三种代理模式</a></p>
</div>
</div>
<div class="sect3">
<h4 id="_静态代理">5.4.2. 静态代理</h4>
<div class="paragraph">
<p>由程序员创建或由特定工具自动生成源代码，再对其编译。在程序运行前，代理类的 <code>.class</code> 文件就已经存在了。</p>
</div>
<div class="paragraph">
<p>静态代理方式需要代理对象和目标对象实现同一个接口。 <br>
<strong>缺点</strong>：冗余，不宜维护</p>
</div>
</div>
<div class="sect3">
<h4 id="_jdk动态代理">5.4.3. JDK动态代理</h4>
<div class="paragraph">
<p><strong>JDK动态代理</strong> 可以在运行期间，为相应的 <strong>接口（interface）</strong> 动态生成相应的代理对象。所以，我们可以将横切关注点的逻辑封装到动态代理的 <strong>InvocationHandler</strong> 中，然后在系统运行期间，根据横切关注点需要植入的模块位置，将横切逻辑植入到相应的 <strong>代理类</strong> 中。</p>
</div>
<div class="paragraph">
<p>JDK动态代理的方式需要 <strong>被代理的目标对象实现相应的接口</strong>，因为这种动态代理机制只针对接口有效。</p>
</div>
<div class="paragraph">
<p>JDK动态代理必须实现 <strong>InvocationHandler</strong> 接口，通过 <strong>反射</strong> 代理方法，比较消耗系统性能，但可以减少代理类的数量，使用更灵活。</p>
</div>
</div>
<div class="sect3">
<h4 id="_cglib动态代理">5.4.4. cglib动态代理</h4>
<div class="paragraph">
<p>我们知道，Java虚拟机加载class文件都是符合一定的规范的，所以，只要交给Java虚拟机运行的文件符合Java Class规范，程序的运行就没有问题。在Java中，我们可以使用 <strong>ASM</strong> 或者 <strong>cglib</strong> 工具库，在程序运行期间，动态的构建字节码的class文件。</p>
</div>
<div class="paragraph">
<p>在这样的前提下，我们可以为需要添加横切逻辑的模块类，在运行期间，通过动态字节码增强技术，为这些需要被代理的类 <strong>生成相应的子类</strong>，而 <strong>将横切逻辑加入到这些子类中</strong>，让程序在运行期间 <strong>使用的是这些动态生成的子类</strong>，从而达到将横切逻辑添加到系统中的目的。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>cglib包的底层是通过使用一个小而快的字节码处理框架ASM(什么是ASM？)，来转换字节码并生成新的类。</p>
</div>
<div class="paragraph">
<p>cglib代理无需实现接口，通过生成类字节码实现代理，比反射稍快，不存在性能问题，但cglib的代理对象会继承目标对象，需要重写方法，所以目标对象不能为 <strong>final类</strong>。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>cglib与JDK动态代理最大的区别就是JDK动态代理的对象必须实现一个或多个接口，使用cglib代理的对象则无需实现接口。</p>
</div>
<div class="paragraph">
<p><strong>JDK动态代理</strong>：代理的是接口  <br>
<strong>cglib代理</strong>：代理的是类</p>
</div>
<div class="paragraph">
<p>在Spring AOP中，判断使用 <strong>JDK动态代理</strong>，还是使用 <strong>cglib代理</strong>，就是根据被代理的目标类是否实现 <strong>接口</strong> 来判断的。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_spring_aop代理失效问题">5.4.5. Spring AOP代理失效问题？</h4>
<div class="paragraph">
<p>Spring AOP代理，同一个对象中的内部方法调用导致代理失效。</p>
</div>
<div class="sect4">
<h5 id="_原因分析">原因分析</h5>
<div class="paragraph">
<p>出现这种问题的原因是因为Spring AOP的实现机制造成的。Spring AOP采用的是 <strong>JDK动态代理</strong> 和 <strong>cglib动态代理</strong> 实现的AOP，<strong>在运行的时候，会动态生成对应的代理对象</strong>，而且 <strong>具体的横切逻辑也会被添加到代理对象中</strong>，只要调用的是 <strong>代理对象</strong> 上的方法，通常就可以保证目标对象上的方法执行可以被拦截。</p>
</div>
<div class="paragraph">
<p>但是，在对象内部方法调用时会失效，我们要知道，在代理方法中，不管添加多少的横切逻辑，最终都会调用 <strong>目标对象</strong> 上的同一方法来执行最初定义的方法逻辑。</p>
</div>
<div class="paragraph">
<p><strong>示例分析</strong></p>
</div>
<div class="paragraph">
<p>下面这个例子来自于《Sring揭秘&#8212;&#8203;王福强》。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class NestableInvacationBO {
    public void method1(){
        method2();
        System.out.println("method1 executed!");
    }

    public void method2(){
        System.out.println("method2 executed!");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上方代码中的类（NestableInvocationBO）中定义了两个方法，并且method1()方法会调用method2()方法。</p>
</div>
<div class="paragraph">
<p>现在，我们要使用Spring AOP拦截该类定义的方法method1()和method2()，下面是一个 <strong>AspectJ</strong>，定义了简单的切面逻辑。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Aspect
public class PerformanceTraceAspect {
    @Pointcut("execution(public void *.method1())")
    public void method1(){}
    @Pointcut("execution(public void *.method2())")
    public void method2(){}
    @Pointcut("method1() || method2()")
    public void compositePointcut(){}

    @Around("compositePointcut()")
    public Object performanceTrace(ProceedingJoinPoint joinPoint) throws Throwable{
        StopWatch watch = new StopWatch();
        try {
            watch.start();
            return joinPoint.proceed();
        }finally {
            watch.stop();
            System.out.println(String.format("PT in method[%s] &gt;&gt;&gt;&gt;&gt; %s", joinPoint.getSignature().getName(), watch.toString()));
        }
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>其中定义的 <strong>Around Advice</strong> 会拦截 <strong>compositePointcut()</strong> 指定的 Joinpoint，即method1()或者method2()的执行。</p>
</div>
<div class="paragraph">
<p>如果将 <strong>PerformanceTranceAspect</strong> 中定义的横切逻辑织入到 <strong>NestableInvocationBO</strong> 中，然后运行代码并查看结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        AspectJProxyFactory weaver = new AspectJProxyFactory(new NestableInvacationBO());
        weaver.setProxyTargetClass(true);
        weaver.addAspect(PerformanceTraceAspect.class);
        Object proxy = weaver.getProxy();
        ((NestableInvacationBO) proxy).method2();
        ((NestableInvacationBO) proxy).method1();</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>输出结果</strong>：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spring_aop代码1.png" alt="spring aop代码1">
</div>
</div>
<div class="paragraph">
<p>从输出结果我们可以看出，我们直接从外部调用 <strong>method2()</strong> 的时候，该方法被正常拦截。但是当我们从外部调用 <strong>method1()</strong> 的时候，却只有 <strong>method1()</strong> 被成功拦截，而 <strong>method1()</strong> 中的 <strong>method2()</strong> 没有被拦截，因为输出日志中只有 <strong>PT in method[method1]</strong> 的信息</p>
</div>
<div class="paragraph">
<p>下面是 <strong>代理对象</strong> 和 <strong>目标对象</strong> 的方法调用关系(<strong>Spring AOP对象内部方法嵌套调用示意图</strong>)：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spring_aop对象内部方法嵌套调用示意图.png" alt="spring aop对象内部方法嵌套调用示意图">
</div>
</div>
<div class="paragraph">
<p>从上图我们可以看出，在 <strong>代理对象的method1()</strong> 经过层层拦截器之后，最终会将调用转向 <strong>目标对象的method1()</strong>，之后的调用流程全部都是走在 <strong>目标对象（TargetObject）</strong> 之上，当method1()调用method2()的时候，它调用的是 <strong>TargetObject上的method2()</strong>，而不是 <strong>ProxyObject上的method2()</strong>。要知道，针对method2()的横切逻辑，只是织入到了 <strong>代理对象（ProxyObject）</strong> 上的method2()方法中，所以，在method1()中所调用的method2()没有被拦截成功。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="literalblock">
<div class="content">
<pre>正因为上述原因，可以解释在Spring中，为什么 @Transactional，@Cacheable 等注解会失效了。</pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_spring数据访问">5.5. Spring数据访问</h3>
<div class="sect3">
<h4 id="_什么是jdbc">5.5.1. 什么是JDBC？</h4>
<div class="paragraph">
<p>JDBC是Java DataBase Connectivity的缩写，它是Java程序访问数据库的标准接口。</p>
</div>
<div class="paragraph">
<p>使用Java程序访问数据库时，Java代码并不是直接通过TCP连接去访问数据库，而是通过JDBC接口来访问，而JDBC接口则通过JDBC驱动来实现真正对数据库的访问。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>使用JDBC的好处是：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>各数据库厂商使用相同的接口，Java代码不需要针对不同数据库分别开发；</p>
</li>
<li>
<p>Java程序编译期仅依赖java.sql包，不依赖具体数据库的jar包；</p>
</li>
<li>
<p>可随时替换底层数据库，访问数据库的Java代码基本不变。</p>
</li>
</ol>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<div class="title">JDBC查询</div>
<p>获取到JDBC连接后，下一步我们就可以查询数据库了。查询数据库分以下几步：</p>
</div>
<div class="paragraph">
<p>第一步，通过 <strong>Connection</strong> 提供的 <strong>createStatement()</strong> 方法创建一个 <strong>Statement</strong> 对象，用于执行一个查询；</p>
</div>
<div class="paragraph">
<p>第二步，执行 <strong>Statement</strong> 对象提供的 <strong>executeQuery("SELECT * FROM students")</strong> 并传入SQL语句，执行查询并获得返回的结果集，使用 <strong>ResultSet</strong> 来引用这个结果集；</p>
</div>
<div class="paragraph">
<p>第三步，反复调用 <strong>esultSet</strong> 的 <strong>next()</strong> 方法并读取每一行结果。</p>
</div>
<div class="paragraph">
<p>完整查询代码如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// JDBC连接的URL, 不同数据库有不同的格式:
String JDBC_URL = "jdbc:mysql://localhost:3306/test";
String JDBC_USER = "root";
String JDBC_PASSWORD = "password";

// try-with-resources
try (Connection conn = DriverManager.getConnection(JDBC_URL, JDBC_USER, JDBC_PASSWORD)) {
    try (Statement stmt = conn.createStatement()) {
        try (ResultSet rs = stmt.executeQuery("SELECT id, grade, name, gender FROM students WHERE gender=1")) {
            while (rs.next()) {
                long id = rs.getLong(1); // 注意：索引从1开始
                long grade = rs.getLong(2);
                String name = rs.getString(3);
                int gender = rs.getInt(4);
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_集成hibernate">5.5.2. 集成Hibernate</h4>
<div class="paragraph">
<p>Hibernate是对JDBC的深度封装。</p>
</div>
<div class="paragraph">
<div class="title">SessionFactory</div>
<p>在Hibernate中，<strong>SessionFactory</strong> 是Hibernate最核心的一个对象，<strong>SessionFactory</strong> 中封装了 <strong>JDBC DataSource的实例</strong>，即 <strong>SessionFactory</strong> 持有连接池，每次需要操作数据库的时候，<strong>SessionFactory</strong> 创建一个新的 <strong>Session</strong>，<strong>Session</strong> 是封装了一个 <strong>JDBC Connection</strong> 的实例，相当于从连接池获取到一个新的 <strong>Connection</strong>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_集成mybatis">5.5.3. 集成Mybatis</h4>
<div class="paragraph">
<p>Mybatis是对JDBC的浅度封装，对用户的sql编写要求要高一些。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_spring事务">5.6. Spring事务</h3>
<div class="paragraph">
<p><strong>事务是逻辑上的一组操作，要么都执行，要么都不执行。</strong></p>
</div>
<div class="sect3">
<h4 id="_spring对事务的支持">5.6.1. Spring对事务的支持</h4>
<div class="paragraph">
<p>程序时候支持事务首先取决于数据库，比如MySQL，<strong>innodb</strong> 引擎支持事务，<strong>myisam</strong> 引擎不支持事务。</p>
</div>
</div>
<div class="sect3">
<h4 id="_事务的四大特性acid">5.6.2. 事务的四大特性（ACID）</h4>
<div class="imageblock">
<div class="content">
<img src="images/事务四大特性.png" alt="事务四大特性">
</div>
</div>
<div class="paragraph">
<p><strong>原子性</strong>：事务所包含的全部操作是一个整体，要么全部提交成功，要么全部失败。<br>
<strong>一致性</strong>：要求事务所包含的操作不能违反数据资源的一致性检查，即在事务执行之后数据之间保持着一致。<br>
<strong>隔离性</strong>：多个事务执行，各个事务之间相互影响的程度。当两个事务同时访问一个数据资源的时候，不同的隔离级别决定了各个事务对该数据资源访问的不同行为。事务隔离分为不同级别，包括 <strong>读未提交（Read uncommitted）、读已提交（read committed）、可重复读（repeatable read）和串行化（Serializable）</strong>。<br>
<strong>持久性</strong>：一旦整个事务的操作成功提交，对数据所作的变更将被记载并且不可逆转。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><strong>MySQL 怎么保证原子性的？</strong></p>
</div>
<div class="paragraph">
<p>我们知道如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行 <strong>回滚</strong>，在 <strong>MySQL</strong> 中，恢复机制是通过 <strong>回滚日志（undo log）</strong> 实现的，所有事务进行的修改都会先先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用 <strong>回滚日志</strong> 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_并发事务带来的问题">5.6.3. 并发事务带来的问题？</h4>
<div class="paragraph">
<p><strong>脏读</strong>：当一个事务正在访问数据并且对数据进行了修改，但事务还没有提交，另一个事务可以“看到”这个没有提交的更新结果。这样的会造成的问题就是，如果第一个事务回滚，那么第二个事务之前所“看到”的数据就是一笔脏数据。</p>
</div>
<div class="paragraph">
<p><strong>不可重复读</strong>：指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p>
</div>
<div class="paragraph">
<p><strong>幻读</strong>：幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><strong>不可重复读和幻读区别</strong>：
不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_事务的隔离级别有哪些">5.6.4. 事务的隔离级别有哪些？</h4>
<div class="paragraph">
<p><strong>READ-UNCOMMITTED(读取未提交)</strong>： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。<br>
<strong>READ-COMMITTED(读取已提交)</strong>： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。<br>
<strong>REPEATABLE-READ(可重复读)</strong>： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。<br>
<strong>SERIALIZABLE(可串行化)</strong>： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/事务隔离级别.png" alt="事务隔离级别">
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>MYSQL默认的事务隔离级别是 <strong>REPEATABLE-READ(可重复读)</strong>。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_事务的传播行为">5.6.5. 事务的传播行为</h4>
<div class="paragraph">
<p><strong>事务传播行为是为了解决业务层方法之间互相调用的事务问题</strong></p>
</div>
<div class="paragraph">
<p>如果有两个方法，都被 <strong>@Tansactional</strong> 注释（即这是两个事务方法），<strong>方法A（aMethod）调用了方法B（bMethod）</strong>，在业务中会有以下问题的出现：
如果 <strong>bMethod</strong> 出现异常，是让 <strong>bMethod</strong> 提交还是两个一起回滚？</p>
</div>
<div class="paragraph">
<p>在Spring中，提供了7种事务的传播机制，下面是Spring定义的源码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.springframework.transaction.annotation;

public enum Propagation {
    REQUIRED(0),
    SUPPORTS(1),
    MANDATORY(2),
    REQUIRES_NEW(3),
    NOT_SUPPORTED(4),
    NEVER(5),
    NESTED(6);

    private final int value;

    private Propagation(int value) {
        this.value = value;
    }

    public int value() {
        return this.value;
    }
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_1_propagation_required">1. Propagation.REQUIRED</h5>
<div class="paragraph">
<p><strong>如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</strong> Spring中 <strong>@Transactional</strong> 默认的事务传播行为，也是我们经常使用的传播行为。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>如果外部方法没有开启事务的话，<strong>Propagation.REQUIRED</strong> 修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</p>
</li>
<li>
<p>如果外部方法开启事务并且被 <strong>Propagation.REQUIRED</strong> 的话，所有 <strong>Propagation.REQUIRED</strong> 修饰的内部方法和外部方法均属于同一事务 ，只要一个方法回滚，整个事务均回滚。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>举例说明：如果我们上面的 <strong>aMethod()</strong> 和 <strong>bMethod()</strong> 使用的都是 <strong>Propagation.REQUIRED</strong> 传播行为的话，两者使用的就是同一个事务，只要其中一个方法回滚，整个事务均回滚。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Class A {
    @Transactional(propagation=Propagation.REQUIRED)
    public void aMethod {
        //do something
        B b = new B();
        b.bMethod();
    }
}

Class B {
    @Transactional(propagation=Propagation.REQUIRED)
    public void bMethod {
       //do something
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_2_propagation_requires_new">2. Propagation.REQUIRES_NEW</h5>
<div class="paragraph">
<p><strong>创建一个新的事务，如果当前存在事务，则把当前事务挂起</strong>。也就是说不管外部方法是否开启事务，<strong>Propagation.REQUIRES_NEW</strong> 修饰的内部方法会新开启自己的事务，且开启的事务 <strong>相互独立，互不干扰</strong>。</p>
</div>
<div class="paragraph">
<p>举例说明：如果我们上面的 <strong>bMethod()</strong> 使用 <strong>Propagation.REQUIRES_NEW</strong> 事务传播行为修饰，<strong>aMethod()</strong> 还是用 <strong>Propagation.REQUIRED</strong> 修饰的话。如果 <strong>aMethod()</strong> 发生异常回滚， <strong>bMethod()</strong> 不会跟着回滚，因为 <strong>bMethod()</strong> 开启了独立的事务。但是，如果 <strong>bMethod()</strong> 抛出了 <strong>未被捕获</strong> 的异常并且这个异常满足事务回滚规则的话，<strong>aMethod()</strong> 同样也会回滚，因为这个异常被 <strong>aMethod()</strong> 的事务管理机制检测到了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Class A {
    @Transactional(propagation=Propagation.REQUIRED)
    public void aMethod {
        //do something
        B b = new B();
        b.bMethod();
    }
}

Class B {
    @Transactional(propagation=Propagation.REQUIRES_NEW)
    public void bMethod {
       //do something
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_3_propagation_nested">3. Propagation.NESTED</h5>
<div class="paragraph">
<p><strong>如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于Propagation.REQUIRED。</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>在外部方法未开启事务的情况下 <strong>Propagation.NESTED</strong> 和 <strong>Propagation.REQUIRED</strong> 作用相同，修饰的内部方法都会新开启自己的事务，且开启的事务相互独立，互不干扰。</p>
</li>
<li>
<p>如果外部方法开启事务的话，<strong>Propagation.NESTED</strong> 修饰的内部方法属于外部事务的子事务，外部主事务回滚的话，子事务也会回滚，而内部子事务可以单独回滚而不影响外部主事务和其他子事务。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>举例说明：如果 <strong>aMethod()</strong> 回滚的话，<strong>bMethod()</strong> 和 <strong>bMethod2()</strong> 都要回滚，而 <strong>bMethod()</strong> 回滚的话，并不会造成 <strong>aMethod()</strong> 和 <strong>bMethod()2</strong> 回滚。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Class A {
    @Transactional(propagation=Propagation.REQUIRED)
    public void aMethod {
        //do something
        B b = new B();
        b.bMethod();
        b.bMethod2();
    }
}

Class B {
    @Transactional(propagation=Propagation.NESTED)
    public void bMethod {
       //do something
    }
    @Transactional(propagation=Propagation.NESTED)
    public void bMethod2 {
       //do something
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_4_propagation_mandatory">4. Propagation.MANDATORY</h5>
<div class="paragraph">
<p><strong>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</strong></p>
</div>
</div>
<div class="sect4">
<h5 id="_5_propagation_supports">5. Propagation.SUPPORTS</h5>
<div class="paragraph">
<p><strong>如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</strong></p>
</div>
</div>
<div class="sect4">
<h5 id="_6_propagation_not_supported">6. Propagation.NOT_SUPPORTED</h5>
<div class="paragraph">
<p><strong>以非事务方式运行，如果当前存在事务，则把当前事务挂起。</strong></p>
</div>
</div>
<div class="sect4">
<h5 id="_7_propagation_never">7. Propagation.NEVER</h5>
<div class="paragraph">
<p><strong>以非事务方式运行，如果当前存在事务，则抛出异常。</strong></p>
</div>
<div class="quoteblock">
<blockquote>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><strong>Propagation.SUPPORTS</strong>，<strong>Propagation.NOT_SUPPORTED</strong>，<strong>Propagation.NEVER</strong> 这三种事务的传播行为，用得比较少，配置以后可能会导致事务不会回滚。</p>
</div>
</blockquote>
</div>
</blockquote>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_spring配置事务的两种方式">5.6.6. Spring配置事务的两种方式</h4>
<div class="sect4">
<h5 id="_编程式事务">编程式事务</h5>
<div class="paragraph">
<p>通过 <strong>TransactionTemplate</strong> 或者 <strong>TransactionManager</strong>  在代码中手动管理事务的方式，但是我们在实际开发中是很少用到的，可以了解一下，帮助自己理解Spring事务。</p>
</div>
<div class="listingblock">
<div class="title">使用 <strong>TransactionTemplate</strong> 进行编程式事务管理</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Autowired
private TransactionTemplate transactionTemplate;
public void testTransaction() {

    transactionTemplate.execute(new TransactionCallbackWithoutResult() {
        @Override
        protected void doInTransactionWithoutResult(TransactionStatus transactionStatus) {

            try {
                // ....  业务代码
            } catch (Exception e){
                //回滚
                transactionStatus.setRollbackOnly();
            }

        }
    });
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">使用 <strong>TransactionManager</strong> 进行编程式事务管理</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Autowired
private PlatformTransactionManager transactionManager;

public void testTransaction() {

  TransactionStatus status = transactionManager.getTransaction(new DefaultTransactionDefinition());
          try {
               // ....  业务代码
              transactionManager.commit(status);
          } catch (Exception e) {
              transactionManager.rollback(status);
          }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_声明式事务">声明式事务</h5>
<div class="paragraph">
<p>声明式事务是基于 <strong>Spring AOP</strong> 实现的，一般使用 <strong>@Transactional</strong> 注解进行事务管理，这样的事务管理方式 <strong>代码侵入性小</strong>，推荐使用声明式事务。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_spring事务管理接口">5.6.7. Spring事务管理接口</h4>
<div class="paragraph">
<p>Spring的事务框架将开发过程中的事务管理相关的关注点进行适当的分离，并对这些关注点进行合理的抽象。通过Spring的事务框架，我们可以按照 <strong>统一的编程模型</strong> 来进行事务编程，却不用关心所使用的数据访问技术（JDBC、iBatis、Hibernate等）和具体要访问的什么类型的事务资源。</p>
</div>
<div class="paragraph">
<p>Spring的事务框架设计理念的基本原则是：<strong>让事务管理的关注点与数据访问关注点相分离</strong>。
. 当在业务层使用事务的抽象API进行事务界定的时候，不需要关心事务将要加诸于上事务资源是什么，对不同的事务资源的管理将由相应的框架实现类来操心。<br>
. 当在数据访问层对可能参与事务的数据资源进行访问的时候，只需要使用相应的数据访问API进行数据访问，不需要关心当前的事务资源如何参与事务或者是否需要参与事务。这同样将由事务框架类来打理。</p>
</div>
<div class="paragraph">
<p>对于开发人员来说，唯一需要关心的，就是 <strong>通过抽象后的事务管理API对当前事务进行界定</strong> 而已。</p>
</div>
<div class="sect4">
<h5 id="_事务管理三大核心接口">事务管理三大核心接口</h5>
<div class="paragraph">
<p><strong>PlatformTransactionManager</strong>：（平台）事务管理器，负责界定事务的边界。</p>
</div>
<div class="paragraph">
<p><strong>TransactionDefinition</strong>：负责定义事务相关属性，（包括事务隔离级别、传播行为、超时、只读、回滚规则）。PlatformTransactionManager 将根据 TransactionDefinition 定义的属性来开启相关事务。</p>
</div>
<div class="paragraph">
<p><strong>TransactionStatus</strong>：负责事务开启到事务结束期间的事务状态。</p>
</div>
<div class="paragraph">
<p>它们之间的依赖关系如下图：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spring事务接口依赖图.png" alt="spring事务接口依赖图">
</div>
</div>
</div>
<div class="sect4">
<h5 id="_platformtransactionmanager事务界定">PlatformTransactionManager：事务界定</h5>
<div class="paragraph">
<p>负责界定事务的边界，这个接口中定义了三个方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.springframework.transaction;

import org.springframework.lang.Nullable;

public interface PlatformTransactionManager {
    //获得事务
    TransactionStatus getTransaction(@Nullable TransactionDefinition var1) throws TransactionException;
    //提交事务
    void commit(TransactionStatus var1) throws TransactionException;
    //回滚事务
    void rollback(TransactionStatus var1) throws TransactionException;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring采用 <strong>策略模式</strong>，通过实现这个接口，不同的数据访问方式，采用不同的事务管理器去处理，比如，Spring 为各个平台如 JDBC/iBatis(DataSourceTransactionManager)、Hibernate(HibernateTransactionManager)、JPA(JpaTransactionManager)等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。</p>
</div>
</div>
<div class="sect4">
<h5 id="_transactiondefinition事务属性">TransactionDefinition：事务属性</h5>
<div class="paragraph">
<p>负责定义事务相关属性，事务管理器接口 <strong>PlatformTransactionManager</strong> 通过 <strong>getTransaction(TransactionDefinition definition)</strong> 方法来得到一个事务，这个方法里面的参数是 <strong>TransactionDefinition</strong> 类。Spring源码如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.springframework.transaction;

import org.springframework.lang.Nullable;

public interface TransactionDefinition {
    int PROPAGATION_REQUIRED = 0;
    int PROPAGATION_SUPPORTS = 1;
    int PROPAGATION_MANDATORY = 2;
    int PROPAGATION_REQUIRES_NEW = 3;
    int PROPAGATION_NOT_SUPPORTED = 4;
    int PROPAGATION_NEVER = 5;
    int PROPAGATION_NESTED = 6;
    int ISOLATION_DEFAULT = -1;
    int ISOLATION_READ_UNCOMMITTED = 1;
    int ISOLATION_READ_COMMITTED = 2;
    int ISOLATION_REPEATABLE_READ = 4;
    int ISOLATION_SERIALIZABLE = 8;
    int TIMEOUT_DEFAULT = -1;
    // 返回事务的传播行为，默认值为 REQUIRED。
    int getPropagationBehavior();
    //返回事务的隔离级别，默认值是 DEFAULT
    int getIsolationLevel();
    // 返回事务的超时时间，默认值为-1。如果超过该时间限制但事务还没有完成，则自动回滚事务。
    int getTimeout();
    // 返回是否为只读事务，默认值为 false
    boolean isReadOnly();

    @Nullable
    String getName();
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_transactionstatus事务状态">TransactionStatus：事务状态</h5>
<div class="paragraph">
<p>负责事务开启到事务结束期间的事务状态。</p>
</div>
<div class="paragraph">
<p><strong>TransactionStatus</strong> 接口用来记录事务的状态 该接口定义了一组方法,用来获取或判断事务的相应状态信息。<strong>PlatformTransactionManager.getTransaction(…)</strong> 方法返回一个 <strong>TransactionStatus</strong> 对象。</p>
</div>
<div class="paragraph">
<p>Spring源码如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface TransactionStatus{
    boolean isNewTransaction(); // 是否是新的事务
    boolean hasSavepoint(); // 是否有恢复点
    void setRollbackOnly();  // 设置为只回滚
    boolean isRollbackOnly(); // 是否为只回滚
    boolean isCompleted; // 是否已完成
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_spring_mvc_chapter">6. Spring MVC</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_什么是spring_mvc">6.1. 什么是Spring MVC？</h3>
<div class="paragraph">
<p>MVC 是一种软件架构思想，是一种开发模式，将软件划分为三种不同类型的模块，分别是模型，视图，和控制器。</p>
</div>
<div class="paragraph">
<p>Spring MVC是一个基于MVC架构的用来简化web应用程序开发的应用开发框架。</p>
</div>
<div class="sect3">
<h4 id="_spring_mvc的原理">6.1.1. Spring MVC的原理</h4>
<div class="paragraph">
<p>通过一张图来说明Spring MVC的工作原理：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spring_mvc原理图.png" alt="spring mvc原理图">
</div>
</div>
<div class="paragraph">
<p>关于上图的流程解释如下：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>客户端（浏览器）发送请求，直接请求到 <strong>DispatcherServlet</strong>。</p>
</li>
<li>
<p><strong>DispatcherServlet</strong> 根据请求信息调用 <strong>HandlerMapping</strong>，解析请求对应的 <strong>Handler</strong>。</p>
</li>
<li>
<p>解析到对应的 <strong>Handler</strong>（也就是我们平常说的 <strong>Controller</strong> 控制器）后，开始由 <strong>HandlerAdapter</strong> 适配器处理。</p>
</li>
<li>
<p><strong>HandlerAdapter</strong> 会根据 <strong>Handler</strong> 来调用真正的处理器来处理请求，并处理相应的业务逻辑。</p>
</li>
<li>
<p>处理器处理完业务后，会返回一个 <strong>ModelAndView</strong> 对象，<strong>Model</strong> 是返回的数据对象，<strong>View</strong> 是个逻辑上的 <strong>View</strong>。</p>
</li>
<li>
<p><strong>ViewResolver</strong> 会根据逻辑 <strong>View</strong> 查找实际的 <strong>View</strong>。</p>
</li>
<li>
<p><strong>DispaterServlet</strong> 把返回的 <strong>Model</strong> 传给 <strong>View</strong>（视图渲染）。</p>
</li>
<li>
<p>把 <strong>View</strong> 返回给请求者（浏览器）</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_spring_mvc中各角色交互">6.1.2. Spring MVC中各角色交互</h4>
<div class="imageblock">
<div class="content">
<img src="images/spring_mvc各种角色交互图.png" alt="spring mvc各种角色交互图">
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_spring_boot_chapter">7. SpringBoot</h2>
<div class="sectionbody">
<div class="paragraph">
<p>参考书籍: <strong>《Spring Boot技术内幕》--朱智胜</strong> （这本书写的超级好，推荐）</p>
</div>
<div class="paragraph">
<p>随着互联网的高速发展，Spring集成了很多的开源软件，引入了大量的配置文件，这样会导致程序出错率高，运行效率低，开发难度增加等问题。为了解决这些问题，Spring Boot也就应运而生。</p>
</div>
<div class="paragraph">
<p>Spring Boot的核心设计理念：<strong>约定优于配置</strong></p>
</div>
<div class="sect2">
<h3 id="_spring_boot核心运行原理">7.1. Spring Boot核心运行原理</h3>
<div class="paragraph">
<p>在使用 Spring Boot 时，我们只需要引入对应的 Starters，Spring Boot 启动时便会自动加载相关依赖，配置相应的初始化参数，以最快捷，简单的形式对第三方软件进行集成，这便是 Spring Boot 的自动配置功能。</p>
</div>
<div class="paragraph">
<p>下图是 Spring Boot 实现运作机制涉及的核心部分：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spring_boot自动配置功能核心运行原理图.png" alt="spring boot自动配置功能核心运行原理图">
</div>
</div>
<div class="paragraph">
<p>在上图中，我们可以看到 Spring Boot 自动配置功能运作过程中设计的几个核心功能及相互之间的关系包括 <strong>@EnableAutoConfiguration</strong>，<strong>spring.factories</strong>，各组件对应的 <strong>AutoConfiguration</strong> 类，<strong>@Conditional</strong> 注解以及各种 Starters。</p>
</div>
<div class="paragraph">
<p>用一句话来描述这个过程：Spring Boot 通过 <strong>@EnableAutoConfiguration</strong> 注解开启自动配置，加载 <strong>spring.factories</strong> 中注册的各种 <strong>AutoConfiguration</strong> 类，当某个 <strong>AutoConfiguration</strong> 类满足其注解 <strong>@Conditional</strong> 指定的生效条件时，就实例化该 <strong>AutoConfiguration</strong> 类中定义的Bean（组件等），并注入Spring容器，就可以完成依赖框架的自动配置。</p>
</div>
<div class="paragraph">
<p>这写对应部分的作用及相互关系如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>@EnableAutoConfiguration</strong>：该注解由组合注解 <strong>@SpringBootApplication</strong> 引入，完成自动配置开启，扫描各个 jar 包下的 <strong>spring.factories</strong> 文件，并加载文件中注册的 <strong>AutoConfiguration</strong> 类等。</p>
</li>
<li>
<p><strong>spring.factories</strong>：配置文件，位于 jar 包的 META—INF 目录下，按照指定格式注册了自动配置的 <strong>AutoConfiguration</strong> 类。<strong>spring.factories</strong> 也可以包含其它类型待注册的类。该配置文件不仅仅存在于 Spring Boot 项目中，也可以存在于自定义的自动配置（或者 Starter）项目中。</p>
</li>
<li>
<p><strong>AutoConfiguration</strong> 类：自动配置类，代表了 Spring Boot 中一类以 **AutoConfiguration 命名的自动配置类。其中定义了三方组件集成 Spring 所需初始化的 Bean 和条件。</p>
</li>
<li>
<p><strong>@Conditional</strong>：条件注解及其衍生注解，在 AutoConfiguration 类上使用，当满足该条件时，才会实例化 AutoConfiguration 类。</p>
</li>
<li>
<p><strong>Starters</strong>：三方组件的依赖及配置，Spring Boot已经预置的组件。</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_自动配置注解_enableautoconfiguration">7.1.1. 自动配置注解 @EnableAutoConfiguration</h4>
<div class="paragraph">
<p>在 SpringBoot 项目的启动类的上方有一个核心注解 <strong>@SpringBootApplication</strong>，该注解其中包含以下三个注解：</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><strong>@SpringBootConfiguration</strong>：我们点进这个注解里面，可以看到，该注解包含 <strong>@Configuration</strong> 注解，说白了就是支持 JavaConfig 的方式进行配置 Bean （使用Configuration配置类等同于XML文件）。</p>
</div>
<div class="paragraph">
<p><strong>@EnableAutoConfiguration</strong>：开启自动配置功能。</p>
</div>
<div class="paragraph">
<p><strong>@ComponentScan</strong>：扫描注解，默认是扫描当前类下的包，所以我们的启动类一般都放在最顶层的包下面。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>接下来就要具体分析 <strong>@EnableAutoConfiguration</strong> 注解了，我们点击进入 <strong>@EnableAutoConfiguration</strong> 的注解类中，可以发现，在该注解上方有一个 <strong>@Import(AutoConfigurationImportSelector.class)</strong> 注解代码（<strong>@Import</strong> 注解的比较重要，要了解的话，请先阅读 <a href="#Import注解">@Import注解</a>），如下图：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/@EnableAutoConfiguration.png" alt="@EnableAutoConfiguration">
</div>
</div>
<div class="paragraph">
<p>然后我们再点进 <strong>AutoConfigurationImportSelector.class</strong> 类中，如下图：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/AutoConfigurationImportSelector类及实现接口.png" alt="AutoConfigurationImportSelector类及实现接口">
</div>
</div>
<div class="paragraph">
<p>从上图中我们可以看出，<strong>AutoConfigurationImportSelector.class</strong> 类实现了 <strong>DeferredImportSelector</strong> 接口（该接口作用在 <a href="#Import注解">@Import注解</a> 有讲到），以及 4 个 <strong>Aware</strong> 接口（这种类型的接口作用在 <a href="#各色的Aware接口">各色的Aware接口</a> 中有讲到），由于实现了 <strong>DeferredImportSelector</strong> 接口，所以该类会实现其中的 <strong>selectImports</strong> 方法，如下图：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/selectImports方法获取自动配置信息.png" alt="selectImports方法获取自动配置信息">
</div>
</div>
<div class="paragraph">
<p>从上面的源码中可以看出，<strong>selectImports</strong> 方法会 <strong>获取将被引入的自动配置信息，并返回符合条件的配置类的全限定名数组</strong>，那么该方法是怎么获取到将被引入的自动配置信息的呢，下面我们点进 <strong>getAutoConfigurationEntry</strong> 方法中，如下图：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/获取将被引入的自动配置信息的方法.png" alt="获取将被引入的自动配置信息的方法">
</div>
</div>
<div class="paragraph">
<p>上图就是获取将被引入的自动配置信息的方法，具体步骤可以看其中的注释，不过现在我们还是想看一下自动配置类的信息从哪里来，我们点进 <strong>getCandidateConfigurations</strong> 方法，看下面两张图：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/getCandidateConfigurations方法.png" alt="getCandidateConfigurations方法">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/加载自动配置的类信息方法.png" alt="加载自动配置的类信息方法">
</div>
</div>
<div class="paragraph">
<p>从上面的两张图可以看出，在 <strong>getCandidateConfigurations</strong> 方法中，会通过 <strong>SpringFactoriesLoader.loadFactoryNames</strong> 读取 <strong>META-INF/spring.factories</strong> 文件，并筛选出以 <strong>EnableAutoConfiguration</strong> 为 key 的配置类信息。</p>
</div>
<div class="paragraph">
<p>就这样，最终将这些配置加载到 IOC 容器中，实现了自动配置功能。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>下面总结一下，SpringBoot 自动配置的几个核心步骤，如下图：</p>
</div>
</blockquote>
</div>
</blockquote>
</div>
<div class="imageblock">
<div class="content">
<img src="images/SpringBoot自动配置核心步骤图.png" alt="SpringBoot自动配置核心步骤图">
</div>
</div>
</div>
<div class="sect3">
<h4 id="_条件注解_conditional">7.1.2. 条件注解 @Conditional</h4>
<div class="paragraph">
<p>@Conditional 注解是由 Spring 4.0 版本引入的新特性，可根据是否满足指定的条件来决定是否进行 Bean 的实例化以及装配。下面是该注解的源码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Conditional {
    Class&lt;? extends Condition&gt;[] value();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>@Conditional 注解唯一的元素属性是接口 Condition 的数组，只有在 Condition 的 matches 方法都返回 true 的情况下，被注解的类才会被加载。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_spring_boot构造流程">7.2. Spring Boot构造流程</h3>
<div class="paragraph">
<p>Spring Boot 的启动代码非常简单，只有简单的几行代码，如下图：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/springboot启动入口类代码.png" alt="springboot启动入口类代码">
</div>
</div>
<div class="paragraph">
<p>从上面的Spring Boot启动入口代码来看，Spring Boot通过调用 <strong>SpringApplication</strong> 的静态方法 <strong>run</strong> 方法来启动。我们点进 run 方法的源码看一下，如下图：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/springboot的run方法.png" alt="springboot的run方法">
</div>
</div>
<div class="paragraph">
<p>看了以上这两个 <strong>run</strong> 方法，可以看出，最后是创建了一个 <strong>SpringApplication</strong> 的对象，然后执行了这个对象的 <strong>run</strong> 方法。因此，我们的启动入口程序也可以写成：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
public class SpringOauthApplication {
    public static void main(String[] args) {
        new SpringApplication(SpringOauthApplication.class).run(args);
    }
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_springapplication_实例化流程">7.2.1. SpringApplication 实例化流程</h4>
<div class="paragraph">
<p>现在我们知道要启动Spring Boot项目，首先需要实例化一个 <strong>SpringApplication</strong> 对象，那么接下来，我们看一下 <strong>SpringApplication</strong> 实例化的过程中具体做了什么操作，源码如下：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/springboot的springapplication实例化.png" alt="springboot的springapplication实例化">
</div>
</div>
<div class="paragraph">
<p>通过源码分析，我们用一张图来直观的表示 SpringApplication 实例化过程所做的事情，如下图：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/springboot中的springApplication实例化流程图.png" alt="springboot中的springApplication实例化流程图">
</div>
</div>
<div class="paragraph">
<p>从上图我们可以看出，在 SpringApplication 对象实例化的过程中主要做了 3 件事情：<strong>参数赋值给成员变量，应用类型及方法推断和ApplicationContext相关内容加载及实例化</strong>。</p>
</div>
<div class="sect4">
<h5 id="_参数赋值给成员变量">参数赋值给成员变量</h5>
<div class="paragraph">
<p>SpringApplication 核心构造方法有两个参数，第一个是 <strong>ResourceLoader resourceLoader</strong>，第二个是 <strong>Class&lt;?&gt;&#8230;&#8203; primarySources</strong>。</p>
</div>
<div class="paragraph">
<p><strong>ResourceLoader</strong> 是资源加载的接口。</p>
</div>
<div class="paragraph">
<p><strong>primarySources</strong> 是一个可变参数，用来指定项目的启动类，此参数传入的类需要满足一个必要条件，那就是被注解 <strong>@EnableAutoConfiguration</strong> 标注（<strong>@ApringBootApplication</strong> 中包含此注解），一般情况下，我们的入口类会被指定为启动类。</p>
</div>
</div>
<div class="sect4">
<h5 id="_推断web应用类型">推断Web应用类型</h5>
<div class="paragraph">
<p>在完成成员变量赋值以后，就会通过 <strong>WebApplicationType.deduceFromClasspath()</strong> 方法推断Web应用类型。该方法主要通过判断指定的类是否存在于 <strong>classpath</strong> 下，并根据判断结果来进行组合推断该应用属于什么Web类型。</p>
</div>
</div>
<div class="sect4">
<h5 id="_applicationcontextinitializer加载">ApplicationContextInitializer加载</h5>
<div class="paragraph">
<p><strong>ApplicationContextInitializer</strong> 是Spring IOC 容器提供的一个接口，它是一个回调接口，主要目的是允许用户在 <strong>ConfigurableApplicationContext</strong> 类型（或其子类型）的 <strong>ApplicationContext</strong> 做 <strong>refresh</strong> 方法调用刷新前，对 <strong>ConfigurableApplicationContext</strong> 实例做进一步的设置或处理。通常用于应用程序上下文进行编程初始化的Web应用程序中。</p>
</div>
<div class="paragraph">
<p>ApplicationContextInitializer 接口只定义了一个 <strong>initialize</strong> 方法，代码如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@FunctionalInterface
public interface ApplicationContextInitializer&lt;C extends ConfigurableApplicationContext&gt; {
    void initialize(C applicationContext);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>ApplicationContextInitializer 接口的 initialize 方法主要是为了初始化指定的应用上下文。而对应的上下文由参数传入，参数为 <strong>ConfigurableApplicationContext</strong> 的子类。</p>
</div>
<div class="paragraph">
<p>从 SpringApplication 初始化的源码可以看出，在 <strong>ApplicationContextInitializer</strong> 实例化的时候，先是通过 <strong>getSpringFactoriesInstances</strong> 方法获取实例，然后通过 <strong>setInitializers</strong> 方法设置实例。</p>
</div>
<div class="paragraph">
<p><strong>getSpringFactoriesInstances</strong> 方法获取实例的时候是依然是通过 <strong>SringFactoriesLoader</strong> 类的 <strong>loadFactoryNames</strong> 方法，获取 <strong>META-INF/spring.factories</strong> 文件中注册的对应的配置。获取到实例之后，会进行初始化操作，并返回创建好的实例集合。代码如下图：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/ApplicationContextInitializer加载和初始化.png" alt="ApplicationContextInitializer加载和初始化">
</div>
</div>
<div class="paragraph">
<p><strong>setInitializers</strong> 方法会把获取到的 <strong>ApplicationContextInitializer</strong> 实例集合添加到 <strong>SpringApplication</strong> 的成员变量 <strong>initializers</strong> 中。代码如下图：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/SpringApplication中的setInitializers方法.png" alt="SpringApplication中的setInitializers方法">
</div>
</div>
</div>
<div class="sect4">
<h5 id="_applicationlistener加载">ApplicationListener加载</h5>
<div class="paragraph">
<p>完成了 ApplicationContextInitializer 的加载后，就会进行 ApplicationListener 的加载。它的常见应用场景为：当容器初始化完成之后，需要处理一些 <strong>数据的加载、初始化缓存、特定任务的注册</strong> 等操作。而在此阶段，更多的是 <strong>用于 ApplicationContext 管理 Bean 过程</strong> 的场景。</p>
</div>
<div class="paragraph">
<p>Spring 事件传播机制是基于观察者模式（Observer）实现的。比如，在 ApplicationContext 管理 Bean 生命周期的过程中，会将一些改变（或者行为）定义为事件（ApplicationEvent）。ApplicationContext 通过 ApplicationListener 监听 ApplicationEvent，当事件被发布之后（即 ApplicationContext 调用 publishEvent 方法），ApplicationListener 用来对事件做出具体的操作。</p>
</div>
<div class="paragraph">
<p>ApplicationListener 的整个配置和加载流程和 <strong>ApplicationContextInitializer</strong> 的加载一样，读取 <strong>META-INF/spring.factories</strong> 文件中注册的对应的配置。</p>
</div>
</div>
<div class="sect4">
<h5 id="_入口类推断">入口类推断</h5>
<div class="paragraph">
<p>创建 SpringApplication 的最后一步便是推断入口类。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_spring_boot运行流程">7.3. Spring Boot运行流程</h3>
<div class="paragraph">
<p>在完成了 SpringApplication 的实例化之后，就会执行 SpringApplication 实例的 <strong>run()</strong> 方法，即真正的开始 Spring Boot 的启动和运行。首先，我们先通过一张流程图来认识一下 <strong>run()</strong> 方法的核心操作。如下图：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/springApplication的run方法流程图.png" alt="springApplication的run方法流程图">
</div>
</div>
<div class="paragraph">
<p>从上面的流程图可以看出，SpringApplication 在 run 方法中重点做了以下操作：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>获取监听器和参数配置</p>
</li>
<li>
<p>打印Banner信息</p>
</li>
<li>
<p>创建并初始化容器</p>
</li>
<li>
<p>发送监听器通知</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当然，除了以上的这些核心操作以外，run 方法运行过程中还涉及到启动时长统计、异常报告、启动日志、异常处理等辅助操作。</p>
</div>
<div class="paragraph">
<p>对照流程图，接下来，我们具体的看一下 run 方法的源码，如下图：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/springboot运行流程run方法源码.png" alt="springboot运行流程run方法源码">
</div>
</div>
<div class="paragraph">
<p>从源码中，我们可以更加清晰的认识到 run 方法所做的事情，并且其中的核心操作被标注了出来。</p>
</div>
<div class="sect3">
<h4 id="_springapplicationrunlistener监听器">7.3.1. SpringApplicationRunListener监听器</h4>
<div class="sect4">
<h5 id="_监听器的配置与加载">监听器的配置与加载</h5>
<div class="paragraph">
<p>让我们跳过Spring Boot的计时和统计的辅助功能，直接来看 <strong>SpringApplicationRunListeners</strong> 的获取和使用。</p>
</div>
<div class="paragraph">
<p><strong>SpringApplicationRunListeners</strong> 可以理解为一个 <strong>SpringApplicationRunListener</strong> 的容器，它将 <strong>SpringApplicationRunListener</strong> 的集合赋值给 <strong>SpringApplicationRunListeners</strong> 的 <strong>listeners</strong> （成员变量）。SpringApplication 中 <strong>getRunListeners</strong> 方法如下图：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/springApplication的getRunListeners方法源码.png" alt="springApplication的getRunListeners方法源码">
</div>
</div>
<div class="paragraph">
<p>从上图中的源码，我们可以看出，<strong>SpringApplicationRunListeners</strong> 的构造方法的第二个参数是调用的 <strong>getSpringFactoriesInstances</strong> 方法，该方法会返回 <strong>SpringApplicationRunListener</strong> 的实例集合，具体源码如下图：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/获取SpringApplicationRunListener的实例集合.png" alt="获取SpringApplicationRunListener的实例集合">
</div>
</div>
<div class="paragraph">
<p>通过这段源码可以看出，<strong>SpringApplicationRunListener</strong> 的实例配置也是从 <strong>META-INF/spring.factories</strong> 中获取的。</p>
</div>
</div>
<div class="sect4">
<h5 id="_springapplicationrunlistener_源码解析">SpringApplicationRunListener 源码解析</h5>
<div class="paragraph">
<p>接口 <strong>SpringApplicationRunListener</strong> 是 SpringApplication 的 run 方法的监听器。该接口提供了一系列的方法，用户可以通过调用这些方法，在启动各个流程时加入指定的逻辑处理。下面我们通过源码和注释来了解一下该接口定义的方法以及方法的功能。如下图：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/SpringApplicationRunListener接口源码.png" alt="SpringApplicationRunListener接口源码">
</div>
</div>
<div class="paragraph">
<p>通过上方的源码我们可以看出，<strong>SpringApplicationRunListener</strong> 为 run 方法提供了各个运行阶段的监听事件处理功能。接下来我们通过一张图，展示出每个监听方法所处的位置，便于我们理解和加深记忆。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/run方法中springApplicaitonRunListener位置.png" alt="run方法中springApplicaitonRunListener位置">
</div>
</div>
</div>
<div class="sect4">
<h5 id="_实现类_eventpublishingrunlistener">实现类 EventPublishingRunListener</h5>
<div class="paragraph">
<p><strong>EventPublishingRunListener</strong> 是 Spring Boot 中针对 <strong>SpringApplicationRunListener</strong> 接口的唯一实现。</p>
</div>
<div class="paragraph">
<p><strong>默认情况下，Spring Boot 在初始化过程中触发的事件也是交给 EventPublishingRunListener 来代理实现的。</strong></p>
</div>
<div class="paragraph">
<p>接下来看一下 <strong>EventPublishingRunListener</strong> 的构造方法源码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class EventPublishingRunListener implements SpringApplicationRunListener, Ordered {

	private final SpringApplication application;

	private final String[] args;

	private final SimpleApplicationEventMulticaster initialMulticaster;

	public EventPublishingRunListener(SpringApplication application, String[] args) {
        // 成员变量赋值，SpringApplication
		this.application = application;
		this.args = args;
        // 创建 SimpleApplicationEventMulticaster 广播器
		this.initialMulticaster = new SimpleApplicationEventMulticaster();
        // 遍历 SpringApplication 初始化的时候实例化的 ApplicationListener 集合
        // 并把这些监听器添加到 广播器中
		for (ApplicationListener&lt;?&gt; listener : application.getListeners()) {
			this.initialMulticaster.addApplicationListener(listener);
		}
	}

    // 省略的代码
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>看了 <strong>EventPublishingRunListener</strong> 构造方法源码后，接下来我们看一下在 EventPublishingRunListener 中事件的处理流程到底是怎样的。</p>
</div>
<div class="paragraph">
<p>EventPublishingRunListener 针对不同的时间提供了不同的处理方法，但是它们的处理流程基本相同，处理流程如下图：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/EventPublishingRunListener事件处理流程.png" alt="EventPublishingRunListener事件处理流程">
</div>
</div>
<div class="paragraph">
<p>根据上面流程图我们梳理一下整个事件的流程：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>程序启动到某个步骤以后，调用 EventPublishingRunListener 的某个方法（比如：starting() 方法）。</p>
</li>
<li>
<p>EventPublishingRunListener 的具体方法将 application 参数和 args 参数封装到对应的事件中。这里的事件均为 SpringApplicationEvent 的实现类。</p>
</li>
<li>
<p>通过成员变量 initialMulticaster 的 multicastEvent 方法对事件进行广播，或通过该方法的 ConfigurableApplicationContext 参数的 publishEvent 方法来对事件进行发布。</p>
</li>
<li>
<p>对应的 ApplicationListener 被触发，执行相应的业务逻辑。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>下面，我们可以看一下 EventPublishingRunListener 的 starting 方法，对照上述流程进行理解。其他的方法功能是类似的，就不全部分析了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public void starting() {
	// 通过 initialMulticaster 的 multicastEvent 方法对事件进行广播
	this.initialMulticaster.multicastEvent(new ApplicationStartingEvent(this.application, this.args));
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_初始化applicaitonarguments">7.3.2. 初始化ApplicaitonArguments</h4>
<div class="paragraph">
<p>ApplicaitonArguments 的初始化很简单，就是调用它的实现类初始化。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_初始化configurableenvironment">7.3.3. 初始化ConfigurableEnvironment</h4>
<div class="paragraph">
<p><strong>ConfigurableEnvironment 接口的主要作用是提供当前运行环境的公开接口，比如配置文件 profiles 各类系统属性和变量的设置、添加、读取、合并等功能</strong>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_打印banner">7.3.4. 打印Banner</h4>
<div class="paragraph">
<p>完成环境的基本处理之后，就会打印 Banner 到控制台。</p>
</div>
</div>
<div class="sect3">
<h4 id="_spring_应用上下文的创建">7.3.5. Spring 应用上下文的创建</h4>
<div class="paragraph">
<p>Spring Boot 创建 Spring 的应用上下文时，如果未指定要创建的类，则会根据之前推断的Web应用类型来进行默认上下文类的创建。如下图代码：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/springApplication的createApplicationContext方法.png" alt="springApplication的createApplicationContext方法">
</div>
</div>
</div>
<div class="sect3">
<h4 id="_spring_应用上下文的准备">7.3.6. Spring 应用上下文的准备</h4>
<div class="paragraph">
<p>完成了 Spring 上下文的创建工作之后，Spring Boot 通过 SpringApplication 的 <strong>prepareContext</strong> 方法来进行上下文的准备工作，下面是该方法的源码：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spring应用上下文的准备.png" alt="spring应用上下文的准备">
</div>
</div>
<div class="paragraph">
<p>从源码分析，可以看出在该方法内完成了两个操作： <strong>应用上下文的准备和加载</strong></p>
</div>
</div>
<div class="sect3">
<h4 id="_spring_应用上下文的刷新">7.3.7. Spring 应用上下文的刷新</h4>
<div class="imageblock">
<div class="content">
<img src="images/SpringApplication的refresh方法.png" alt="SpringApplication的refresh方法">
</div>
</div>
</div>
<div class="sect3">
<h4 id="_applicationrunner_和_commandlinerunner">7.3.8. ApplicationRunner 和 CommandLineRunner</h4>
<div class="paragraph">
<p>在 refresh 完成后，就会调用 ApplicationRunner 和 CommandLineRunner。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="一些注解的作用">7.4. 一些注解的作用</h3>
<div class="paragraph">
<p>这里是关于一些在 Spring 中的注解使用的讲解。</p>
</div>
<div class="sect3">
<h4 id="Import注解">7.4.1. @Import注解</h4>
<div class="paragraph">
<p>参考文章： <a href="https://zhuanlan.zhihu.com/p/147025312" target="_blank" rel="noopener">Spring全解系列 - @Import注解</a></p>
</div>
<div class="quoteblock">
<blockquote>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>加载解析@Import注解位于  BeanFactoryPostProcessor （这个接口的作用在 <a href="#容器背后的秘密">容器背后的秘密</a> 有讲到）处理的时候。</p>
</div>
</blockquote>
</div>
</blockquote>
</div>
<div class="paragraph">
<p><strong>@Import</strong> 是Spring基于 Java 注解配置的主要组成部分。@Import 的作用和xml 配置文件里的&lt;import&gt;标签一样，下面是该注解提供的几个作用：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>通过 @Import 引入被 @Configuration 注解的类</p>
</li>
<li>
<p>通过 @Import 导入普通的类（将其注册为 Bean，但是需要 Spring 4.2 以上版本）</p>
</li>
<li>
<p>导入实现了 ImportSelector（或者 DefferredImportSelector）接口的类</p>
</li>
<li>
<p>导入实现了 ImportBeanDefinitionRegistrar 接口的类</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>下面分别说明 <strong>@Import</strong> 注解的功能。</p>
</div>
<div class="paragraph">
<div class="title"><strong>1. 通过 @Import 引入被 @Configuration 注解的类</strong></div>
<p>假设有如下的接口和两个实现类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">interface ServiceInterface {
    void test();
}

class ServiceA implements ServiceInterface {
    @Override
    public void test() {
        System.out.println("ServiceA");
    }
}

class ServiceB implements ServiceInterface {
    @Override
    public void test() {
        System.out.println("ServiceB");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>两个被 @Configuration 注解的类，其中 ConfigA 上有 @Import(ConfigB.class) 注解</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Import(ConfigB.class)
@Configuration
class ConfigA {
    @Bean
    @ConditionalOnMissingBean
    public ServiceInterface getServiceA() {
        return new ServiceA();
    }
}

@Configuration
class ConfigB {
    @Bean
    @ConditionalOnMissingBean
    public ServiceInterface getServiceB() {
        return new ServiceB();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过 ConfigA 创建 AnnotationConfigApplicationContext，获取 ServiceInterface，看是哪种实现：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(ConfigA.class);
    ServiceInterface bean = ctx.getBean(ServiceInterface.class);
    bean.test();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的代码最终输出为 <code>ServiceB</code>，说明 <strong>@Import</strong> 导入被 <strong>@Configuration</strong> 注解的类时，优先于本身的的类定义加载。</p>
</div>
<div class="paragraph">
<div class="title"><strong>2. 通过 @Import 导入普通的类</strong></div>
<p>在Spring 4.2之后，<strong>@Import 可以直接指定实体类，加载这个类定义到 Bean 到容器上下文中</strong>。 例如把上面代码中的 ConfigA 的 @Import 修改为 @Import(ServiceB.class)，就会生成 ServiceB 的 Bean 到容器上下文中。</p>
</div>
<div class="paragraph">
<p>之后运行main方法，输出为：ServiceB, 说明 <strong>@Import</strong> 导入普通类，注册为 Bean 时，优先于本身的的类定义加载。</p>
</div>
<div class="paragraph">
<div class="title"><strong>3. 导入实现了 ImportSelector（或者 DefferredImportSelector）接口的类，用于个性化加载</strong></div>
<p>@Import 的许多功能都需要借助接口 ImportSelector 来实现，ImportSelector 决定可引入哪些 @Configuration。下面是 ImportSelector 接口的源码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface importSelector {
    String[] selectImports(AnnotationMetadata importingClassMetadata);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>@Import 导入实现了 <strong>ImportSelector</strong> 接口的类，该接口提供了一个参数为 <strong>AnnotationMetadata</strong> 方法，参数 <strong>AnnotationMetadata</strong> 内包含了被 <strong>@Import</strong> 注解的类的 <strong>注解信息</strong>，返回要加载的 <strong>@Configuation</strong> 或者 <strong>具体Bean类</strong> 的全限定名的String数组（即要被实例化为 Bean 的类的全限定名的数组）。</p>
</div>
<div class="paragraph">
<p><strong>如果 @Import 所在类是注解类，则延伸至应用这个注解类的非注解类为止</strong>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class ServiceImportSelector implements ImportSelector {
    @Override
    public String[] selectImports(AnnotationMetadata importingClassMetadata) {
        //可以是@Configuration注解修饰的类，也可以是具体的Bean类的全限定名称
        // "**.**.ConfigB" 是ConfigB这个类的全限定名
        return new String[]{"**.**.ConfigB"};
    }
}

@Import(ServiceImportSelector.class)
@Configuration
class ConfigA {
    @Bean
    @ConditionalOnMissingBean
    public ServiceInterface getServiceA() {
        return new ServiceA();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>再次运行main方法，输出：<code>ServiceB</code>。</p>
</div>
<div class="paragraph">
<p>一般情况下，框架中如果基于 <strong>AnnotationMetadata</strong> 的参数实现动态加载类，一般会写一个额外的Enable注解，配合使用。如下代码，我们对 <strong>ImportSelector</strong> 接口的实现类稍作修改：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class ServiceImportSelector implements ImportSelector {
    @Override
    public String[] selectImports(AnnotationMetadata importingClassMetadata) {
        // 这里的 AnnotationMetadata 参数针对的是被 @EnableService 注解的的非注解类（即ConfigA）
        // 如果 @Import 所在类是注解类，则延伸至应用这个注解类的非注解类为止
        Map&lt;String , Object&gt; map =
            importingClassMetadata.getAnnotationAttributes(EnableService.class.getName(), true);
        String name = (String) map.get("name");
        if (Objects.equals(name, "B")) {
            return new String[]{"**.**.ConfigB"};
        }
        return new String[0];
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>定义一个注解类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Retention(RetentionPolicy.RUNTIME)
@Documented
@Target(ElementType.TYPE)
@Import(ServiceImportSelector.class)
@interface EnableService {
    String name();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>之后，在 ConfigA中增加注解 @EnableService(name = "B")</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableService(name = "B")
@Configuration
class ConfigA {
    @Bean
    @ConditionalOnMissingBean
    public ServiceInterface getServiceA() {
        return new ServiceA();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>再次运行main方法，输出：<code>ServiceB</code>。</p>
</div>
<div class="paragraph">
<p><strong>DefferredImportSelector</strong> 是 <strong>ImportSelector</strong> 的子接口，所以都可以用于个性化加载，这两个接口的区别在于，<strong>DefferredImportSelector</strong> 接口会在所有被 @Configuration 注解的类加载完成之后再加载返回的配置类，而 <strong>ImportSelector</strong> 接口实在加载完被 @Configuration 注解的类之前先去加载返回的配置类。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class DefferredServiceImportSelector implements DeferredImportSelector {
    @Override
    public String[] selectImports(AnnotationMetadata importingClassMetadata) {
        // 这里的 AnnotationMetadata 参数针对的是被 @EnableService 注解的的非注解类（即ConfigA）
        // 如果 @Import 所在类是注解类，则延伸至应用这个注解类的非注解类为止
        Map&lt;String , Object&gt; map = importingClassMetadata.getAnnotationAttributes(EnableService.class.getName(), true);
        String name = (String) map.get("name");
        if (Objects.equals(name, "B")) {
            return new String[]{"**.**.ConfigB"};
        }
        return new String[0];
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>修改 <code>EnableService</code> 注解：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Retention(RetentionPolicy.RUNTIME)
@Documented
@Target(ElementType.TYPE)
@Import(DefferredServiceImportSelector.class)
@interface EnableService {
    String name();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>执行main方法，输出：<code>ServiceA</code>，因为 实现 <strong>DeferredImportSelector</strong> 接口的类，是在被 @Configuration 注解的类加载完之后才返回的，所以 ConfigA 就优先于DefferredServiceImportSelector 返回的 ConfigB 加载。</p>
</div>
<div class="paragraph">
<div class="title"><strong>4. 导入实现了 ImportBeanDefinitionRegistrar 接口的类</strong></div>
<p>与ImportSelector用法与用途类似，该接口定义如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface ImportBeanDefinitionRegistrar {
    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该接口定义的方法中，除了有 <strong>AnnotationMetadata</strong> 类型的参数以外，还有 <strong>BeanDefinitionRegistry</strong> 类型的参数（该接口在 Spring 模块的 <a href="#BeanFactory">BeanFactory</a> 部分有讲到），通过这个参数，我们就可以重新定义 Bean，例如动态注入属性，改变 Bean 的类型和 Scope 等等。不过 <strong>ImportBeanDefinitionRegistrar</strong> 接口的实现类在 @Bean 直接之后加载，也就是说，先实例化被 @Bean 注解的类到容器中，再执行 <strong>registerBeanDefinitions</strong> 方法，最后才实例化在该方法中注册到 <strong>BeanDefinitionRegistry</strong> 中的Bean。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_data_structure_chapter">8. 数据结构</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_queue和stack">8.1. Queue和Stack</h3>
<div class="paragraph">
<p>参考文章： <a href="https://blog.csdn.net/super_YC/article/details/75208174" target="_blank" rel="noopener">两个队列实现一个栈 + 两个栈实现一个队列 Java</a></p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
队列： <code>先进先出</code> 的数据结构<br>
栈： <code>后进先出</code> 的数据结构
</td>
</tr>
</table>
</div>
<div class="paragraph">
<div class="title">两个队列实现栈</div>
<p>实现思路：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>添加元素时，优先考虑不为空的队列进行添加；</p>
</li>
<li>
<p>在输出数据的时候，先将有数据的队列的数据转到沒有数据的队列，然后执行输出操作。</p>
</li>
</ol>
</div>
<div class="paragraph">
<div class="title">两个栈实现队列</div>
<p>实现思路：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>添加元素时，只向第一个栈添加元素；</p>
</li>
<li>
<p>输出数据时，先判断第二个栈是否为空，如果为空，就将第一个栈的数据转到第二个栈，然后再输出数据。</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_MySQL_chapter">9. MySQL</h2>
<div class="sectionbody">
<div class="paragraph">
<p>MySQL 是一种开源免费并且比较成熟的关系型数据库，主要用于持久化存储我们的系统中的一些数据比如用户信息。</p>
</div>
<div class="sect2">
<h3 id="_存储引擎">9.1. 存储引擎</h3>
<div class="sect3">
<h4 id="_innodb和myisam对比">9.1.1. InnoDB和MyISAM对比</h4>
<div class="paragraph">
<p><strong>1. 是否支持事务？</strong></p>
</div>
<div class="paragraph">
<p>MyISAM 不支持，而 InnoDB 支持。</p>
</div>
<div class="paragraph">
<p><strong>2. 是否支持外键？</strong></p>
</div>
<div class="paragraph">
<p>MyISAM 不支持，而 InnoDB 支持。</p>
</div>
<div class="paragraph">
<p><strong>3. 是否支持行级锁？</strong></p>
</div>
<div class="paragraph">
<p>MyISAM 不支持，而 InnoDB 支持。</p>
</div>
</div>
<div class="sect3">
<h4 id="_存储过程">9.1.2. 存储过程</h4>
<div class="paragraph">
<p>存储过程是一段可执行性sql的集合</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_索引">9.2. 索引</h3>
<div class="paragraph">
<p><strong>索引是一种用于快速查询和检索数据的数据结构</strong>。常见的索引结构有: <strong>B 树， B+树和 Hash</strong>。</p>
</div>
<div class="sect3">
<h4 id="_索引分类">9.2.1. 索引分类</h4>
<div class="paragraph">
<p>按数据结构分类可分为：<strong>B+tree索引、Hash索引</strong>。<br>
按物理存储分类可分为：<strong>聚簇索引、非聚簇索引</strong>。<br>
按字段特性分类可分为：<strong>主键索引、二级索引（辅助索引）</strong>。<br>
按字段个数分类可分为：<strong>单列索引、联合索引（复合索引、组合索引）</strong>。</p>
</div>
<div class="sect4">
<h5 id="_按数据结构分类">按数据结构分类</h5>
<div class="sect5">
<h6 id="_hash索引">Hash索引</h6>
<div class="paragraph">
<p>哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据（接近 O（1））。</p>
</div>
<div class="paragraph">
<p>既然哈希表这么快，<strong>为什么MySQL 没有使用其作为索引的数据结构呢？</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Hash 冲突问题 ：我们上面也提到过Hash 冲突了，不过对于数据库来说这还不算最大的缺点。</p>
</li>
<li>
<p>因为经过相应的 Hash算法处理之后的 Hash 值的大小关系，并不能保证和Hash运算前完全一样。所以 Hash 索引不支持顺序和范围查询(Hash 索引不支持顺序和范围查询是它最大的缺点： 假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。</p>
</li>
</ol>
</div>
<div class="quoteblock">
<blockquote>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>InnoDB实际上也支持Hash索引，但是InnoDB中Hash索引的创建由存储引擎引擎自动优化创建，不能人为干预是否为表创建Hash索引。所以我们平常不考虑Hash索引。</p>
</div>
</blockquote>
</div>
</blockquote>
</div>
</div>
<div class="sect5">
<h6 id="_b_tree_和_btree">B-tree 和 B+tree</h6>
<div class="ulist">
<ul>
<li>
<p><strong>B 树的所有节点既存放键(key) 也存放 数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key</strong>。</p>
</li>
<li>
<p>B 树的叶子节点都是独立的；B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</p>
</li>
<li>
<p>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在 MySQL 中，MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是，两者的实现方式不太一样。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_按物理存储分类">按物理存储分类</h5>
<div class="sect5">
<h6 id="_聚簇索引">聚簇索引</h6>
<div class="paragraph">
<p>聚集索引即 <strong>索引结构</strong> 和 <strong>数据行</strong> 一起存放的索引。主键索引属于聚集索引。</p>
</div>
</div>
<div class="sect5">
<h6 id="_非聚簇索引">非聚簇索引</h6>
<div class="paragraph">
<p>非聚集索引即 <strong>索引结构</strong> 和 <strong>数据行</strong> 分开存放的索引。</p>
</div>
<div class="paragraph">
<p><strong>二级索引属于非聚集索引</strong>。所以说非聚簇索引可能 <strong>回表查询</strong>。只是说有可能，因为还有一种叫做 <strong>覆盖索引</strong> 的存在。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><strong>覆盖索引</strong></p>
</div>
<div class="paragraph">
<p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。我们知道在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</p>
</div>
<div class="paragraph">
<p>覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了， 而无需回表查询。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_按字段特性分类">按字段特性分类</h5>
<div class="sect5">
<h6 id="_主键索引">主键索引</h6>
<div class="paragraph">
<p>数据表的主键列使用的就是主键索引。</p>
</div>
<div class="paragraph">
<p>一张数据表有只能有一个主键，并且主键不能为 null，不能重复。</p>
</div>
</div>
<div class="sect5">
<h6 id="_二级索引辅助索引">二级索引（辅助索引）</h6>
<div class="paragraph">
<p>二级索引又称为辅助索引，是因为 <strong>二级索引的叶子节点存储的数据是主键</strong>。也就是说，通过二级索引，可以定位 <strong>主键</strong> 的位置。</p>
</div>
<div class="paragraph">
<p><strong>唯一索引，普通索引，前缀索引</strong> 等索引属于二级索引。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>唯一索引(Unique Key)</strong> ：唯一索引也是一种约束。唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</p>
</li>
<li>
<p><strong>普通索引(Index)</strong> ：普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。</p>
</li>
<li>
<p><strong>前缀索引(Prefix)</strong> ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_按字段个数分类">按字段个数分类</h5>
<div class="sect5">
<h6 id="_单列索引">单列索引</h6>
<div class="paragraph">
<p>建立在单个列上的索引被称为单列索引。</p>
</div>
</div>
<div class="sect5">
<h6 id="_联合索引复合索引组合索引">联合索引（复合索引、组合索引）</h6>
<div class="paragraph">
<p>建立在多个列上的索引被称为联合索引，又叫复合索引、组合索引。</p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_Mybatis_chapter">10. Mybatis</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_mybatis缓存">10.1. Mybatis缓存</h3>
<div class="paragraph">
<p>参考资料： <a href="https://tech.meituan.com/2018/01/19/mybatis-cache.html" target="_blank" rel="noopener">聊聊MyBatis缓存机制</a></p>
</div>
<div class="paragraph">
<p>mybatis提供查询缓存，用于减轻数据压力，提高数据库性能。</p>
</div>
<div class="sect3">
<h4 id="_一级缓存">10.1.1. 一级缓存</h4>
<div class="paragraph">
<p>一级缓存的 <strong>作用域是同一个SqlSession</strong>，在同一个sqlSession中两次执行相同的sql语句，第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从缓存中获取数据将不再从数据库查询，从而提高查询效率。不过需要注意的是，如果在同一个SqlSession中，修改了数据，刚刚存入的缓存就会失效，会重新从数据库查询。当一个sqlSession结束后该sqlSession中的一级缓存也就不存在了。</p>
</div>
<div class="paragraph">
<p><strong>Mybatis默认开启一级缓存</strong>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_二级缓存">10.1.2. 二级缓存</h4>
<div class="paragraph">
<p>二级缓存是多个SqlSession共享的，其 <strong>作用域是mapper的同一个namespace</strong>，不同的sqlSession两次执行相同namespace下的sql语句且向sql中传递参数也相同即最终执行相同的sql语句，第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从缓存中获取数据将不再从数据库查询，从而提高查询效率。</p>
</div>
<div class="paragraph">
<p>Mybatis默认没有开启二级缓存需要在setting全局参数中配置开启二级缓存。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_mybatis常见问题">10.2. Mybatis常见问题</h3>
<div class="paragraph">
<div class="title">1. #{}和${}的区别是什么？</div>
<p>${} 是变量占位符，#{} 是参数占位符</p>
</div>
<div class="paragraph">
<div class="title">2. Mybatis中常见标签</div>
<p><strong>trim</strong> | <strong>where</strong> | <strong>set</strong> | <strong>foreach</strong> | <strong>if</strong> | <strong>choose</strong> | <strong>when</strong> | <strong>otherwise</strong> | <strong>bind</strong></p>
</div>
<div class="paragraph">
<div class="title">3. Mapper接口和xml文件对应，实现原理是什么？</div>
<p>Mapper 接口的全限定名和xml中的namespace对应，id与方法名对应，<strong>namespace + id</strong> 确定唯一的sql。</p>
</div>
<div class="ulist">
<div class="title">4. Mybatis分页原理？</div>
<ul>
<li>
<p>MyBatis 使用 <strong>RowBounds</strong> 对象进行分页，它是针对 <strong>ResultSet</strong> 结果集执行的内存分页，而非物理分页</p>
</li>
<li>
<p>可以在 sql 内直接书写带有物理分页的参数来完成物理分页功能</p>
</li>
<li>
<p>也可以使用分页插件来完成物理分页，分页插件的原理就是执行SQL前会拦截SQL，在SQL中加上 limit 实现分页</p>
</li>
</ul>
</div>
<div class="olist arabic">
<div class="title">5. MyBatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？</div>
<ol class="arabic">
<li>
<p>通过 resultMap 指定映射关系</p>
</li>
<li>
<p>通过在SQL中用别名来实现，比如说，<code>select user_name as userName from user;</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<div class="title">6. 简述 MyBatis 的插件运行原理，以及如何编写一个插件。</div>
<p>Mybatis 插件其实是通过 <strong>JDK动态代理</strong> 实现的。如果要实现一个插件，只需要实现 <strong>InvocationHandler</strong>，指定拦截方法就行了。</p>
</div>
<div class="paragraph">
<div class="title">7. Mybatis一对一，一对多关联查询</div>
<p>一对一关联查询：使用 <strong>association</strong> 标签<br>
一对多关联查询：使用 <strong>collection</strong> 标签</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_Netty_chapter">11. Netty</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Netty是一个基于 NIO 的网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端。</p>
</div>
<div class="sect2">
<h3 id="_常见问题">11.1. 常见问题</h3>
<div class="paragraph">
<div class="title">TCP粘包、拆包解决办法？</div>
<p>发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度。<br>
发送端将每个数据包封装为固定长度（不够的可以通过补0填充）。<br>
可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。</p>
</div>
<div class="paragraph">
<div class="title">什么是netty？为什么要用netty？netty的应用场景？</div>
<p>netty是基于NIO的网络通信框架，能够快速简单的开发网络应用程序<br>
极大的优化了TCP，UDP套接字服务器编程，性能更好，更加安全；支持多种协议（http，ftp，rtp等）；自带解码器（如可以解决TCP粘包，拆包）<br>
作为rpc框架通信工具，实现http服务器，即时通讯，消息推送等</p>
</div>
<div class="paragraph">
<div class="title">netty的组件有哪些？分别有什么作用？</div>
<p>Channel：Channel是 Netty 抽象出来对网络 I/O 进行操作的接口，如 bind()、connect()、read()、write() 等<br>
EventLoop（事件循环）：EventLoop 的主要作用实际就是负责监听网络事件并调用事件处理器进行相关 I/O 操作的处理。<br>
ChannelHandler：ChannelHandler 是消息的具体处理器，<br>
ChannelPipeline：ChannelPipeline 为 ChannelHandler 的链，因为一条消息可以被多个ChannelHandler处理，我们可以在 ChannelPipeline 上通过 addLast() 方法添加一个或者多个ChannelHandler，让消息按照顺序被处理。</p>
</div>
<div class="paragraph">
<div class="title">EventloopGroup 了解么?和 EventLoop 啥关系?</div>
<p>EventLoopGroup 包含多个 EventLoop<br>
我们实现服务端的时候，一般会初始化两个线程组：<br>
bossGroup :接收连接。<br>
workerGroup ：负责具体的处理，交由对应的 Handler 处理。</p>
</div>
<div class="paragraph">
<div class="title">netty的线程模型？</div>
<p>单线程模型：所有的 I/O 操作都由一个线程完成，既要监听客户端连接，又要又要发送/读取请求或应答/响应消息<br>
多线程模型：一个 Acceptor 线程只负责监听客户端的连接，一个 NIO 线程池负责网络的 I/O 操作<br>
主从多线程模型：从一个 主线程 NIO 线程池中选择一个线程作为 Acceptor 线程，绑定监听端口，接收客户端连接的连接，其他线程负责后续的接入认证等工作。连接建立完成后，Sub NIO 线程池负责具体处理 I/O 读写。</p>
</div>
<div class="paragraph">
<div class="title">零拷贝</div>
<p>Netty的零拷贝体现在三个方面：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Netty 接收和发送 ByteBuffer 采用的都是堆外直接内存，使用堆外直接内存进行 Socket 的读/写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存进行 Socket 的读/写，则 JVM 会将堆内存Buffer数据拷贝到堆外直接内存中，然后才写入Socket中。与堆外直接内存相比，使用传统的堆内存，在消息发送过程中多了一次缓冲区的内存拷贝</p>
</li>
<li>
<p>在网络传输中，一条消息可能会被分割成多个多个数据包进行发送，只有当收到一个完整的数据包后，才能完成解码工作。Netty 通过组合内存的方式把这些数据包组合到一块，而不是对每个数据块进行一次拷贝。</p>
</li>
<li>
<p>传统拷贝文件的方法需要先把文件采用 FileInputStream 文件输入流读取到一个临时的 byte[] 数组中，然后通过 FileOutputStream 文件输出流，把临时的 byte[] 数据内容写入到目的文件中。当拷贝大文件时，频繁的内存拷贝操作会消耗大量的系统资源。Netty 底层运用 Java NIO d的 FileChannel.transfer() 方法，该方法依赖操作系统实现零拷贝，可以直接将文件缓冲区的数据发送到目标的 Channel 中，避免了传统的通过循环方式导致的内存数据拷贝问题。</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_分布式_chapter">12. 分布式</h2>
<div class="sectionbody">
<div class="paragraph">
<p>分布式系统就是一组计算机系统，原先由一台计算机完成的任务，交给多个计算机，通过网络相互连接传递消息与通信后并协调它们的行为而形成的系统。组件之间彼此进行交互以实现一个共同的目标。</p>
</div>
<div class="sect2">
<h3 id="_cap理论">12.1. CAP理论</h3>
<div class="paragraph">
<p>CAP 也就是 Consistency（一致性）、Availability（可用性）、Partition Tolerance（分区容错性） 这三个单词首字母组合。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/cap理论.png" alt="cap理论">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>一致性（Consistence） : 所有节点访问同一份最新的数据副本</p>
</li>
<li>
<p>可用性（Availability）: 非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）。</p>
</li>
<li>
<p>分区容错性（Partition tolerance） : 分布式系统出现网络分区的时候，仍然能够对外提供服务。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>什么是网络分区？</strong></p>
</div>
<div class="paragraph">
<p>分布式系统中，多个节点之前的网络本来是连通的，但是因为某些故障（比如部分节点网络出了问题）某些节点之间不连通了，整个网络就分成了几块区域，这就叫网络分区。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>当发生网络分区的时候，如果我们要继续服务，那么强一致性和可用性只能 2 选 1。也就是说当网络分区之后 P 是前提，决定了 P 之后才有 C 和 A 的选择。也就是说分区容错性（Partition tolerance）我们是必须要实现的。</p>
</div>
</blockquote>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>简而言之就是：<strong>CAP 理论中分区容错性 P 是一定要满足的，在此基础上，只能满足可用性 A 或者一致性 C。</strong></p>
</div>
<div class="paragraph">
<p>因此，分布式系统理论上不可能选择 CA 架构，只能选择 CP 或者 AP 架构。 比如 ZooKeeper、HBase 就是 CP 架构，Cassandra、Eureka 就是 AP 架构，Nacos 不仅支持 CP 架构也支持 AP 架构。</p>
</div>
<div class="paragraph">
<p>选择 CP 还是 AP 的关键在于当前的业务场景，没有定论，比如对于需要确保强一致性的场景如银行一般会选择保证 CP 。</p>
</div>
</div>
<div class="sect2">
<h3 id="_base理论">12.2. Base理论</h3>
<div class="paragraph">
<p>BASE 是 Basically Available（基本可用） 、Soft-state（软状态） 和 Eventually Consistent（最终一致性） 三个短语的缩写。BASE 理论是对 CAP 中一致性 C 和可用性 A 权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于 CAP 定理逐步演化而来的，它大大降低了我们对系统的要求。</p>
</div>
<div class="sect3">
<h4 id="_base理论的核心思想">12.2.1. BASE理论的核心思想</h4>
<div class="paragraph">
<p>即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>也就是牺牲数据的一致性来满足系统的高可用性，系统中一部分数据不可用或者不一致时，仍需要保持系统整体“主要可用”。</p>
</div>
</blockquote>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>BASE 理论本质上是对 CAP 的延伸和补充，更具体地说，是对 CAP 中 AP 方案的一个补充。</p>
</div>
<div class="paragraph">
<p><strong>为什么这样说呢？</strong></p>
</div>
<div class="paragraph">
<p>CAP 理论这节我们也说过了：</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>如果系统没有发生“分区”的话，节点间的网络连接通信正常的话，也就不存在 P 了。这个时候，我们就可以同时保证 C 和 A 了。因此，如果系统发生“分区”，我们要考虑选择 CP 还是 AP。如果系统没有发生“分区”的话，我们要思考如何保证 CA 。</p>
</div>
</blockquote>
</div>
</blockquote>
</div>
</div>
<div class="sect3">
<h4 id="_base理论三要素">12.2.2. Base理论三要素</h4>
<div class="imageblock">
<div class="content">
<img src="images/base理论.png" alt="base理论">
</div>
</div>
<div class="paragraph">
<div class="title">1. 基本可用</div>
<p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。但是，这绝不等价于系统不可用。</p>
</div>
<div class="paragraph">
<p><strong>什么叫允许损失部分可用性呢？</strong></p>
</div>
<div class="paragraph">
<p>响应时间上的损失: 正常情况下，处理用户请求需要 0.5s 返回结果，但是由于系统出现故障，处理用户请求的时间变为 3 s。<br>
系统功能上的损失：正常情况下，用户可以使用系统的全部功能，但是由于系统访问量突然剧增，系统的部分非核心功能无法使用。</p>
</div>
<div class="paragraph">
<div class="title">2. 软状态</div>
<p>软状态指允许系统中的数据存在中间状态（CAP 理论中的数据不一致），并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p>
</div>
<div class="paragraph">
<div class="title">3. 最终一致性</div>
<p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_分布式事务">12.3. 分布式事务</h3>
<div class="paragraph">
<p>参考文档： <a href="https://www.infoq.cn/article/thmgmfvqvpwp9yrrxpmw" target="_blank" rel="noopener">一文讲透微服务架构下如何保证事务的一致性</a></p>
</div>
<div class="sect3">
<h4 id="_强一致性解决方案">12.3.1. 强一致性解决方案</h4>
<div class="sect4">
<h5 id="_二段提交协议">二段提交协议</h5>
<div class="imageblock">
<div class="content">
<img src="images/二段提交协议.webp" alt="二段提交协议" width="800">
</div>
</div>
<div class="paragraph">
<p>缺点： 容易造成同步阻塞问题</p>
</div>
</div>
<div class="sect4">
<h5 id="_三段提交协议">三段提交协议</h5>
<div class="imageblock">
<div class="content">
<img src="images/三段提交协议.webp" alt="三段提交协议" width="800">
</div>
</div>
<div class="paragraph">
<p>三阶段提交协议是二阶段提交协议的改良版本，它与二阶段提交协议不同之处在于，引入了超时机制解决同步阻塞问题，此外加入了预备阶段尽可能提早发现无法执行的资源管理者（参与者）并且终止事务，如果全部资源管理者（参与者）都可以完成，才发起第二阶段的准备和第三阶段的提交。</p>
</div>
<div class="paragraph">
<p>缺点： 因为三阶段提交协议引入了超时机制，如果出现资源管理者（参与者）超时场景会默认提交成功，但是如果其没有成功执行，或者其他资源管理者（参与者）出现回滚，那么就会出现数据的不一致性。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_最终一致性解决方案">12.3.2. 最终一致性解决方案</h4>
<div class="sect4">
<h5 id="_tcc补偿事务">TCC（补偿事务）</h5>
<div class="paragraph">
<p>TCC 模式将一个任务拆分三个操作：Try、Confirm、Cancel。</p>
</div>
<div class="paragraph">
<p><strong>TCC 模式的流程</strong>：</p>
</div>
<div class="paragraph">
<p>第一阶段主业务服务调用全部的从业务服务的 Try 操作，并且事务管理器记录操作日志。第二阶段，当全部从业务服务都成功时，再执行 Confirm 操作，否则会执行 Cancel 逆操作进行回滚。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/TCC流程.webp" alt="TCC流程" width="800">
</div>
</div>
<div class="sect5">
<h6 id="_tcc_transaction框架">tcc-transaction框架</h6>
<div class="paragraph">
<p>tcc-transaction实战案例: <a href="https://blog.csdn.net/a251628111/article/details/107203846" target="_blank" rel="noopener">TCC分布式事务之一 —— tcc-transaction-1.2.x最新版整合spring cloud + dubbo + zookeeper</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// try 方法
@Compensable(confirmMethod = "confirmRecord", cancelMethod = "cancelRecord", transactionContextEditor = MethodTransactionContextEditor.class)
@Transactional
public String record(TransactionContext transactionContext, CapitalTradeOrderDto tradeOrderDto) {}

// confirm 方法
@Transactional
public void confirmRecord(TransactionContext transactionContext, CapitalTradeOrderDto tradeOrderDto) {}

// cancel 方法
@Transactional
public void cancelRecord(TransactionContext transactionContext, CapitalTradeOrderDto tradeOrderDto) {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于 tcc-transaction 框架的实现，我们来了解一些核心思路。tcc-transaction 框架通过 @Compensable 切面进行拦截，可以透明化对参与者 confirm / cancel 方法调用，从而实现 TCC 模式。</p>
</div>
<div class="paragraph">
<p>其中，事务编号  TransactionXid  用于唯一标识一个事务，它使用 UUID 算法生成，保证唯一性。当参与者进行远程调用时，远程的分支事务的事务编号等于该参与者的事务编号。通过事务编号的关联 TCC confirm / cancel 方法，使用参与者的事务编号和远程的分支事务进行关联，从而实现事务的提交和回滚。事务状态 TransactionStatus 包含 ： 尝试中状态 TRYING(1)、确认中状态 CONFIRMING(2)、取消中状态 CANCELLING(3)。此外，事务类型 TransactionType 包含 ： 根事务 ROOT(1)、分支事务 BRANCH(2)。</p>
</div>
<div class="paragraph">
<p>此外，对于事务恢复机制，tcc-transaction 框架基于 Quartz 实现调度，按照一定频率对事务进行重试，直到事务完成或超过最大重试次数。如果单个事务超过最大重试次数时，tcc-transaction 框架不再重试，此时需要手工介入解决。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_本地消息表异步确保">本地消息表（异步确保）</h5>
<div class="paragraph">
<p>本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务来保证在对这两个表的操作满足事务特性，并且使用了消息队列来保证最终一致性。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中。</p>
</li>
<li>
<p>之后将本地消息表中的消息转发到 Kafka 等消息队列中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。</p>
</li>
<li>
<p>在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。</p>
</li>
</ol>
</div>
<div class="imageblock">
<div class="content">
<img src="images/分布式事务之异步确保.jpg" alt="分布式事务之异步确保">
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_消息队列_chapter">13. 消息队列</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_什么是消息队列">13.1. 什么是消息队列</h3>
<div class="paragraph">
<p>就是一个中间件，可以把消息队列看作是一个存放消息的容器。</p>
</div>
<div class="paragraph">
<p><strong>为什么要使用消息队列？</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>通过异步处理提高系统性能（减少响应所需时间）</strong>。</p>
</li>
<li>
<p><strong>削峰/限流</strong></p>
</li>
<li>
<p><strong>降低系统耦合性</strong>。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_kafka">13.2. Kafka</h3>
<div class="paragraph">
<p>Kafka java语言开发，吞吐量大。</p>
</div>
<div class="sect3">
<h4 id="_kafka的组件">13.2.1. Kafka的组件</h4>
<div class="paragraph">
<p><strong>生产者（Producer），消费者（Consumer），经纪人（Broker），主题（Topic），分区（Queue）</strong></p>
</div>
</div>
<div class="sect3">
<h4 id="_kafka的模型">13.2.2. Kafka的模型</h4>
<div class="paragraph">
<p><strong>发布-订阅模型</strong></p>
</div>
</div>
<div class="sect3">
<h4 id="_kafka多副本机制">13.2.3. Kafka多副本机制</h4>
<div class="literalblock">
<div class="content">
<pre>Kafka 为分区（Partition）引入了多副本（Replica）机制。分区（Partition）中的多个副本之间会有一个叫做 leader 的家伙，其他副本称为 follower。我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_zookeeper_在_kafka_中的作用">13.2.4. Zookeeper 在 Kafka 中的作用</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Broker注册</strong>： Zookeeper 上会有一个专门 <strong>用来进行 Broker 服务器列表记录的节点</strong>。</p>
</li>
<li>
<p><strong>负载均衡</strong></p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_kafka如何保证消息的消费顺序">13.2.5. Kafka如何保证消息的消费顺序</h4>
<div class="paragraph">
<p>第一种方法： <strong>Kafka 可以保证 Partition 中的消息有序，所以只要保证一个 Topic 只有一个 分区就能够保证消息的消费顺序</strong>。</p>
</div>
<div class="paragraph">
<p>第二种方法： Kafka 中发送 1 条消息的时候，可以指定 topic, partition, key,data（数据） 4 个参数，<strong>发送消息的时候指定分区发送也可以保证消息的消费顺序</strong>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_kafka如何保证消息不丢失">13.2.6. Kafka如何保证消息不丢失</h4>
<div class="paragraph">
<p>Kafka 消息丢失分三种情况，生产者丢失消息，kafka自己丢失消息，消费者丢失消息。</p>
</div>
<div class="paragraph">
<p>下面根据这三种情况分别提出解决方案：</p>
</div>
<div class="sect4">
<h5 id="_生产者丢失消息">生产者丢失消息</h5>
<div class="paragraph">
<p><strong>使用带回调方法的 API</strong>。如下代码 API：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">   Future&lt;RecordMetadata&gt; send(ProducerRecord&lt;K, V&gt; record, Callback callback)</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用带有回调方法的 API 时，我们可以根据回调函数得知消息是否发送成功，如果发送失败了，我们要进行异常处理，比如把失败消息存储到本地硬盘或远程数据库，等应用正常了再发送，这样才能保证消息不丢失。</p>
</div>
<div class="paragraph">
<p>这里我们还需要设置 <strong>重试次数（retries）</strong>，和 <strong>重试时间间隔（retry.backoff.ms=300）</strong></p>
</div>
</div>
<div class="sect4">
<h5 id="_kafka自己丢失消息">kafka自己丢失消息</h5>
<div class="paragraph">
<p>设置参数 <strong>保证 leader 副本能有 follower 副本</strong>，并 <strong>保证至少需要两个副本被写入数据才算成功</strong>。</p>
</div>
</div>
<div class="sect4">
<h5 id="_消费者丢失消息">消费者丢失消息</h5>
<div class="paragraph">
<p>关闭 <strong>自动提交 offset</strong>，每次在真正消费完消息之后之后再自己 <strong>手动提交 offset</strong>。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_kafka如何保证消息不重复">13.2.7. Kafka如何保证消息不重复</h4>
<div class="sect4">
<h5 id="_生产端不重复生产消息">生产端不重复生产消息</h5>
<div class="paragraph">
<p>每个生产端生成一个唯一的 ID，并且在每条消息中生成一个 <strong>sequence num</strong>，sequence num 是 <strong>递增且唯一</strong> 的，这样就能对消息去重，达到一个生产端不重复发送一条消息的目的。</p>
</div>
</div>
<div class="sect4">
<h5 id="_消费端不能重复消费消息">消费端不能重复消费消息</h5>
<div class="paragraph">
<p>通过对每条消息设置一个 ID，每次消费前，校验一下此条消息是否已经被消费过了。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_kafka常见问题">13.2.8. Kafka常见问题</h4>
<div class="sect4">
<h5 id="_kafka_重启消费者后从分区的哪里开始重新消费队列头队列尾上一次消费位置">Kafka 重启消费者后，从分区的哪里开始重新消费（队列头？队列尾？上一次消费位置？）</h5>
<div class="paragraph">
<p>参考文档： <a href="https://blog.csdn.net/lishuangzhe7047/article/details/74530417" target="_blank" rel="noopener">Kafka auto.offset.reset值详解</a></p>
</div>
<div class="paragraph">
<p>这个问题的关键在于 <strong>auto.offset.reset</strong> 的设置，<strong>auto.offset.reset</strong> 有三个值，<strong>earliest，latest，none</strong>。</p>
</div>
<div class="paragraph">
<p><strong>earliest</strong>： 当各分区下有已提交的offset时，从提交的offset开始消费；无提交的offset时，从头开始消费。<br>
<strong>latest</strong>： 当各分区下有已提交的offset时，从提交的offset开始消费；无提交的offset时，只消费当前消费者启动完成后生产者新生产的数据。<br>
<strong>none</strong>： topic各分区都存在已提交的offset时，从offset后开始消费；只要有一个分区不存在已提交的offset，则抛出异常</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_rabbitmq">13.3. RabbitMQ</h3>
<div class="paragraph">
<p>RabbitMQ 是基于 erlang 开发的，并发能力强，性能极好，延时低。</p>
</div>
<div class="sect3">
<h4 id="_rabbitmq的组件">13.3.1. RabbitMQ的组件</h4>
<div class="paragraph">
<p><strong>生产者（Producer），消费者（Consumer），经纪人（Broker），交换器（Exchange），消息队列（Queue）</strong></p>
</div>
</div>
<div class="sect3">
<h4 id="_rabbitmq消息消费流程">13.3.2. RabbitMQ消息消费流程</h4>
<div class="paragraph">
<p>下图展示了生产者将消息存入 RabbitMQ Broker,以及消费者从Broker中消费数据的整个流程。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/RabbitMQ消息使用流程.jpg" alt="RabbitMQ消息使用流程">
</div>
</div>
</div>
<div class="sect3">
<h4 id="_rabbitmq消息模型">13.3.3. RabbitMQ消息模型</h4>
<div class="sect4">
<h5 id="_基本消息模型">基本消息模型</h5>
<div class="paragraph">
<p>就是正常的消息消费，生产者生产消息放入队列中，然后消费者消费这条消息</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/RabbitMQ之基本消息模型.png" alt="RabbitMQ之基本消息模型">
</div>
</div>
</div>
<div class="sect4">
<h5 id="_work消息模型">work消息模型</h5>
<div class="paragraph">
<p>工作队列，又称为任务队列。</p>
</div>
<div class="paragraph">
<p>让多个消费者绑定到一个队列，共同消费队列中的消息，但是一个消息只能被一个消费者获取。队列中的消息一旦消费，就会消失，因此任务是不会被重复执行的。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/RabbitMQ之work消息模型.png" alt="RabbitMQ之work消息模型">
</div>
</div>
</div>
<div class="sect4">
<h5 id="_订阅模型三种">订阅模型（三种）</h5>
<div class="sect5">
<h6 id="_订阅模型_fanout广播">订阅模型-Fanout（广播）</h6>
<div class="paragraph">
<p>广播，交换机把消息发送给绑定过的所有队列，实现一条消息被多个消费者消费。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/RabbitMQ之订阅模型-Fanout.png" alt="RabbitMQ之订阅模型 Fanout">
</div>
</div>
</div>
<div class="sect5">
<h6 id="_订阅模型_direct定向">订阅模型-Direct（定向）</h6>
<div class="paragraph">
<p>定向，把消息发送给符合指定 routingKey 的队列</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/RabbitMQ之订阅模型-Direct.png" alt="RabbitMQ之订阅模型 Direct">
</div>
</div>
</div>
<div class="sect5">
<h6 id="_订阅模型_topic通配符">订阅模型-Topic（通配符）</h6>
<div class="paragraph">
<p>通配符，根据通配符把消息发送给符合的队列</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/RabbitMQ之订阅模型-Topic.png" alt="RabbitMQ之订阅模型 Topic">
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_rabbitmq如何保证消息不丢失">13.3.4. RabbitMQ如何保证消息不丢失</h4>
<div class="paragraph">
<p>RabbitMQ 消息丢失分三种情况，生产者丢失消息，rabbitmq自己丢失消息，消费者丢失消息。</p>
</div>
<div class="paragraph">
<p>下面根据这三种情况分别提出解决方案：</p>
</div>
<div class="sect4">
<h5 id="_生产者丢失消息_2">生产者丢失消息</h5>
<div class="paragraph">
<p>第一种方式： 使用rabbitmq提供的事务功能，开启事务后，如果消息没有成功被rabbitmq接收，生产者就会报错，这时就可以回滚事务，然后尝试重新发送。成功就提交事务。</p>
</div>
<div class="paragraph">
<p>第二种方式： 可以开启confirm模式，每次写消息都会分配一个唯一的id，如果写入消息成功，会返回一个ack，告诉你消息发送成功；如果写入消息没有成功，就可以回调一个nack接口，告诉你消息发送失败，然后你就可以重试。</p>
</div>
<div class="paragraph">
<p>需要注意的是： 事务机制是 <strong>同步阻塞</strong> 的；confirm机制是 <strong>异步</strong> 的，因为消息发送失败，rabbitmq会回调告知是否成功。</p>
</div>
</div>
<div class="sect4">
<h5 id="_rabbitmq自己丢失消息">rabbitmq自己丢失消息</h5>
<div class="paragraph">
<p>可以设置消息持久化到磁盘。</p>
</div>
</div>
<div class="sect4">
<h5 id="_消费者丢失消息_2">消费者丢失消息</h5>
<div class="paragraph">
<p>可以关闭掉 rabbitmq 自动的 ack ，使用手动的 ack，每次在确保处理完这个消息之后，在代码里手动调用ack。这样就可以避免消息还没有处理完就ack。</p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2022-01-06 15:17:00 +0800
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/highlight.min.js"></script>
<script>
if (!hljs.initHighlighting.called) {
  hljs.initHighlighting.called = true
  ;[].slice.call(document.querySelectorAll('pre.highlight > code[data-lang]')).forEach(function (el) { hljs.highlightBlock(el) })
}
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
})
MathJax.Hub.Register.StartupHook("AsciiMath Jax Ready", function () {
  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {
    if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains("stemblock")) {
      data.math.root.display = "block"
    }
    return data
  })
})
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
</body>
</html>